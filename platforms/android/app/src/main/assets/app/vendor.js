(global["webpackJsonp"] = global["webpackJsonp"] || []).push([["vendor"],{

/***/ "../node_modules/@nativescript/webpack/helpers/hot.js":
/***/ (function(module, exports, __webpack_require__) {

const hmrPrefix = 'HMR:';
const log = {
  info: message => console.info(`${hmrPrefix} ${message}`),
  warn: message => console.warn(`${hmrPrefix} ${message}`),
  error: message => console.error(`${hmrPrefix} ${message}`)
};
const refresh = 'Application needs to be restarted in order to apply the changes.';
const hotOptions = {
  ignoreUnaccepted: false,
  ignoreDeclined: false,
  ignoreErrored: false,

  onUnaccepted(data) {
    const chain = [].concat(data.chain);
    const last = chain[chain.length - 1];

    if (last === 0) {
      chain.pop();
    }

    log.warn(`Ignored an update to unaccepted module: `);
    chain.forEach(mod => log.warn(`         ➭ ${mod}`));
  },

  onDeclined(data) {
    log.warn(`Ignored an update to declined module:`);
    data.chain.forEach(mod => log.warn(`         ➭ ${mod}`));
  },

  onErrored(data) {
    log.warn(`Ignored an error while updating module ${data.moduleId} <${data.type}>`);
    log.warn(data.error);
  }

};
let nextHash;
let currentHash;

function upToDate() {
  return nextHash.indexOf(__webpack_require__.h()) >= 0;
}

function result(modules, appliedModules) {
  const unaccepted = modules.filter(moduleId => appliedModules && appliedModules.indexOf(moduleId) < 0);

  if (unaccepted.length > 0) {
    log.warn('The following modules could not be updated:');

    for (const moduleId of unaccepted) {
      log.warn(`          ⦻ ${moduleId}`);
    }
  }

  if (!(appliedModules || []).length) {
    log.info('No Modules Updated.');
  } else {
    log.info('The following modules were updated:');

    for (const moduleId of appliedModules) {
      log.info(`         ↻ ${moduleId}`);
    }

    const numberIds = appliedModules.every(moduleId => typeof moduleId === 'number');

    if (numberIds) {
      log.info('Please consider using the NamedModulesPlugin for module names.');
    }
  }
}

function check(options) {
  return module.hot.check().then(modules => {
    if (!modules) {
      log.warn(`Cannot find update. ${refresh}`);
      return null;
    }

    return module.hot.apply(hotOptions).then(appliedModules => {
      let nextCheck;

      if (!upToDate()) {
        nextCheck = check(options);
      }

      result(modules, appliedModules);

      if (upToDate()) {
        // Do not modify message - CLI depends on this exact content to determine hmr operation status.
        log.info(`Successfully applied update with hmr hash ${currentHash}. App is up to date.`);
      }

      return nextCheck || null;
    }).catch(err => {
      const status = module.hot.status();

      if (['abort', 'fail'].indexOf(status) >= 0) {
        // Do not modify message - CLI depends on this exact content to determine hmr operation status.
        log.error(`Cannot apply update with hmr hash ${currentHash}.`);
        log.error(err.message || err.stack);
      } else {
        log.error(`Update failed: ${err.message || err.stack}`);
      }
    });
  }).catch(err => {
    const status = module.hot.status();

    if (['abort', 'fail'].indexOf(status) >= 0) {
      log.error(`Cannot check for update. ${refresh}`);
      log.error(err.message || err.stack);
    } else {
      log.error(`Update check failed: ${err.message || err.stack}`);
    }
  });
}

if (true) {
  log.info('Hot Module Replacement Enabled. Waiting for signal.');
} else {}

function update(latestHash, options) {
  nextHash = latestHash;

  if (!upToDate()) {
    const status = module.hot.status();

    if (status === 'idle') {
      //Do not modify message - CLI depends on this exact content to determine hmr operation status.
      log.info(`Checking for updates to the bundle with hmr hash ${currentHash}.`);
      return check(options);
    } else if (['abort', 'fail'].indexOf(status) >= 0) {
      log.warn(`Cannot apply update. A previous update ${status}ed. ${refresh}`);
    }
  }
}

;

function getNextHash(hash, getFileContent) {
  const file = getFileContent(`${hash}.hot-update.json`);

  if (!file) {
    return Promise.resolve(hash);
  }

  return file.readText().then(hotUpdateContent => {
    if (hotUpdateContent) {
      const manifest = JSON.parse(hotUpdateContent);
      const newHash = manifest.h;
      return getNextHash(newHash, getFileContent);
    } else {
      return Promise.resolve(hash);
    }
  }).catch(error => Promise.reject(error));
}

module.exports = function checkState(initialHash, getFileContent) {
  currentHash = initialHash;
  return getNextHash(initialHash, getFileContent).then(nextHash => {
    if (nextHash != initialHash) {
      return update(nextHash, {});
    }
  });
};

/***/ }),

/***/ "../node_modules/@nativescript/webpack/helpers/load-application-css-regular.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {const loadCss = __webpack_require__("../node_modules/@nativescript/webpack/helpers/load-application-css.js");

module.exports = function () {
  loadCss(function () {
    const appCssContext = __webpack_require__("./ sync ^\\.\\/app\\.(css|scss|less|sass)$");

    global.registerWebpackModules(appCssContext);
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/@nativescript/webpack/helpers/load-application-css.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = function (loadModuleFn) {
  const nsCore = __webpack_require__("@nativescript/core");

  __webpack_require__("@nativescript/core/ui/styling/style-scope");

  loadModuleFn();
  nsCore.Application.loadAppCss();
};

/***/ }),

/***/ "../node_modules/@nativescript/webpack/hmr/hmr-update.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hmrUpdate = void 0;

const hot = __webpack_require__("../node_modules/@nativescript/webpack/helpers/hot.js");

function hmrUpdate() {
  const coreFile = __webpack_require__("@nativescript/core");

  const currentAppFolder = coreFile.knownFolders.currentApp();

  const latestHash = __webpack_require__['h']();

  return hot(latestHash, filename => {
    const fullFilePath = coreFile.path.join(currentAppFolder.path, filename);
    return coreFile.File.exists(fullFilePath) ? currentAppFolder.getFile(filename) : null;
  });
}

exports.hmrUpdate = hmrUpdate;

/***/ }),

/***/ "../node_modules/@nativescript/webpack/hmr/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hmrUpdate = void 0;

var hmr_update_1 = __webpack_require__("../node_modules/@nativescript/webpack/hmr/hmr-update.js");

Object.defineProperty(exports, "hmrUpdate", {
  enumerable: true,
  get: function () {
    return hmr_update_1.hmrUpdate;
  }
});

/***/ }),

/***/ "../node_modules/css-loader/dist/runtime/api.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names

module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "../node_modules/nativescript-vue/dist/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * NativeScript-Vue v2.8.4
 * (Using Vue v2.6.12)
 * (c) 2017-2021 rigor789
 * Released under the MIT license.
 */


global.process = global.process || {};
global.process.env = global.process.env || {};

var core = __webpack_require__("@nativescript/core");
/*  */


var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}
/**
 * Check if value is primitive.
 */


function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
  typeof value === 'symbol' || typeof value === 'boolean';
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject$1(obj) {
  return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject$1(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

function isPromise(val) {
  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
}
/**
 * Convert a value to a string that is actually rendered.
 */


function toString(val) {
  return val == null ? '' : Array.isArray(val) || isPlainObject$1(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */


function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */

function remove$2(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether an object has the property.
 */


var hasOwnProperty = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
/**
 * Capitalize a string.
 */

var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */

var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind$1 = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);

  while (i--) {
    ret[i] = list[i + start];
  }

  return ret;
}
/**
 * Mix properties into target object.
 */


function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */


function toObject$1(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */


function noop(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */


var identity = function (_) {
  return _;
};
/**
 * Generate a string containing static keys from compiler modules.
 */


function genStaticKeys$1(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */


function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var isObjectA = isObject$1(a);
  var isObjectB = isObject$1(b);

  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);

      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */


function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }

  return -1;
}
/**
 * Ensure a function is called only once.
 */


function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}
/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */


var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
/**
 * Check if a string starts with $ or _
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}
/**
 * Define a property.
 */


function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
/**
 * Parse simple path.
 */


var bailRE = new RegExp("[^" + unicodeRegExp.source + ".$_\\d]");

function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }

  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }

      obj = obj[segments[i]];
    }

    return obj;
  };
}
/*  */
// can we use __proto__?


var hasProto = ('__proto__' in {}); // Browser environment sniffing

var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
UA && /chrome\/\d+/.test(UA) && !isEdge;
UA && /phantomjs/.test(UA);
UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...

var nativeWatch = {}.watch;
var supportsPassive = false;

if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285

    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
} // this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV


var _isServer = false;

var isServerRendering = function () {
  return _isServer;
};
/* istanbul ignore next */


function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */
// $flow-disable-line


if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = /*@__PURE__*/function () {
    function Set() {
      this.set = Object.create(null);
    }

    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };

    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };

    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];
/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};
/*  */

var warn$1 = noop;
var tip = noop;
var generateComponentTrace = noop; // work around flow check

var formatComponentName = noop;

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;

  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn$1 = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }

    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;

    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat$1 = function (str, n) {
    var res = '';

    while (n) {
      if (n % 2 === 1) {
        res += str;
      }

      if (n > 1) {
        str += str;
      }

      n >>= 1;
    }

    return res;
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;

      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];

          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }

        tree.push(vm);
        vm = vm.$parent;
      }

      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat$1(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}
/*  */


var uid$2 = 0;
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */

var Dep = function Dep() {
  this.id = uid$2++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove$2(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();

  if ( true && !config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) {
      return a.id - b.id;
    });
  }

  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
}; // The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.


Dep.target = null;
var targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
/*  */


var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors$2 = {
  child: {
    configurable: true
  }
}; // DEPRECATED: alias for componentInstance for backwards compat.

/* istanbul ignore next */

prototypeAccessors$2.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors$2);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
} // optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.


function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, // #7975
  // clone children array to avoid mutating original in case of cloning
  // a child.
  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */


var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);
var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
/**
 * Intercept mutating methods and emit events
 */

methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;

    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;

      case 'splice':
        inserted = args.slice(2);
        break;
    }

    if (inserted) {
      ob.observeArray(inserted);
    } // notify change


    ob.dep.notify();
    return result;
  });
});
/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */

var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */


var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);

  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }

    this.observeArray(value);
  } else {
    this.walk(value);
  }
};
/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */


Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i]);
  }
};
/**
 * Observe a list of Array items.
 */


Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
}; // helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */


function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}
/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */

/* istanbul ignore next */


function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */


function observe(value, asRootData) {
  if (!isObject$1(value) || value instanceof VNode) {
    return;
  }

  var ob;

  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject$1(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }

  if (asRootData && ob) {
    ob.vmCount++;
  }

  return ob;
}
/**
 * Define a reactive property on an Object.
 */


function defineReactive(obj, key, val, customSetter, shallow) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);

  if (property && property.configurable === false) {
    return;
  } // cater for pre-defined getter/setters


  var getter = property && property.get;
  var setter = property && property.set;

  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;

      if (Dep.target) {
        dep.depend();

        if (childOb) {
          childOb.dep.depend();

          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }

      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */

      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */


      if ( true && customSetter) {
        customSetter();
      } // #7981: for accessor properties without setter


      if (getter && !setter) {
        return;
      }

      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }

      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}
/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */


function set$1(target, key, val) {
  if ( true && (isUndef(target) || isPrimitive(target))) {
    warn$1("Cannot set reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }

  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
     true && warn$1('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }

  if (!ob) {
    target[key] = val;
    return val;
  }

  defineReactive(ob.value, key, val);
  ob.dep.notify();
  return val;
}
/**
 * Delete a property and trigger change if necessary.
 */


function del(target, key) {
  if ( true && (isUndef(target) || isPrimitive(target))) {
    warn$1("Cannot delete reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
     true && warn$1('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }

  if (!hasOwn(target, key)) {
    return;
  }

  delete target[key];

  if (!ob) {
    return;
  }

  ob.dep.notify();
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */


function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();

    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */


var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */

if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn$1("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }

    return defaultStrat(parent, child);
  };
}
/**
 * Helper that recursively merges two data objects together.
 */


function mergeData(to, from) {
  if (!from) {
    return to;
  }

  var key, toVal, fromVal;
  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i]; // in case the object is already observed...

    if (key === '__ob__') {
      continue;
    }

    toVal = to[key];
    fromVal = from[key];

    if (!hasOwn(to, key)) {
      set$1(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject$1(toVal) && isPlainObject$1(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }

  return to;
}
/**
 * Data
 */


function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }

    if (!parentVal) {
      return childVal;
    } // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.


    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
       true && warn$1('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }

    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */


function mergeHook$1(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}

function dedupeHooks(hooks) {
  var res = [];

  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }

  return res;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook$1;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);

  if (childVal) {
     true && assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }

  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */


  if (!childVal) {
    return Object.create(parentVal || null);
  }

  if (true) {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = {};
  extend(ret, parentVal);

  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];

    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }

    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }

  return ret;
};
/**
 * Other object hashes.
 */


strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = Object.create(null);
  extend(ret, parentVal);

  if (childVal) {
    extend(ret, childVal);
  }

  return ret;
};

strats.provide = mergeDataOrFn;
/**
 * Default strategy.
 */

var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */


function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name)) {
    warn$1('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
  }

  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn$1('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */


function normalizeProps(options, vm) {
  var props = options.props;

  if (!props) {
    return;
  }

  var res = {};
  var i, val, name;

  if (Array.isArray(props)) {
    i = props.length;

    while (i--) {
      val = props[i];

      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = {
          type: null
        };
      } else if (true) {
        warn$1('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject$1(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject$1(val) ? val : {
        type: val
      };
    }
  } else if (true) {
    warn$1("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }

  options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */


function normalizeInject(options, vm) {
  var inject = options.inject;

  if (!inject) {
    return;
  }

  var normalized = options.inject = {};

  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = {
        from: inject[i]
      };
    }
  } else if (isPlainObject$1(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject$1(val) ? extend({
        from: key
      }, val) : {
        from: val
      };
    }
  } else if (true) {
    warn$1("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}
/**
 * Normalize raw function directives into object format.
 */


function normalizeDirectives$1(options) {
  var dirs = options.directives;

  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];

      if (typeof def === 'function') {
        dirs[key] = {
          bind: def,
          update: def
        };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject$1(value)) {
    warn$1("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */


function mergeOptions(parent, child, vm) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives$1(child); // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.

  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }

    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;

  for (key in parent) {
    mergeField(key);
  }

  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }

  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }

  return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */


function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }

  var assets = options[type]; // check local registration variations first

  if (hasOwn(assets, id)) {
    return assets[id];
  }

  var camelizedId = camelize(id);

  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }

  var PascalCaseId = capitalize(camelizedId);

  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  } // fallback to prototype chain


  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

  if ( true && warnMissing && !res) {
    warn$1('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }

  return res;
}
/*  */


function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key]; // boolean casting

  var booleanIndex = getTypeIndex(Boolean, prop.type);

  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);

      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  } // check default value


  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
    // make sure to observe it.

    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }

  if (true) {
    assertProp(prop, key, value, vm, absent);
  }

  return value;
}
/**
 * Get the default value of a prop.
 */


function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }

  var def = prop.default; // warn against non-factory defaults for Object & Array

  if ( true && isObject$1(def)) {
    warn$1('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  } // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger


  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  } // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context


  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}
/**
 * Assert whether a prop is valid.
 */


function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn$1('Missing required prop: "' + name + '"', vm);
    return;
  }

  if (value == null && !prop.required) {
    return;
  }

  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];

  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }

    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn$1(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }

  var validator = prop.validator;

  if (validator) {
    if (!validator(value)) {
      warn$1('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);

  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject$1(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */


function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }

  return -1;
}

function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }

  message += ", got " + receivedType + " "; // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }

  return message;
}

function styleValue(value, type) {
  if (type === 'String') {
    return "\"" + value + "\"";
  } else if (type === 'Number') {
    return "" + Number(value);
  } else {
    return "" + value;
  }
}

function isExplicable(value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) {
    return value.toLowerCase() === elem;
  });
}

function isBoolean() {
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}
/*  */


function handleError(err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();

  try {
    if (vm) {
      var cur = vm;

      while (cur = cur.$parent) {
        var hooks = cur.$options.errorCaptured;

        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;

              if (capture) {
                return;
              }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }

    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;

  try {
    res = args ? handler.apply(context, args) : handler.call(context);

    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) {
        return handleError(e, vm, info + " (Promise/async)");
      }); // issue #9511
      // avoid catch triggering multiple times when nested calls

      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }

  return res;
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }

  logError(err, vm, info);
}

function logError(err, vm, info) {
  if (true) {
    warn$1("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */


  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}
/*  */


var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;

  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
} // Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).


var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:

/* istanbul ignore next, $flow-disable-line */

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();

  timerFunc = function () {
    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.

    if (isIOS) {
      setTimeout(noop);
    }
  };
} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === '[object MutationObserverConstructor]')) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });

  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick(cb, ctx) {
  var _resolve;

  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });

  if (!pending) {
    pending = true;
    timerFunc();
  } // $flow-disable-line


  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}
/*  */


var ref$1 = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;

  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;

  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove$2(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}
/*  */


var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */

function traverse(val) {
  _traverse(val, seenObjects);

  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);

  if (!isA && !isObject$1(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }

  if (val.__ob__) {
    var depId = val.__ob__.dep.id;

    if (seen.has(depId)) {
      return;
    }

    seen.add(depId);
  }

  if (isA) {
    i = val.length;

    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;

    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}
/*  */


var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index$1 = 0;
/**
 * Reset the scheduler's state.
 */

function resetSchedulerState() {
  index$1 = queue.length = activatedChildren.length = 0;
  has = {};

  if (true) {
    circular = {};
  }

  waiting = flushing = false;
} // Async edge case fix requires storing an event listener's attach timestamp.


var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)

if (inBrowser && !isIE) {
  var performance = window.performance;

  if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () {
      return performance.now();
    };
  }
}
/**
 * Flush both queues and run the watchers.
 */


function flushSchedulerQueue() {
  getNow();
  flushing = true;
  var watcher, id; // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.

  queue.sort(function (a, b) {
    return a.id - b.id;
  }); // do not cache length because more watchers might be pushed
  // as we run existing watchers

  for (index$1 = 0; index$1 < queue.length; index$1++) {
    watcher = queue[index$1];

    if (watcher.before) {
      watcher.before();
    }

    id = watcher.id;
    has[id] = null;
    watcher.run(); // in dev build, check and stop circular updates.

    if ( true && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;

      if (circular[id] > MAX_UPDATE_COUNT) {
        warn$1('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  } // keep copies of post queues before resetting state


  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState(); // call component updated and activated hooks

  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue); // devtool hook

  /* istanbul ignore if */

  if (global.__VUE_DEVTOOLS_GLOBAL_HOOK__ && config.devtools) {
    global.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;

  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;

    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook$1(vm, 'updated');
    }
  }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */


function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true
    /* true */
    );
  }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */


function queueWatcher(watcher) {
  var id = watcher.id;

  if (has[id] == null) {
    has[id] = true;

    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;

      while (i > index$1 && queue[i].id > watcher.id) {
        i--;
      }

      queue.splice(i + 1, 0, watcher);
    } // queue the flush


    if (!waiting) {
      waiting = true;

      if ( true && !config.async) {
        flushSchedulerQueue();
        return;
      }

      nextTick(flushSchedulerQueue);
    }
  }
}
/*  */


var uid$1 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */

var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;

  if (isRenderWatcher) {
    vm._watcher = this;
  }

  vm._watchers.push(this); // options


  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }

  this.cb = cb;
  this.id = ++uid$1; // uid for batching

  this.active = true;
  this.dirty = this.lazy; // for lazy watchers

  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true ? expOrFn.toString() : undefined; // parse expression for getter

  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);

    if (!this.getter) {
      this.getter = noop;
       true && warn$1("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }

  this.value = this.lazy ? undefined : this.get();
};
/**
 * Evaluate the getter, and re-collect dependencies.
 */


Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;

  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }

    popTarget();
    this.cleanupDeps();
  }

  return value;
};
/**
 * Add a dependency to this directive.
 */


Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;

  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);

    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};
/**
 * Clean up for dependency collection.
 */


Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var i = this.deps.length;

  while (i--) {
    var dep = this.deps[i];

    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }

  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};
/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */


Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */


Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();

    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject$1(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;

      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};
/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */


Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};
/**
 * Depend on all deps collected by this watcher.
 */


Watcher.prototype.depend = function depend() {
  var i = this.deps.length;

  while (i--) {
    this.deps[i].depend();
  }
};
/**
 * Remove self from all dependencies' subscriber list.
 */


Watcher.prototype.teardown = function teardown() {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove$2(this.vm._watchers, this);
    }

    var i = this.deps.length;

    while (i--) {
      this.deps[i].removeSub(this);
    }

    this.active = false;
  }
};

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */

  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };

    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag); // perf.clearMeasures(name)
    };
  }
}
/*  */


var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once = name.charAt(0) === '~'; // Prefixed last, checked first

  name = once ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns, vm) {
  function invoker() {
    var arguments$1 = arguments;
    var fns = invoker.fns;

    if (Array.isArray(fns)) {
      var cloned = fns.slice();

      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
    }
  }

  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {
  var name, cur, old, event;

  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);

    if (isUndef(cur)) {
       true && warn$1("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }

      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }

      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }

  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove(event.name, oldOn[name], event.capture);
    }
  }
}
/*  */


function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }

  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
    // and prevent memory leak

    remove$2(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}
/*  */


function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;

  if (isUndef(propOptions)) {
    return;
  }

  var res = {};
  var attrs = data.attrs;
  var props = data.props;

  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);

      if (true) {
        var keyInLowerCase = key.toLowerCase();

        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }

      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }

  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];

      if (!preserve) {
        delete hash[key];
      }

      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];

      if (!preserve) {
        delete hash[altKey];
      }

      return true;
    }
  }

  return false;
}
/*  */
// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.


function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }

  return children;
} // 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.


function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;

  for (i = 0; i < children.length; i++) {
    c = children[i];

    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }

    lastIndex = res.length - 1;
    last = res[lastIndex]; //  nested

    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }

        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }

        res.push(c);
      }
    }
  }

  return res;
}
/* not type checking this file because flow doesn't play well with Proxy */


var initProxy;

if (true) {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn$1("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var warnReservedPrefix = function (target, key) {
    warn$1("Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals. ' + 'See: https://vuejs.org/v2/api/#data', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn$1("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = (key in target);
      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);

      if (!has && !isAllowed) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return has || !isAllowed;
    }
  };
  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
/*  */


var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };

  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;

  if (opts.props) {
    initProps$1(vm, opts.props);
  }

  if (opts.methods) {
    initMethods(vm, opts.methods);
  }

  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true
    /* asRootData */
    );
  }

  if (opts.computed) {
    initComputed$1(vm, opts.computed);
  }

  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps$1(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.

  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent; // root instance props should be converted

  if (!isRoot) {
    toggleObserving(false);
  }

  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */

    if (true) {
      var hyphenatedKey = hyphenate(key);

      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn$1("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }

      defineReactive(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn$1("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {} // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.


    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);

  toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

  if (!isPlainObject$1(data)) {
    data = {};
     true && warn$1('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  } // proxy data on instance


  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;

  while (i--) {
    var key = keys[i];

    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn$1("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }

    if (props && hasOwn(props, key)) {
       true && warn$1("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  } // observe data


  observe(data, true
  /* asRootData */
  );
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();

  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = {
  lazy: true
};

function initComputed$1(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;

    if ( true && getter == null) {
      warn$1("Getter is missing for computed property \"" + key + "\".", vm);
    }

    {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    } // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.

    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn$1("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn$1("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = createComputedGetter(key);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }

  if ( true && sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn$1("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];

    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }

      if (Dep.target) {
        watcher.depend();
      }

      return watcher.value;
    }
  };
}

function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;

  for (var key in methods) {
    if (true) {
      if (typeof methods[key] !== 'function') {
        warn$1("Method \"" + key + "\" has type \"" + typeof methods[key] + "\" in the component definition. " + "Did you reference the function correctly?", vm);
      }

      if (props && hasOwn(props, key)) {
        warn$1("Method \"" + key + "\" has already been defined as a prop.", vm);
      }

      if (key in vm && isReserved(key)) {
        warn$1("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }

    vm[key] = typeof methods[key] !== 'function' ? noop : bind$1(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];

    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject$1(handler)) {
    options = handler;
    handler = handler.handler;
  }

  if (typeof handler === 'string') {
    handler = vm[handler];
  }

  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};

  dataDef.get = function () {
    return this._data;
  };

  var propsDef = {};

  propsDef.get = function () {
    return this._props;
  };

  if (true) {
    dataDef.set = function () {
      warn$1('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };

    propsDef.set = function () {
      warn$1("$props is readonly.", this);
    };
  }

  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);
  Vue.prototype.$set = set$1;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;

    if (isPlainObject$1(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }

    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);

    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, "callback for immediate watcher \"" + watcher.expression + "\"");
      }
    }

    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
/*  */


function initProvide(vm) {
  var provide = vm.$options.provide;

  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);

  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive(vm, key, result[key], function () {
          warn$1("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {}
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]; // #6574 in case the inject object is observed...

      if (key === '__ob__') {
        continue;
      }

      var provideKey = inject[key].from;
      var source = vm;

      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }

        source = source.$parent;
      }

      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else if (true) {
          warn$1("Injection \"" + key + "\" not found", vm);
        }
      }
    }

    return result;
  }
}
/*  */


var uid = 0;

function initMixin$1(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this; // a uid

    vm._uid = uid++;
    var startTag, endTag;
    /* istanbul ignore if */

    if ( true && config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    } // a flag to avoid this being observed


    vm._isVue = true; // merge options

    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */


    if (true) {
      initProxy(vm);
    } else {} // expose real self


    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook$1(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props

    initState(vm);
    initProvide(vm); // resolve provide after data/props

    callHook$1(vm, 'created');
    /* istanbul ignore if */

    if ( true && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;

  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;

    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }

  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;

  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }

      modified[key] = latest[key];
    }
  }

  return modified;
}
/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */


function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }

  var slots = {};

  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    } // named slots should only be respected if the vnode was rendered in the
    // same context.


    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);

      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  } // ignore slots that contains only whitespace


  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }

  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}
/*  */


function normalizeScopedSlots(slots, normalSlots, prevSlots) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;

  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized;
  } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots;
  } else {
    res = {};

    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  } // expose normal slots on scopedSlots


  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  } // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error


  if (slots && Object.isExtensible(slots)) {
    slots._normalized = res;
  }

  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res;
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode
    : normalizeChildren(res);
    return res && (res.length === 0 || res.length === 1 && res[0].isComment // #9658
    ) ? undefined : res;
  }; // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.


  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }

  return normalized;
}

function proxyNormalSlot(slots, key) {
  return function () {
    return slots[key];
  };
}
/*  */

/**
 * Runtime helper for rendering v-for lists.
 */


function renderList(val, render) {
  var ret, i, l, keys, key;

  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);

    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);

    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject$1(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();

      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);

      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }

  if (!isDef(ret)) {
    ret = [];
  }

  ret._isVList = true;
  return ret;
}
/*  */

/**
 * Runtime helper for rendering <slot>
 */


function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;

  if (scopedSlotFn) {
    // scoped slot
    props = props || {};

    if (bindObject) {
      if ( true && !isObject$1(bindObject)) {
        warn$1('slot v-bind without argument expects an Object', this);
      }

      props = extend(extend({}, bindObject), props);
    }

    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;

  if (target) {
    return this.$createElement('template', {
      slot: target
    }, nodes);
  } else {
    return nodes;
  }
}
/*  */

/**
 * Runtime helper for resolving filters
 */


function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}
/*  */


function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */


function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}
/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */


function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject$1(value)) {
       true && warn$1('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject$1(value);
      }

      var hash;

      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }

        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);

        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});

            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }

  return data;
}
/*  */

/**
 * Runtime helper for rendering static trees.
 */


function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.

  if (tree && !isInFor) {
    return tree;
  } // otherwise, render a fresh tree.


  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic$1(tree, "__static__" + index, false);
  return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */


function markOnce(tree, index, key) {
  markStatic$1(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic$1(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
/*  */


function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject$1(value)) {
       true && warn$1('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};

      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }

  return data;
}
/*  */


function resolveScopedSlots(fns, // see flow/vnode
res, // the following are added in 2.6
hasDynamicKeys, contentHashKey) {
  res = res || {
    $stable: !hasDynamicKeys
  };

  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];

    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }

      res[slot.key] = slot.fn;
    }
  }

  if (contentHashKey) {
    res.$key = contentHashKey;
  }

  return res;
}
/*  */


function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];

    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if ( true && key !== '' && key !== null) {
      // null is a special value for explicitly removing a binding
      warn$1("Invalid value for dynamic directive argument (expected string or null): " + key, this);
    }
  }

  return baseObj;
} // helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.


function prependModifier(value, symbol) {
  return typeof value === 'string' ? symbol + value : value;
}
/*  */


function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}
/*  */


function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var this$1 = this;
  var options = Ctor.options; // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check

  var contextVm;

  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent); // $flow-disable-line

    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent; // $flow-disable-line

    parent = parent._original;
  }

  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);

  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
    }

    return this$1.$slots;
  };

  Object.defineProperty(this, 'scopedSlots', {
    enumerable: true,
    get: function get() {
      return normalizeScopedSlots(data.scopedSlots, this.slots());
    }
  }); // support for compiled functional template

  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options; // pre-resolve slots for renderSlot()

    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement$1(contextVm, a, b, c, d, needNormalization);

      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }

      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement$1(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;

  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }

    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);

    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }

    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;

  if (true) {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }

  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }

  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
/*  */
// inline hooks to be invoked on component VNodes during patch


var componentVNodeHooks = {
  init: function init(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow

      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },
  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook$1(componentInstance, 'mounted');
    }

    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  },
  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base; // plain options object: turn it into a constructor

  if (isObject$1(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  } // if at this stage it's not a constructor or an async component factory,
  // reject.


  if (typeof Ctor !== 'function') {
    if (true) {
      warn$1("Invalid Component definition: " + String(Ctor), context);
    }

    return;
  } // async component


  var asyncFactory;

  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);

    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {}; // resolve constructor options in case global mixins are applied after
  // component constructor creation

  resolveConstructorOptions(Ctor); // transform component v-model data into props & events

  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  } // extract props


  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  } // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners


  var listeners = data.on; // replace with listeners with .native modifier
  // so it gets processed during parent component patch.

  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot
    // work around flow
    var slot = data.slot;
    data = {};

    if (slot) {
      data.slot = slot;
    }
  } // install component management hooks onto the placeholder node


  installComponentHooks(data); // return a placeholder vnode

  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
    Ctor: Ctor,
    propsData: propsData,
    listeners: listeners,
    tag: tag,
    children: children
  }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }; // check inline-template render functions

  var inlineTemplate = vnode.data.inlineTemplate;

  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }

  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});

  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];

    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook(f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };

  merged._merged = true;
  return merged;
} // transform component v-model info (value and callback) into
// prop and event handler respectively.


function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;

  if (isDef(existing)) {
    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
/*  */


var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
// without getting yelled at by flow

function createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }

  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }

  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
     true && warn$1("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  } // object syntax in v-bind


  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }

  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  } // warn against non-primitive key


  if ( true && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn$1('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  } // support single function children as default scoped slot


  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = {
      default: children[0]
    };
    children.length = 0;
  }

  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }

  var vnode, ns;

  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if ( true && isDef(data) && isDef(data.nativeOn)) {
        warn$1("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">.", context);
      }

      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }

  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }

    if (isDef(data)) {
      registerDeepBindings(data);
    }

    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;

  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }

  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];

      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
} // ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes


function registerDeepBindings(data) {
  if (isObject$1(data.style)) {
    traverse(data.style);
  }

  if (isObject$1(data.class)) {
    traverse(data.class);
  }
}
/*  */


function initRender(vm) {
  vm._vnode = null; // the root of the child tree

  vm._staticTrees = null; // v-once cached trees

  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates

  vm._c = function (a, b, c, d) {
    return createElement$1(vm, a, b, c, d, false);
  }; // normalization is always applied for the public version, used in
  // user-written render functions.


  vm.$createElement = function (a, b, c, d) {
    return createElement$1(vm, a, b, c, d, true);
  }; // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated


  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */

  if (true) {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn$1("$attrs is readonly.", vm);
    }, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn$1("$listeners is readonly.", vm);
    }, true);
  } else {}
}

var currentRenderingInstance = null;

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
    } // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.


    vm.$vnode = _parentVnode; // render self

    var vnode;

    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render"); // return error render result,
      // or previous vnode to prevent render error causing blank component

      /* istanbul ignore else */

      if ( true && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e$1) {
          handleError(e$1, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    } // if the returned array contains only a single node, allow it


    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    } // return empty vnode in case the render function errored out


    if (!(vnode instanceof VNode)) {
      if ( true && Array.isArray(vnode)) {
        warn$1('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }

      vnode = createEmptyVNode();
    } // set parent


    vnode.parent = _parentVnode;
    return vnode;
  };
}
/*  */


function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }

  return isObject$1(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = {
    data: data,
    context: context,
    children: children,
    tag: tag
  };
  return node;
}

function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  var owner = currentRenderingInstance;

  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null;
    owner.$on('hook:destroyed', function () {
      return remove$2(owners, owner);
    });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;

        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }

        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)

      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });
    var reject = once(function (reason) {
       true && warn$1("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });
    var res = factory(resolve, reject);

    if (isObject$1(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);

          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;

              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;

            if (isUndef(factory.resolved)) {
              reject( true ? "timeout (" + res.timeout + "ms)" : undefined);
            }
          }, res.timeout);
        }
      }
    }

    sync = false; // return in case resolved synchronously

    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
/*  */


function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
/*  */


function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];

      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
/*  */


function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false; // init parent attached events

  var listeners = vm.$options._parentListeners;

  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target$1;

function add$1(event, fn) {
  target$1.$on(event, fn);
}

function remove$1(event, fn) {
  target$1.$off(event, fn);
}

function createOnceHandler$1(event, fn) {
  var _target = target$1;
  return function onceHandler() {
    var res = fn.apply(null, arguments);

    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target$1 = vm;
  updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);
  target$1 = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;

  Vue.prototype.$on = function (event, fn) {
    var vm = this;

    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup

      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }

    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;

    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }

    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this; // all

    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    } // array of events


    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }

      return vm;
    } // specific event


    var cbs = vm._events[event];

    if (!cbs) {
      return vm;
    }

    if (!fn) {
      vm._events[event] = null;
      return vm;
    } // specific handler


    var cb;
    var i = cbs.length;

    while (i--) {
      cb = cbs[i];

      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }

    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;

    if (true) {
      var lowerCaseEvent = event.toLowerCase();

      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }

    var cbs = vm._events[event];

    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";

      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }

    return vm;
  };
}
/*  */


var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  };
}

function initLifecycle(vm) {
  var options = vm.$options; // locate first non-abstract parent

  var parent = options.parent;

  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }

    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.

    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
      /* removeOnly */
      );
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }

    restoreActiveInstance(); // update __vue__ reference

    if (prevEl) {
      prevEl.__vue__ = null;
    }

    if (vm.$el) {
      vm.$el.__vue__ = vm;
    } // if parent is an HOC, update its $el as well


    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    } // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.

  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;

    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;

    if (vm._isBeingDestroyed) {
      return;
    }

    callHook$1(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true; // remove self from parent

    var parent = vm.$parent;

    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove$2(parent.$children, vm);
    } // teardown watchers


    if (vm._watcher) {
      vm._watcher.teardown();
    }

    var i = vm._watchers.length;

    while (i--) {
      vm._watchers[i].teardown();
    } // remove reference from data ob
    // frozen object may not have observer.


    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    } // call the last hook...


    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

    vm.__patch__(vm._vnode, null); // fire destroyed hook


    callHook$1(vm, 'destroyed'); // turn off all instance listeners.

    vm.$off(); // remove __vue__ reference

    if (vm.$el) {
      vm.$el.__vue__ = null;
    } // release circular reference (#6759)


    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;

  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;

    if (true) {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn$1('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn$1('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }

  callHook$1(vm, 'beforeMount');
  var updateComponent;
  /* istanbul ignore if */

  if ( true && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;
      mark(startTag);

      var vnode = vm._render();

      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);
      mark(startTag);

      vm._update(vnode, hydrating);

      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  } // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined


  new Watcher(vm, updateComponent, noop, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook$1(vm, 'beforeUpdate');
      }
    }
  }, true
  /* isRenderWatcher */
  );
  hydrating = false; // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook

  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook$1(vm, 'mounted');
  }

  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (true) {
    isUpdatingChildComponent = true;
  } // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.
  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.


  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key); // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.

  var needsForceUpdate = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  hasDynamicScopedSlot);
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }

  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render

  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject; // update props

  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];

    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?

      props[key] = validateProp(key, propOptions, propsData, vm);
    }

    toggleObserving(true); // keep a copy of raw propsData

    vm.$options.propsData = propsData;
  } // update listeners


  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }

  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;

    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }

  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;

    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }

    callHook$1(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;

    if (isInInactiveTree(vm)) {
      return;
    }
  }

  if (!vm._inactive) {
    vm._inactive = true;

    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }

    callHook$1(vm, 'deactivated');
  }
}

function callHook$1(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";

  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }

  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  popTarget();
}
/*  */


makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
// contain child elements.

makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);
var isTextInputType = makeMap('text,number,password,search,email,tel,url');
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }

  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};

  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;

    if (isDef(key)) {
      map[key] = i;
    }
  }

  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];

    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove() {
      if (--remove.listeners === 0) {
        removeNode(childElm);
      }
    }

    remove.listeners = listeners;
    return remove;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check

    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;

    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }

        if (isUnknownElement(vnode, creatingElmInVPre)) {
          warn$1('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }

      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);
      /* istanbul ignore if */

      {
        createChildren(vnode, children, insertedVnodeQueue);

        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }

        insert(parentElm, vnode.elm, refElm);
      }

      if ( true && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;

    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false
        /* hydrating */
        );
      } // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.


      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);

        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }

        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }

    vnode.elm = vnode.componentInstance.$el;

    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode); // make sure to invoke the insert hook

      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i; // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.

    var innerNode = vnode;

    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;

      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }

        insertedVnodeQueue.push(innerNode);
        break;
      }
    } // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself


    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref) {
    if (isDef(parent)) {
      if (isDef(ref)) {
        if (nodeOps.parentNode(ref) === parent) {
          nodeOps.insertBefore(parent, elm, ref);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (true) {
        checkDuplicateKeys(children);
      }

      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }

    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }

    i = vnode.data.hook; // Reuse variable

    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }

      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  } // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.


  function setScope(vnode) {
    var i;

    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;

      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }

        ancestor = ancestor.parent;
      }
    } // for slot content they should also get the scopeId from the host instance.


    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }

      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }

    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];

      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;

      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } // recursively invoke hooks on child component root node


      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }

      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }

      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions

    var canMove = !removeOnly;

    if (true) {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }

        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];

          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }

        newStartVnode = newCh[++newStartIdx];
      }
    }

    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};

    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;

      if (isDef(key)) {
        if (seenKeys[key]) {
          warn$1("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];

      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }

      return;
    } // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.


    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;

    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;

    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }

      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }

    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (true) {
          checkDuplicateKeys(ch);
        }

        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }

        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).

  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    } // assert node match


    if (true) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true
        /* hydrating */
        );
      }

      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }

    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ( true && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }

              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;

            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }

              childNode = childNode.nextSibling;
            } // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.


            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ( true && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }

              return false;
            }
          }
        }
      }

      if (isDef(data)) {
        var fullInvoke = false;

        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }

        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }

    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }

      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);

      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }

          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (true) {
              warn$1('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          } // either not server-rendered, or hydration failed.
          // create an empty node and replace it


          oldVnode = emptyNodeAt(oldVnode);
        } // replacing existing element


        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm); // create new node

        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);

          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }

            ancestor.elm = vnode.elm;

            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              } // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.


              var insert = ancestor.data.hook.insert;

              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }

            ancestor = ancestor.parent;
          }
        } // destroy old node


        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
/*  */


var directives$1 = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;

  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];

    if (!oldDir) {
      // new directive, bind
      callHook(dir, 'bind', vnode, oldVnode);

      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook(dir, 'update', vnode, oldVnode);

      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };

    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives(dirs, vm) {
  var res = Object.create(null);

  if (!dirs) {
    // $flow-disable-line
    return res;
  }

  var i, dir;

  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];

    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }

    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  } // $flow-disable-line


  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];

  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref$1, directives$1];

function updateAttrs(oldVnode, vnode) {
  if (!oldVnode.data.attrs && !vnode.data.attrs) {
    return;
  }

  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

  if (attrs.__ob__) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];

    if (old !== cur) {
      elm.setAttribute(key, cur);
    }
  }

  for (key in oldAttrs) {
    if (attrs[key] == null) {
      elm.setAttribute(key);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
/*  */

function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;

  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;

    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }

  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }

  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */


  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }

  if (isObject$1(value)) {
    return stringifyObject(value);
  }

  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */


  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;

  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }

      res += stringified;
    }
  }

  return res;
}

function stringifyObject(value) {
  var res = '';

  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }

      res += key;
    }
  }

  return res;
}

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (!data.staticClass && !data.class && (!oldData || !oldData.staticClass && !oldData.class)) {
    return;
  }

  var cls = genClassForVnode(vnode); // handle transition classes

  var transitionClass = el._transitionClasses;

  if (transitionClass) {
    cls = concat(cls, stringifyClass(transitionClass));
  } // set the class


  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var class_$1 = {
  create: updateClass,
  update: updateClass
};
var target;

function createOnceHandler(event, handler, capture) {
  var _target = target; // save current target element in closure

  return function onceHandler() {
    var res = handler.apply(null, arguments);

    if (res !== null) {
      remove(event, onceHandler, capture, _target);
    }
  };
}

function add(event, handler, once, capture) {
  if (capture) {
    console.log('NativeScript-Vue do not support event in bubble phase.');
    return;
  }

  if (once) {
    var oldHandler = handler;

    handler = function () {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len];

      var res = oldHandler.call.apply(oldHandler, [null].concat(args));

      if (res !== null) {
        remove(event, null, null, target);
      }
    };
  }

  target.addEventListener(event, handler);
}

function remove(event, handler, capture, _target) {
  if (_target === void 0) _target = target;

  _target.removeEventListener(event);
}

function updateDOMListeners(oldVnode, vnode) {
  if (!oldVnode.data.on && !vnode.data.on) {
    return;
  }

  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target = vnode.elm;
  updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);
  target = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};
var normalize$1 = cached(camelize);

function createStyle(oldVnode, vnode) {
  // console.log(`\t\t ===> createStyle(${oldVnode}, ${vnode})`)
  if (!vnode.data.staticStyle) {
    updateStyle(oldVnode, vnode);
    return;
  }

  var elm = vnode.elm;
  var staticStyle = vnode.data.staticStyle;

  for (var name in staticStyle) {
    if (staticStyle[name]) {
      elm.setStyle(normalize$1(name), staticStyle[name]);
    }
  }

  updateStyle(oldVnode, vnode);
}

function updateStyle(oldVnode, vnode) {
  if (!oldVnode.data.style && !vnode.data.style) {
    return;
  }

  var cur, name;
  var elm = vnode.elm;
  var oldStyle = oldVnode.data.style || {};
  var style = vnode.data.style || {};
  var needClone = style.__ob__; // handle array syntax

  if (Array.isArray(style)) {
    style = vnode.data.style = toObject(style);
  } // clone the style for future updates,
  // in case the user mutates the style object in-place.


  if (needClone) {
    style = vnode.data.style = extend({}, style);
  }

  for (name in oldStyle) {
    if (!style[name]) {
      elm.setStyle(normalize$1(name), '');
    }
  }

  for (name in style) {
    cur = style[name];
    elm.setStyle(normalize$1(name), cur);
  }
}

function toObject(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}

var style$1 = {
  create: createStyle,
  update: updateStyle
};
/*  */

var whitespaceRE$1 = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */

function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE$1).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";

    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */


function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE$1).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }

    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';

    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }

    cur = cur.trim();

    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}
/*  */


function resolveTransition(def) {
  if (!def) {
    return;
  }
  /* istanbul ignore else */


  if (typeof def === 'object') {
    var res = {};

    if (def.css !== false) {
      extend(res, autoCssTransition(def.name || 'v'));
    }

    extend(res, def);
    return res;
  } else if (typeof def === 'string') {
    return autoCssTransition(def);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
}); // binding to window is necessary to make hot reload work in IE in strict mode

var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
/* istanbul ignore next */
function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove$2(el._transitionClasses, cls);
  }

  removeClass(el, cls);
}

function enter(vnode, toggleDisplay) {
  var el = vnode.elm; // call leave callback now

  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;

    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data)) {
    return;
  }
  /* istanbul ignore if */


  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration; // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.

  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;

  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject$1(duration) ? duration.enter : duration);

  if ( true && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }

      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }

    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];

      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }

      enterHook && enterHook(el, cb);
    });
  } // start enter transition


  beforeEnterHook && beforeEnterHook(el);

  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);

      if (!cb.cancelled) {
        addTransitionClass(el, toClass);

        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm; // call enter callback now

  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;

    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  /* istanbul ignore if */


  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;
  var expectsCSS = css !== false;
  var userWantsControl = getHookArgumentsLength(leave);
  var explicitLeaveDuration = toNumber(isObject$1(duration) ? duration.leave : duration);

  if ( true && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }

    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }

      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }

    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    } // record leaving element


    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }

    beforeLeave && beforeLeave(el);

    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);

        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);

          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            }
          }
        }
      });
    }

    leave && leave(el, cb);

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
} // only used in dev mode


function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn$1("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn$1("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */


function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }

  var invokerFns = fn.fns;

  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = {
  create: _enter,
  activate: _enter,
  remove: function remove(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
};
var platformModules = [class_$1, events, attrs, style$1, transition];
var actionBar = {
  template: "\n    <NativeActionBar ~actionBar v-bind=\"$attrs\" v-on=\"$listeners\">\n      <slot />\n    </NativeActionBar>\n  "
};
var android = {
  functional: true,
  render: function render(h, ref) {
    var children = ref.children;

    if (true) {
      return children;
    }
  }
};
var frames = new Map();

function setFrame(id, frame) {
  return frames.set(id, frame);
}

function getFrame(id) {
  return frames.get(id);
}

function deleteFrame(id) {
  return frames.delete(id);
}

var frame = {
  props: {
    id: {
      default: 'default'
    },
    transition: {
      type: [String, Object],
      required: false,
      default: null
    },
    'ios:transition': {
      type: [String, Object],
      required: false,
      default: null
    },
    'android:transition': {
      type: [String, Object],
      required: false,
      default: null
    },
    clearHistory: {
      type: Boolean,
      required: false,
      default: false
    },
    backstackVisible: {
      type: Boolean,
      required: false,
      default: true
    },
    // injected by the template compiler
    hasRouterView: {
      default: false
    }
  },
  data: function data() {
    return {
      properties: {}
    };
  },
  created: function created() {
    this.properties = Object.assign({}, this.$attrs, this.$props);
    setFrame(this.properties.id, this);
  },
  destroyed: function destroyed() {
    deleteFrame(this.properties.id);
  },
  render: function render(h) {
    var vnode = null; // Render slot to ensure default page is displayed

    if (this.$slots.default) {
      if ( true && this.$slots.default.length > 1) {
        warn$1("The <Frame> element can only have a single child element, that is the defaultPage.");
      }

      vnode = this.$slots.default[0];
      vnode.key = 'default';
    }

    return h('NativeFrame', {
      attrs: this.properties,
      on: this.$listeners
    }, [vnode]);
  },
  methods: {
    _getFrame: function _getFrame() {
      return this.$el.nativeView;
    },
    _ensureTransitionObject: function _ensureTransitionObject(transition) {
      if (typeof transition === 'string') {
        return {
          name: transition
        };
      }

      return transition;
    },
    _composeTransition: function _composeTransition(entry) {
      var isAndroid = true;
      var platformEntryProp = "transition" + (isAndroid ? 'Android' : 'iOS');
      var entryProp = entry[platformEntryProp] ? platformEntryProp : 'transition';
      var platformProp = (isAndroid ? 'android' : 'ios') + ":transition";
      var prop = this[platformProp] ? platformProp : 'transition';

      if (entry[entryProp]) {
        entry[entryProp] = this._ensureTransitionObject(entry[entryProp]);
      } else if (this[prop]) {
        entry[entryProp] = this._ensureTransitionObject(this[prop]);
      }

      return entry;
    },
    notifyFirstPageMounted: function notifyFirstPageMounted(pageVm) {
      var options = {
        backstackVisible: this.backstackVisible,
        clearHistory: this.clearHistory,
        create: function () {
          return pageVm.$el.nativeView;
        }
      };
      this.navigate(options);
    },
    navigate: function navigate(entry, back) {
      var this$1 = this;
      if (back === void 0) back = false;

      var frame = this._getFrame();

      if (back) {
        return frame.goBack(entry);
      } // resolve the page from the entry and attach a navigatedTo listener
      // to fire the frame events


      var page = entry.create();
      page.once('navigatedTo', function () {
        this$1.$emit('navigated', entry);
      });

      var handler = function (args) {
        if (args.isBackNavigation) {
          page.off('navigatedFrom', handler);
          this$1.$emit('navigatedBack', entry);
        }
      };

      page.on('navigatedFrom', handler);

      entry.create = function () {
        return page;
      };

      this._composeTransition(entry);

      frame.navigate(entry);
    },
    back: function back(backstackEntry) {
      if (backstackEntry === void 0) backstackEntry = null;
      this.navigate(backstackEntry, true);
    }
  }
};
var ios = {
  functional: true,
  render: function render(h, ref) {
    var children = ref.children;

    if (false) {}
  }
};
var VUE_VIEW = '__vueVNodeRef__';
var tid = 0;
var vTemplate$1 = {
  props: {
    name: {
      type: String
    },
    if: {
      type: String
    }
  },
  mounted: function mounted() {
    if (!this.$scopedSlots.default) {
      return;
    }

    this.$templates = this.$el.parentNode.$templates = this.$parent.$templates = this.$parent.$templates || new TemplateBag();
    this.$templates.registerTemplate(this.$props.name || (this.$props.if ? "v-template-" + tid++ : 'default'), this.$props.if, this.$scopedSlots.default);
  },
  render: function render(h) {}
};

var TemplateBag = function TemplateBag() {
  this._templateMap = new Map();
};

var prototypeAccessors$1 = {
  selectorFn: {
    configurable: true
  }
};

TemplateBag.prototype.registerTemplate = function registerTemplate(name, condition, scopedFn) {
  this._templateMap.set(name, {
    scopedFn: scopedFn,
    conditionFn: this.getConditionFn(condition),
    keyedTemplate: new VueKeyedTemplate(name, scopedFn)
  });
};

prototypeAccessors$1.selectorFn.get = function () {
  var self = this;
  return function templateSelectorFn(item) {
    var iterator = self._templateMap.entries();

    var curr;

    while (curr = iterator.next().value) {
      var name = curr[0];
      var conditionFn = curr[1].conditionFn;

      try {
        if (conditionFn(item)) {
          return name;
        }
      } catch (err) {}
    }

    return 'default';
  };
};

TemplateBag.prototype.getConditionFn = function getConditionFn(condition) {
  return new Function('ctx', "with(ctx) { return !!(" + condition + ") }");
};

TemplateBag.prototype.getKeyedTemplate = function getKeyedTemplate(name) {
  return this._templateMap.get(name).keyedTemplate;
};

TemplateBag.prototype.patchTemplate = function patchTemplate(name, context, oldVnode) {
  var vnode = this._templateMap.get(name).scopedFn(context); // in 2.6 scopedFn returns an array!


  if (Array.isArray(vnode)) {
    vnode = vnode[0];
  }

  var nativeView = patch(oldVnode, vnode).nativeView;
  nativeView[VUE_VIEW] = vnode; // force flush Vue callbacks so all changes are applied immediately
  // rather than on next tick

  flushCallbacks();
  return nativeView;
};

TemplateBag.prototype.getAvailable = function getAvailable() {
  return Array.from(this._templateMap.keys());
};

TemplateBag.prototype.getKeyedTemplates = function getKeyedTemplates() {
  return Array.from(this._templateMap.values()).map(function (ref) {
    var keyedTemplate = ref.keyedTemplate;
    return keyedTemplate;
  });
};

Object.defineProperties(TemplateBag.prototype, prototypeAccessors$1);

var VueKeyedTemplate = function VueKeyedTemplate(key, scopedFn) {
  this._key = key;
  this._scopedFn = scopedFn;
};

var prototypeAccessors$1$1 = {
  key: {
    configurable: true
  }
};

prototypeAccessors$1$1.key.get = function () {
  return this._key;
};

VueKeyedTemplate.prototype.createView = function createView() {
  // we are returning null because we don't have the data here
  // the view will be created in the `patchTemplate` method above.
  // see https://github.com/nativescript-vue/nativescript-vue/issues/229#issuecomment-390330474
  return null;
};

Object.defineProperties(VueKeyedTemplate.prototype, prototypeAccessors$1$1);
var listView = {
  props: {
    items: {
      type: [Array, Object],
      validator: function (val) {
        var ObservableArray = __webpack_require__("@nativescript/core").ObservableArray;

        return Array.isArray(val) || val instanceof ObservableArray;
      },
      required: true
    },
    '+alias': {
      type: String,
      default: 'item'
    },
    '+index': {
      type: String
    }
  },
  template: "\n    <NativeListView\n      ref=\"listView\"\n      :items=\"items\"\n      v-bind=\"$attrs\"\n      v-on=\"listeners\"\n      @itemTap=\"onItemTap\"\n      @itemLoading=\"onItemLoading\"\n    >\n      <slot />\n    </NativeListView>\n  ",
  watch: {
    items: {
      handler: function handler(newVal) {
        this.$refs.listView.setAttribute('items', newVal);
        this.refresh();
      },
      deep: true
    }
  },
  created: function created() {
    // we need to remove the itemTap handler from a clone of the $listeners
    // object because we are emitting the event ourselves with added data.
    var listeners = extend({}, this.$listeners);
    delete listeners.itemTap;
    this.listeners = listeners;
    this.getItemContext = getItemContext.bind(this);
  },
  mounted: function mounted() {
    var this$1 = this;

    if (!this.$templates) {
      return;
    }

    this.$refs.listView.setAttribute('itemTemplates', this.$templates.getKeyedTemplates());
    this.$refs.listView.setAttribute('itemTemplateSelector', function (item, index) {
      return this$1.$templates.selectorFn(this$1.getItemContext(item, index));
    });
  },
  methods: {
    onItemTap: function onItemTap(args) {
      this.$emit('itemTap', extend({
        item: this.getItem(args.index)
      }, args));
    },
    onItemLoading: function onItemLoading(args) {
      if (!this.$templates) {
        return;
      }

      var index = args.index;
      var items = args.object.items;
      var currentItem = this.getItem(index);

      var name = args.object._itemTemplateSelector(currentItem, index, items);

      var context = this.getItemContext(currentItem, index);
      var oldVnode = args.view && args.view[VUE_VIEW];
      args.view = this.$templates.patchTemplate(name, context, oldVnode);
    },
    refresh: function refresh() {
      this.$refs.listView.nativeView.refresh();
    },
    getItem: function getItem(idx) {
      return typeof this.items.getItem === 'function' ? this.items.getItem(idx) : this.items[idx];
    }
  }
};

function getItemContext(item, index, alias, index_alias) {
  var obj;
  if (alias === void 0) alias = this.$props['+alias'];
  if (index_alias === void 0) index_alias = this.$props['+index'];
  return obj = {}, obj[alias] = item, obj[index_alias || '$index'] = index, obj.$even = index % 2 === 0, obj.$odd = index % 2 !== 0, obj;
}

var isReservedTag = makeMap('template', true);

var _Vue;

function setVue(Vue) {
  _Vue = Vue;
}

var canBeLeftOpenTag = function (el) {
  return getViewMeta(el).canBeLeftOpenTag;
};

var isUnaryTag = function (el) {
  return getViewMeta(el).isUnaryTag;
};

function mustUseProp() {// console.log('mustUseProp')
}

function getTagNamespace(el) {
  return getViewMeta(el).tagNamespace;
}

function isUnknownElement(el) {
  return !isKnownView(el);
}

var VUE_VERSION = global.process.env.VUE_VERSION || '2.6.12';
var NS_VUE_VERSION = global.process.env.NS_VUE_VERSION || '2.8.4';
var infoTrace = once(function () {
  console.log("NativeScript-Vue has \"Vue.config.silent\" set to true, to see output logs set it to false.");
});

function trace(message) {
  if (_Vue && _Vue.config.silent) {
    return infoTrace();
  }

  if (_Vue && !_Vue.config.suppressRenderLogs) {
    console.log("{NSVue (Vue: " + VUE_VERSION + " | NSVue: " + NS_VUE_VERSION + ")} -> " + message);
  }
}

function updateDevtools() {
  if (global.__VUE_DEVTOOLS_GLOBAL_HOOK__) {
    try {
      global.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('flush');
    } catch (err) {//
    }
  }
}

var PAGE_REF = '__vuePageRef__';
var page = {
  render: function render(h) {
    return h('NativePage', {
      attrs: this.$attrs,
      on: this.$listeners
    }, this.$slots.default);
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$el.nativeView[PAGE_REF] = this;

    var frame = this._findParentFrame(); // we only need call this for the "defaultPage" of the frame
    // which is equivalent to testing if any page is "current" in the frame


    if (frame && !frame.firstPageMounted && !frame.$el.nativeView.currentPage) {
      frame.firstPageMounted = true;
      frame.notifyFirstPageMounted(this);
    }

    var handler = function (e) {
      if (e.isBackNavigation) {
        this$1.$el.nativeView.off('navigatedFrom', handler);
        this$1.$parent.$destroy();
      }
    };

    this.$el.nativeView.on('navigatedFrom', handler); // ensure that the parent vue instance is destroyed when the
    // page is disposed (clearHistory: true for example)

    var dispose = this.$el.nativeView.disposeNativeView;

    this.$el.nativeView.disposeNativeView = function () {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len];

      this$1.$parent.$destroy();
      dispose.call(this$1.$el.nativeView, args);
      updateDevtools();
    };
  },
  methods: {
    _findParentFrame: function _findParentFrame() {
      var frame = this.$parent;

      while (frame && frame.$options.name !== 'Frame') {
        frame = frame.$parent;
      }

      return frame;
    }
  }
};
var tabView = {
  model: {
    prop: 'selectedIndex',
    event: 'selectedIndexChange'
  },
  render: function render(h) {
    return h('NativeTabView', {
      on: this.$listeners,
      attrs: this.$attrs
    }, this.$slots.default);
  },
  methods: {
    registerTab: function registerTab(tabView) {
      var items = this.$el.nativeView.items || [];
      this.$el.setAttribute('items', items.concat([tabView]));
    }
  }
};
var tabViewItem = {
  template: "<NativeTabViewItem><slot /></NativeTabViewItem>",
  mounted: function mounted() {
    if (this.$el.childNodes.length > 1) {
      warn$1('TabViewItem should contain only 1 root element', this);
    }

    var _nativeView = this.$el.nativeView;
    _nativeView.view = this.$el.childNodes[0].nativeView;
    this.$parent.registerTab(_nativeView);
  }
};
var bottomNavigation = {
  model: {
    prop: 'selectedIndex',
    event: 'selectedIndexChange'
  },
  render: function render(h) {
    return h('NativeBottomNavigation', {
      on: this.$listeners,
      attrs: this.$attrs
    }, this.$slots.default);
  },
  methods: {
    registerTabStrip: function registerTabStrip(tabStrip) {
      this.$el.setAttribute('tabStrip', tabStrip);
    },
    registerTabContentItem: function registerTabContentItem(tabContentItem) {
      var items = this.$el.nativeView.items || [];
      this.$el.setAttribute('items', items.concat([tabContentItem]));
    }
  }
};
var tabs = {
  model: {
    prop: 'selectedIndex',
    event: 'selectedIndexChange'
  },
  render: function render(h) {
    return h('NativeTabs', {
      on: this.$listeners,
      attrs: this.$attrs
    }, this.$slots.default);
  },
  methods: {
    registerTabStrip: function registerTabStrip(tabStrip) {
      this.$el.setAttribute('tabStrip', tabStrip);
    },
    registerTabContentItem: function registerTabContentItem(tabContentItem) {
      var items = this.$el.nativeView.items || [];
      this.$el.setAttribute('items', items.concat([tabContentItem]));
    }
  }
};
var tabStrip = {
  render: function render(h) {
    return h('NativeTabStrip', {
      on: this.$listeners,
      attrs: this.$attrs
    }, this.$slots.default);
  },
  mounted: function mounted() {
    var _nativeView = this.$el.nativeView;
    this.$parent.registerTabStrip(_nativeView);
  },
  methods: {
    registerTabStripItem: function registerTabStripItem(tabStripItem) {
      var items = this.$el.nativeView.items || [];
      this.$el.setAttribute('items', items.concat([tabStripItem]));
    }
  }
};
var tabStripItem = {
  render: function render(h) {
    return h('NativeTabStripItem', {
      on: this.$listeners,
      attrs: this.$attrs
    }, this.$slots.default);
  },
  mounted: function mounted() {
    var _nativeView = this.$el.nativeView;
    this.$parent.registerTabStripItem(_nativeView);
  }
};
var tabContentItem = {
  template: "<NativeTabContentItem><slot /></NativeTabContentItem>",
  mounted: function mounted() {
    if (this.$el.childNodes.length > 1) {
      warn$1('TabContentItem should contain only 1 root element', this);
    }

    var _nativeView = this.$el.nativeView;
    _nativeView.view = this.$el.childNodes[0].nativeView;
    this.$parent.registerTabContentItem(_nativeView);
  }
};
/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
}; // in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered

function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;

  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options; // props

  for (var key in options.propsData) {
    data[key] = comp[key];
  } // events.
  // extract listeners and pass them directly to the transition methods


  var listeners = options._parentListeners;

  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }

  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var isNotTextNode = function (c) {
  return c.tag || isAsyncPlaceholder(c);
};

var isVShowDirective = function (d) {
  return d.name === 'show';
};

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      return;
    } // filter out text nodes (possible whitespaces)


    children = children.filter(isNotTextNode);
    /* istanbul ignore if */

    if (!children.length) {
      return;
    } // warn multiple elements


    if ( true && children.length > 1) {
      warn$1('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode; // warn invalid mode

    if ( true && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn$1('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0]; // if this is a component root node and the component's
    // parent container node also has transition, skip.

    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    } // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive


    var child = getRealChild(rawChild);
    /* istanbul ignore if */

    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    } // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.


    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild); // mark v-show
    // so that the transition module can hand over the control to the directive

    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }

        var delayedLeave;

        var performLeave = function () {
          delayedLeave();
        };

        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};
var elementMap = {};
var nativeRegExp = /Native/gi;
var dashRegExp = /-/g;
var defaultViewMeta = {
  skipAddToDom: false,
  isUnaryTag: false,
  tagNamespace: '',
  canBeLeftOpenTag: false,
  model: null,
  component: null
};

function normalizeElementName(elementName) {
  return "native" + elementName.replace(nativeRegExp, '').replace(dashRegExp, '').toLowerCase();
}

function registerElement(elementName, resolver, meta) {
  var normalizedName = normalizeElementName(elementName);
  meta = Object.assign({}, defaultViewMeta, meta); // allow override of elements classes (N ones especially)
  // this is very practical in case you want to test new component
  // or simply override the global Button for example

  if (elementMap[normalizedName]) {
    trace("Element for " + elementName + " already registered.");
  }

  if (!meta.component) {
    // if no Vue component is passed, wrap the simpler vue component
    // which bind the events and attributes to the NS one
    meta.component = {
      functional: true,
      model: meta.model,
      render: function (h, ref) {
        var data = ref.data;
        var children = ref.children;
        return h(normalizedName, data, children);
      }
    };
  }

  meta.component.name = elementName;
  elementMap[normalizedName] = {
    resolver: resolver,
    meta: meta
  };
}

function getElementMap() {
  return elementMap;
}

function getViewClass(elementName) {
  var normalizedName = normalizeElementName(elementName);
  var entry = elementMap[normalizedName];

  if (!entry) {
    throw new TypeError("No known component for element " + elementName + ".");
  }

  try {
    return entry.resolver();
  } catch (e) {
    throw new TypeError("Could not load view for: " + elementName + ". " + e + " " + e.stack);
  }
}

function getViewMeta(elementName) {
  var normalizedName = normalizeElementName(elementName);
  var meta = defaultViewMeta;
  var entry = elementMap[normalizedName];

  if (entry && entry.meta) {
    meta = entry.meta;
  }

  return meta;
}

function isKnownView(elementName) {
  return elementMap[normalizeElementName(elementName)];
}

registerElement('ActionBar', function () {
  return __webpack_require__("@nativescript/core").ActionBar;
}, {
  removeChild: function removeChild(parent, child) {
    try {
      parent.nativeView._removeView(child.nativeView);
    } catch (e) {// ignore exception - child is likely already removed/replaced
      // fixes #76
    }
  },
  component: actionBar
});
registerElement('ActionItem', function () {
  return __webpack_require__("@nativescript/core").ActionItem;
});
registerElement('android', null, {
  component: android
});
registerElement('ios', null, {
  component: ios
});
registerElement('ListView', function () {
  return __webpack_require__("@nativescript/core").ListView;
}, {
  component: listView
});
registerElement('NavigationButton', function () {
  return __webpack_require__("@nativescript/core").NavigationButton;
});
registerElement('TabView', function () {
  return __webpack_require__("@nativescript/core").TabView;
}, {
  model: {
    prop: 'selectedIndex',
    event: 'selectedIndexChange'
  },
  component: tabView
});
registerElement('TabViewItem', function () {
  return __webpack_require__("@nativescript/core").TabViewItem;
}, {
  skipAddToDom: true,
  component: tabViewItem
});
registerElement('BottomNavigation', function () {
  return __webpack_require__("@nativescript/core").BottomNavigation;
}, {
  model: {
    prop: 'selectedIndex',
    event: 'selectedIndexChange'
  },
  component: bottomNavigation
});
registerElement('Tabs', function () {
  return __webpack_require__("@nativescript/core").Tabs;
}, {
  model: {
    prop: 'selectedIndex',
    event: 'selectedIndexChange'
  },
  component: tabs
});
registerElement('TabStrip', function () {
  return __webpack_require__("@nativescript/core").TabStrip;
}, {
  skipAddToDom: true,
  component: tabStrip
});
registerElement('TabStripItem', function () {
  return __webpack_require__("@nativescript/core").TabStripItem;
}, {
  skipAddToDom: true,
  component: tabStripItem
});
registerElement('TabContentItem', function () {
  return __webpack_require__("@nativescript/core").TabContentItem;
}, {
  skipAddToDom: true,
  component: tabContentItem
});
registerElement('transition', null, {
  component: Transition
});
registerElement('v-template', null, {
  component: vTemplate$1
}); // NS components which uses the automatic registerElement Vue wrapper
// as they do not need any special logic

registerElement('Label', function () {
  return __webpack_require__("@nativescript/core").Label;
}, {
  model: {
    prop: 'text',
    event: 'textChange'
  }
});
registerElement('DatePicker', function () {
  return __webpack_require__("@nativescript/core").DatePicker;
}, {
  model: {
    prop: 'date',
    event: 'dateChange'
  }
});
registerElement('AbsoluteLayout', function () {
  return __webpack_require__("@nativescript/core").AbsoluteLayout;
});
registerElement('ActivityIndicator', function () {
  return __webpack_require__("@nativescript/core").ActivityIndicator;
});
registerElement('Button', function () {
  return __webpack_require__("@nativescript/core").Button;
});
registerElement('ContentView', function () {
  return __webpack_require__("@nativescript/core").ContentView;
});
registerElement('DockLayout', function () {
  return __webpack_require__("@nativescript/core").DockLayout;
});
registerElement('GridLayout', function () {
  return __webpack_require__("@nativescript/core").GridLayout;
});
registerElement('HtmlView', function () {
  return __webpack_require__("@nativescript/core").HtmlView;
});
registerElement('Image', function () {
  return __webpack_require__("@nativescript/core").Image;
});
registerElement('img', function () {
  return __webpack_require__("@nativescript/core").Image;
});
registerElement('ListPicker', function () {
  return __webpack_require__("@nativescript/core").ListPicker;
}, {
  model: {
    prop: 'selectedIndex',
    event: 'selectedIndexChange'
  }
});
registerElement('Page', function () {
  return __webpack_require__("@nativescript/core").Page;
}, {
  skipAddToDom: true,
  component: page
});
registerElement('Placeholder', function () {
  return __webpack_require__("@nativescript/core").Placeholder;
});
registerElement('Progress', function () {
  return __webpack_require__("@nativescript/core").Progress;
}, {
  model: {
    prop: 'value',
    event: 'valueChange'
  }
});
registerElement('ProxyViewContainer', function () {
  return __webpack_require__("@nativescript/core").ProxyViewContainer;
}); // registerElement(
//   'Repeater',
//   () => require('@nativescript/core').Repeater
// )

registerElement('ScrollView', function () {
  return __webpack_require__("@nativescript/core").ScrollView;
});
registerElement('SearchBar', function () {
  return __webpack_require__("@nativescript/core").SearchBar;
}, {
  model: {
    prop: 'text',
    event: 'textChange'
  }
});
registerElement('SegmentedBar', function () {
  return __webpack_require__("@nativescript/core").SegmentedBar;
}, {
  model: {
    prop: 'selectedIndex',
    event: 'selectedIndexChange'
  }
});
registerElement('SegmentedBarItem', function () {
  return __webpack_require__("@nativescript/core").SegmentedBarItem;
});
registerElement('Slider', function () {
  return __webpack_require__("@nativescript/core").Slider;
}, {
  model: {
    prop: 'value',
    event: 'valueChange'
  }
});
registerElement('StackLayout', function () {
  return __webpack_require__("@nativescript/core").StackLayout;
});
registerElement('FlexboxLayout', function () {
  return __webpack_require__("@nativescript/core").FlexboxLayout;
});
registerElement('Switch', function () {
  return __webpack_require__("@nativescript/core").Switch;
}, {
  model: {
    prop: 'checked',
    event: 'checkedChange'
  }
});
registerElement('TextField', function () {
  return __webpack_require__("@nativescript/core").TextField;
}, {
  model: {
    prop: 'text',
    event: 'textChange'
  }
});
registerElement('TextView', function () {
  return __webpack_require__("@nativescript/core").TextView;
}, {
  model: {
    prop: 'text',
    event: 'textChange'
  }
});
registerElement('TimePicker', function () {
  return __webpack_require__("@nativescript/core").TimePicker;
}, {
  model: {
    prop: 'time',
    event: 'timeChange'
  }
});
registerElement('WebView', function () {
  return __webpack_require__("@nativescript/core").WebView;
});
registerElement('WrapLayout', function () {
  return __webpack_require__("@nativescript/core").WrapLayout;
});
registerElement('FormattedString', function () {
  return __webpack_require__("@nativescript/core").FormattedString;
}, {
  insertChild: function insertChild(parentNode, childNode, atIndex) {
    if (atIndex > -1) {
      parentNode.nativeView.spans.splice(atIndex, 0, childNode.nativeView);
      return;
    }

    parentNode.nativeView.spans.push(childNode.nativeView);
  },
  removeChild: function removeChild(parentNode, childNode) {
    var index = parentNode.nativeView.spans.indexOf(childNode.nativeView);

    if (index > -1) {
      parentNode.nativeView.spans.splice(index, 1);
    }
  }
});
registerElement('Span', function () {
  return __webpack_require__("@nativescript/core").Span;
});
registerElement('DetachedContainer', function () {
  return __webpack_require__("@nativescript/core").ProxyViewContainer;
}, {
  skipAddToDom: true
});
registerElement('DetachedText', function () {
  return __webpack_require__("@nativescript/core").Placeholder;
}, {
  skipAddToDom: true
});
registerElement('Comment', function () {
  return __webpack_require__("@nativescript/core").Placeholder;
});
registerElement('Document', function () {
  return __webpack_require__("@nativescript/core").ProxyViewContainer;
}, {
  skipAddToDom: true
});
registerElement('Frame', function () {
  return __webpack_require__("@nativescript/core").Frame;
}, {
  insertChild: function insertChild(parentNode, childNode, atIndex) {// if (normalizeElementName(childNode.tagName) === 'nativepage') {
    // parentNode.nativeView.navigate({ create: () => childNode.nativeView })
    // }
  },
  component: frame
});
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isobject = function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */


function isObjectObject(o) {
  return isobject(o) === true && Object.prototype.toString.call(o) === '[object Object]';
}

var isPlainObject = function isPlainObject(o) {
  var ctor, prot;

  if (isObjectObject(o) === false) {
    return false;
  } // If has modified constructor


  ctor = o.constructor;

  if (typeof ctor !== 'function') {
    return false;
  } // If has modified prototype


  prot = ctor.prototype;

  if (isObjectObject(prot) === false) {
    return false;
  } // If constructor does not have an Object-specific method


  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  } // Most likely a plain Object


  return true;
};
/*!
 * set-value <https://github.com/jonschlinkert/set-value>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */


function set(target, path, value, options) {
  if (!isObject(target)) {
    return target;
  }

  var opts = options || {};
  var isArray = Array.isArray(path);

  if (!isArray && typeof path !== 'string') {
    return target;
  }

  var merge = opts.merge;

  if (merge && typeof merge !== 'function') {
    merge = Object.assign;
  }

  var keys = (isArray ? path : split(path, opts)).filter(isValidKey);
  var len = keys.length;
  var orig = target;

  if (!options && keys.length === 1) {
    result(target, keys[0], value, merge);
    return target;
  }

  for (var i = 0; i < len; i++) {
    var prop = keys[i];

    if (!isObject(target[prop])) {
      target[prop] = {};
    }

    if (i === len - 1) {
      result(target, prop, value, merge);
      break;
    }

    target = target[prop];
  }

  return orig;
}

function result(target, path, value, merge) {
  if (merge && isPlainObject(target[path]) && isPlainObject(value)) {
    target[path] = merge({}, target[path], value);
  } else {
    target[path] = value;
  }
}

function split(path, options) {
  var id = createKey(path, options);

  if (set.memo[id]) {
    return set.memo[id];
  }

  var char = options && options.separator ? options.separator : '.';
  var keys = [];
  var res = [];

  if (options && typeof options.split === 'function') {
    keys = options.split(path);
  } else {
    keys = path.split(char);
  }

  for (var i = 0; i < keys.length; i++) {
    var prop = keys[i];

    while (prop && prop.slice(-1) === '\\' && keys[i + 1] != null) {
      prop = prop.slice(0, -1) + char + keys[++i];
    }

    res.push(prop);
  }

  set.memo[id] = res;
  return res;
}

function createKey(pattern, options) {
  var id = pattern;

  if (typeof options === 'undefined') {
    return id + '';
  }

  var keys = Object.keys(options);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    id += ';' + key + '=' + String(options[key]);
  }

  return id;
}

function isValidKey(key) {
  return key !== '__proto__' && key !== 'constructor' && key !== 'prototype';
}

function isObject(val) {
  return val !== null && (typeof val === 'object' || typeof val === 'function');
}

set.memo = {};
var setValue = set;
var View;

function isView(view) {
  if (!View) {
    View = __webpack_require__("@nativescript/core").View;
  }

  return view instanceof View;
}

var LayoutBase;

function isLayout(view) {
  if (!LayoutBase) {
    LayoutBase = __webpack_require__("@nativescript/core").LayoutBase;
  }

  return view instanceof LayoutBase;
}

var ContentView;

function isContentView(view) {
  if (!ContentView) {
    ContentView = __webpack_require__("@nativescript/core").ContentView;
  }

  return view instanceof ContentView;
}

function insertChild(parentNode, childNode, atIndex) {
  if (atIndex === void 0) atIndex = -1;

  if (!parentNode) {
    return;
  }

  if (parentNode.meta && typeof parentNode.meta.insertChild === 'function') {
    return parentNode.meta.insertChild(parentNode, childNode, atIndex);
  }

  if (childNode.meta.skipAddToDom) {
    return;
  }

  var parentView = parentNode.nativeView;
  var childView = childNode.nativeView;

  if (isLayout(parentView)) {
    if (childView.parent === parentView) {
      var index = parentView.getChildIndex(childView);

      if (index !== -1) {
        parentView.removeChild(childView);
      }
    }

    if (atIndex !== -1) {
      parentView.insertChild(childView, atIndex);
    } else {
      parentView.addChild(childView);
    }
  } else if (isContentView(parentView)) {
    if (childNode.nodeType === 8) {
      parentView._addView(childView, atIndex);
    } else {
      parentView.content = childView;
    }
  } else if (parentView && parentView._addChildFromBuilder) {
    parentView._addChildFromBuilder(childNode._nativeView.constructor.name, childView);
  } else ;
}

function removeChild$1(parentNode, childNode) {
  if (!parentNode) {
    return;
  }

  if (parentNode.meta && typeof parentNode.meta.removeChild === 'function') {
    return parentNode.meta.removeChild(parentNode, childNode);
  }

  if (childNode.meta.skipAddToDom) {
    return;
  }

  var parentView = parentNode.nativeView;
  var childView = childNode.nativeView;

  if (isLayout(parentView)) {
    parentView.removeChild(childView);
  } else if (isContentView(parentView)) {
    if (parentView.content === childView) {
      parentView.content = null;
    }

    if (childNode.nodeType === 8) {
      parentView._removeView(childView);
    }
  } else if (isView(parentView)) {
    parentView._removeView(childView);
  } else ;
}

var XML_ATTRIBUTES = Object.freeze(['style', 'rows', 'columns', 'fontAttributes']);

var ViewNode = function ViewNode() {
  this.nodeType = null;
  this._tagName = null;
  this.parentNode = null;
  this.childNodes = [];
  this.prevSibling = null;
  this.nextSibling = null;
  this._ownerDocument = null;
  this._nativeView = null;
  this._meta = null;
  /* istanbul ignore next
   * make vue happy :)
   */

  this.hasAttribute = this.removeAttribute = function () {
    return false;
  };
};

var prototypeAccessors = {
  tagName: {
    configurable: true
  },
  firstChild: {
    configurable: true
  },
  lastChild: {
    configurable: true
  },
  nativeView: {
    configurable: true
  },
  meta: {
    configurable: true
  },
  ownerDocument: {
    configurable: true
  }
};
/* istanbul ignore next */

ViewNode.prototype.toString = function toString() {
  return this.constructor.name + "(" + this.tagName + ")";
};

prototypeAccessors.tagName.set = function (name) {
  this._tagName = normalizeElementName(name);
};

prototypeAccessors.tagName.get = function () {
  return this._tagName;
};

prototypeAccessors.firstChild.get = function () {
  return this.childNodes.length ? this.childNodes[0] : null;
};

prototypeAccessors.lastChild.get = function () {
  return this.childNodes.length ? this.childNodes[this.childNodes.length - 1] : null;
};

prototypeAccessors.nativeView.get = function () {
  return this._nativeView;
};

prototypeAccessors.nativeView.set = function (view) {
  if (this._nativeView) {
    throw new Error("Can't override native view.");
  }

  this._nativeView = view;
};

prototypeAccessors.meta.get = function () {
  if (this._meta) {
    return this._meta;
  }

  return this._meta = getViewMeta(this.tagName);
};
/* istanbul ignore next */


prototypeAccessors.ownerDocument.get = function () {
  if (this._ownerDocument) {
    return this._ownerDocument;
  }

  var el = this;

  while ((el = el.parentNode).nodeType !== 9) {// do nothing
  }

  return this._ownerDocument = el;
};

ViewNode.prototype.getAttribute = function getAttribute(key) {
  return this.nativeView[key];
};
/* istanbul ignore next */


ViewNode.prototype.setAttribute = function setAttribute(key, value) {
  var isAndroid = true;
  var isIOS = false;
  var nv = this.nativeView;

  try {
    if (XML_ATTRIBUTES.indexOf(key) !== -1) {
      nv[key] = value;
    } else {
      // detect expandable attrs for boolean values
      // See https://vuejs.org/v2/guide/components-props.html#Passing-a-Boolean
      if (__webpack_require__("@nativescript/core").Utils.isBoolean(nv[key]) && value === '') {
        value = true;
      }

      if (isAndroid && key.startsWith('android:')) {
        setValue(nv, key.substr(8), value);
      } else if (isIOS && key.startsWith('ios:')) {
        setValue(nv, key.substr(4), value);
      } else if (key.endsWith('.decode')) {
        setValue(nv, key.slice(0, -7), __webpack_require__("@nativescript/core").XmlParser._dereferenceEntities(value));
      } else {
        setValue(nv, key, value);
      }
    }
  } catch (e) {// ignore
  }
};
/* istanbul ignore next */


ViewNode.prototype.setStyle = function setStyle(property, value) {
  if (!value || !(value = value.trim()).length) {
    return;
  }

  if (property.endsWith('Align')) {
    // NativeScript uses Alignment instead of Align, this ensures that text-align works
    property += 'ment';
  }

  this.nativeView.style[property] = value;
};
/* istanbul ignore next */


ViewNode.prototype.setText = function setText(text) {
  if (this.nodeType === 3) {
    this.parentNode.setText(text);
  } else {
    this.setAttribute('text', text);
  }
};
/* istanbul ignore next */


ViewNode.prototype.addEventListener = function addEventListener(event, handler) {
  this.nativeView.on(event, handler);
};
/* istanbul ignore next */


ViewNode.prototype.removeEventListener = function removeEventListener(event) {
  this.nativeView.off(event);
};

ViewNode.prototype.insertBefore = function insertBefore(childNode, referenceNode) {
  if (!childNode) {
    throw new Error("Can't insert child.");
  }

  if (referenceNode && referenceNode.parentNode && referenceNode.parentNode !== this) {
    throw new Error("Can't insert child, because the reference node has a different parent.");
  }

  if (childNode.parentNode && childNode.parentNode !== this) {
    throw new Error("Can't insert child, because it already has a different parent.");
  }

  if (childNode.parentNode === this) {
    // in case the childNode is already a child node of this view
    // we need to first remove it to clean up childNodes, parentNode, prev/next siblings
    // we are adding back the child right after - this is often the case when the order
    // of children has to change (including comment nodes created by vue)
    // fixes #608
    this.removeChild(childNode); // we don't need to throw an error here, because it is a valid case
    // for example when switching the order of elements in the tree
    // fixes #127 - see for more details
    // fixes #240
    // throw new Error(`Can't insert child, because it is already a child.`)
  } // in some rare cases insertBefore is called with a null referenceNode
  // this makes sure that it get's appended as the last child


  if (!referenceNode) {
    return this.appendChild(childNode);
  }

  var index = this.childNodes.indexOf(referenceNode);
  childNode.parentNode = this;
  childNode.nextSibling = referenceNode;
  childNode.prevSibling = this.childNodes[index - 1];

  if (childNode.prevSibling) {
    childNode.prevSibling.nextSibling = childNode;
  }

  referenceNode.prevSibling = childNode;
  this.childNodes.splice(index, 0, childNode);
  insertChild(this, childNode, index);
};

ViewNode.prototype.appendChild = function appendChild(childNode) {
  if (!childNode) {
    throw new Error("Can't append child.");
  }

  if (childNode.parentNode && childNode.parentNode !== this) {
    throw new Error("Can't append child, because it already has a different parent.");
  }

  childNode.parentNode = this;

  if (this.lastChild) {
    childNode.prevSibling = this.lastChild;
    this.lastChild.nextSibling = childNode;
  }

  this.childNodes.push(childNode);
  insertChild(this, childNode);
};

ViewNode.prototype.removeChild = function removeChild(childNode) {
  if (!childNode) {
    throw new Error("Can't remove child.");
  }

  if (!childNode.parentNode) {
    throw new Error("Can't remove child, because it has no parent.");
  }

  if (childNode.parentNode !== this) {
    throw new Error("Can't remove child, because it has a different parent.");
  }

  childNode.parentNode = null;

  if (childNode.prevSibling) {
    childNode.prevSibling.nextSibling = childNode.nextSibling;
  }

  if (childNode.nextSibling) {
    childNode.nextSibling.prevSibling = childNode.prevSibling;
  } // reset the prevSibling and nextSibling. If not, a keep-alived component will
  // still have a filled nextSibling attribute so vue will not
  // insert the node again to the parent. See #220


  childNode.prevSibling = null;
  childNode.nextSibling = null;
  this.childNodes = this.childNodes.filter(function (node) {
    return node !== childNode;
  });
  removeChild$1(this, childNode);
};

Object.defineProperties(ViewNode.prototype, prototypeAccessors);
var VUE_ELEMENT_REF = '__vue_element_ref__';

var ElementNode = /*@__PURE__*/function (ViewNode) {
  function ElementNode(tagName) {
    ViewNode.call(this);
    this.nodeType = 1;
    this.tagName = tagName;
    var viewClass = getViewClass(tagName);

    if (!viewClass) {
      throw new TypeError("No native component for element tag name " + tagName + ".");
    }

    this._nativeView = new viewClass();
    this._nativeView[VUE_ELEMENT_REF] = this;
  }

  if (ViewNode) ElementNode.__proto__ = ViewNode;
  ElementNode.prototype = Object.create(ViewNode && ViewNode.prototype);
  ElementNode.prototype.constructor = ElementNode;

  ElementNode.prototype.toString = function toString() {
    return this.nativeView.toString();
  };

  ElementNode.prototype.appendChild = function appendChild(childNode) {
    ViewNode.prototype.appendChild.call(this, childNode);

    if (childNode.nodeType === 3) {
      this.setText(childNode.text);
    }
  };

  ElementNode.prototype.insertBefore = function insertBefore(childNode, referenceNode) {
    ViewNode.prototype.insertBefore.call(this, childNode, referenceNode);

    if (childNode.nodeType === 3) {
      this.setText(childNode.text);
    }
  };

  ElementNode.prototype.removeChild = function removeChild(childNode) {
    ViewNode.prototype.removeChild.call(this, childNode);

    if (childNode.nodeType === 3) {
      this.setText('');
    }
  };

  return ElementNode;
}(ViewNode);

var CommentNode = /*@__PURE__*/function (ElementNode) {
  function CommentNode(text) {
    ElementNode.call(this, 'comment');
    this.nodeType = 8;
    this.text = text;
  }

  if (ElementNode) CommentNode.__proto__ = ElementNode;
  CommentNode.prototype = Object.create(ElementNode && ElementNode.prototype);
  CommentNode.prototype.constructor = CommentNode;
  return CommentNode;
}(ElementNode);

var TextNode = /*@__PURE__*/function (ViewNode) {
  function TextNode(text) {
    ViewNode.call(this);
    this.nodeType = 3;
    this.text = text;
    this._meta = {
      skipAddToDom: true
    };
  }

  if (ViewNode) TextNode.__proto__ = ViewNode;
  TextNode.prototype = Object.create(ViewNode && ViewNode.prototype);
  TextNode.prototype.constructor = TextNode;

  TextNode.prototype.setText = function setText(text) {
    this.text = text;
    this.parentNode.setText(text);
  };

  return TextNode;
}(ViewNode);

var DocumentNode = /*@__PURE__*/function (ViewNode) {
  function DocumentNode() {
    ViewNode.call(this);
    this.nodeType = 9;
    this.documentElement = new ElementNode('document'); // make static methods accessible via this

    this.createComment = this.constructor.createComment;
    this.createElement = this.constructor.createElement;
    this.createElementNS = this.constructor.createElementNS;
    this.createTextNode = this.constructor.createTextNode;
  }

  if (ViewNode) DocumentNode.__proto__ = ViewNode;
  DocumentNode.prototype = Object.create(ViewNode && ViewNode.prototype);
  DocumentNode.prototype.constructor = DocumentNode;

  DocumentNode.createComment = function createComment(text) {
    try {
      return new CommentNode(text);
    } catch (err) {
      console.log(err);
    }
  };

  DocumentNode.createElement = function createElement(tagName) {
    try {
      return new ElementNode(tagName);
    } catch (err) {
      console.log(err);
    }
  };

  DocumentNode.createElementNS = function createElementNS(namespace, tagName) {
    try {
      return new ElementNode(namespace + ':' + tagName);
    } catch (err) {
      console.log(err);
    }
  };

  DocumentNode.createTextNode = function createTextNode(text) {
    try {
      return new TextNode(text);
    } catch (err) {
      console.log(err);
    }
  };

  return DocumentNode;
}(ViewNode);

var namespaceMap = {};

function createElement(tagName, vnode) {
  trace("CreateElement(" + tagName.replace(/^native/i, '') + ")");
  return DocumentNode.createElement(tagName);
}

function createElementNS(namespace, tagName) {
  trace("CreateElementNS(" + namespace + "#" + tagName + ")");
  return DocumentNode.createElementNS(namespace, tagName);
}

function createTextNode(text) {
  trace("CreateTextNode(" + text + ")");
  return DocumentNode.createTextNode(text);
}

function createComment(text) {
  trace("CreateComment(" + text + ")");
  return DocumentNode.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  trace("InsertBefore(" + parentNode + ", " + newNode + ", " + referenceNode + ")");
  return parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  trace("RemoveChild(" + node + ", " + child + ")");
  return node.removeChild(child);
}

function appendChild(node, child) {
  trace("AppendChild(" + node + ", " + child + ")");
  return node.appendChild(child);
}

function parentNode(node) {
  trace("ParentNode(" + node + ") -> " + node.parentNode);
  return node.parentNode;
}

function nextSibling(node) {
  trace("NextSibling(" + node + ") -> " + node.nextSibling);
  return node.nextSibling;
}

function tagName(elementNode) {
  trace("TagName(" + elementNode + ") -> " + elementNode.tagName);
  return elementNode.tagName;
}

function setTextContent(node, text) {
  trace("SetTextContent(" + node + ", " + text + ")");
  node.setText(text);
}

function setAttribute(node, key, val) {
  trace("SetAttribute(" + node + ", " + key + ", " + val + ")");
  node.setAttribute(key, val);
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  __proto__: null,
  namespaceMap: namespaceMap,
  createElement: createElement,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setAttribute: setAttribute,
  setStyleScope: setStyleScope
});
var modules$1 = platformModules.concat(baseModules);
var patch = createPatchFunction({
  nodeOps: nodeOps,
  modules: modules$1
});
var he = {
  decode: decode
};

function decode(html) {
  // todo?
  return html;
}
/*  */


makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open
// (and which close themselves)

makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content

var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');
/**
 * Not type-checking this file because it's mostly vendor code.
 */
// Regular Expressions for parsing tags and attributes

var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeRegExp.source + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp("^<" + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being passed as HTML comment when inlined in page

var comment = /^<!\--/;
var conditionalComment = /^<!\[/; // Special Elements (can contain anything)

var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};
var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992

var isIgnoreNewlineTag = makeMap('pre,textarea', true);

var shouldIgnoreFirstNewline = function (tag, html) {
  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
};

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag = options.isUnaryTag || no;
  var canBeLeftOpenTag = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;

  while (html) {
    last = html; // Make sure we're not in a plaintext content element like script/style

    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');

      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }

            advance(commentEnd + 3);
            continue;
          }
        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment


        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        } // Doctype:


        var doctypeMatch = html.match(doctype);

        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        } // End tag:


        var endTagMatch = html.match(endTag);

        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        } // Start tag:


        var startTagMatch = parseStartTag();

        if (startTagMatch) {
          handleStartTag(startTagMatch);

          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }

          continue;
        }
      }

      var text = void 0,
          rest = void 0,
          next = void 0;

      if (textEnd >= 0) {
        rest = html.slice(textEnd);

        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);

          if (next < 0) {
            break;
          }

          textEnd += next;
          rest = html.slice(textEnd);
        }

        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;

        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
          .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }

        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }

        if (options.chars) {
          options.chars(text);
        }

        return '';
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);

      if ( true && !stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"", {
          start: index + html.length
        });
      }

      break;
    }
  } // Clean up any remaining tags


  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);

    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;

      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }

      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }

      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag(tagName) || !!unarySlash;
    var l = match.attrs.length;
    var attrs = new Array(l);

    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };

      if ( true && options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length;
        attrs[i].end = args.end;
      }
    }

    if (!unary) {
      stack.push({
        tag: tagName,
        lowerCasedTag: tagName.toLowerCase(),
        attrs: attrs,
        start: match.start,
        end: match.end
      });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;

    if (start == null) {
      start = index;
    }

    if (end == null) {
      end = index;
    } // Find the closest opened tag of the same type


    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();

      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if ( true && (i > pos || !tagName) && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.", {
            start: stack[i].start,
            end: stack[i].end
          });
        }

        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      } // Remove the open elements from the stack


      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }

      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}
/*  */


var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);

    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;
          break;
        // "

        case 0x27:
          inSingle = true;
          break;
        // '

        case 0x60:
          inTemplateString = true;
          break;
        // `

        case 0x28:
          paren++;
          break;
        // (

        case 0x29:
          paren--;
          break;
        // )

        case 0x5B:
          square++;
          break;
        // [

        case 0x5D:
          square--;
          break;
        // ]

        case 0x7B:
          curly++;
          break;
        // {

        case 0x7D:
          curly--;
          break;
        // }
      }

      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0; // find first non-whitespace prev char

        for (; j >= 0; j--) {
          p = exp.charAt(j);

          if (p !== ' ') {
            break;
          }
        }

        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');

  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
  }
}
/*  */


var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;

  if (!tagRE.test(text)) {
    return;
  }

  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;

  while (match = tagRE.exec(text)) {
    index = match.index; // push text token

    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    } // tag token


    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    rawTokens.push({
      '@binding': exp
    });
    lastIndex = index + match[0].length;
  }

  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }

  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  };
}
/*  */

/**
 * Cross-platform code generation for component v-model
 */


function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;
  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;

  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var assignment = genAssignmentCode(value, valueExpression);
  el.model = {
    value: "(" + value + ")",
    expression: JSON.stringify(value),
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}
/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */


function genAssignmentCode(value, assignment) {
  var res = parseModel(value);

  if (res.key === null) {
    return value + "=" + assignment;
  } else {
    return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
  }
}
/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */


var len, str, chr, index, expressionPos, expressionEndPos;

function parseModel(val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index = val.lastIndexOf('.');

    if (index > -1) {
      return {
        exp: val.slice(0, index),
        key: '"' + val.slice(index + 1) + '"'
      };
    } else {
      return {
        exp: val,
        key: null
      };
    }
  }

  str = val;
  index = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */

    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index);
}

function eof() {
  return index >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index;

  while (!eof()) {
    chr = next();

    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }

    if (chr === 0x5B) {
      inBracket++;
    }

    if (chr === 0x5D) {
      inBracket--;
    }

    if (inBracket === 0) {
      expressionEndPos = index;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;

  while (!eof()) {
    chr = next();

    if (chr === stringQuote) {
      break;
    }
  }
}
/*  */

/* eslint-disable no-unused-vars */


function baseWarn(msg, range) {
  console.error("[Vue compiler]: " + msg);
}
/* eslint-enable no-unused-vars */


function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
}

function addAttr(el, name, value, range, dynamic) {
  var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);
  attrs.push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
} // add a raw attr (use this in preTransforms)


function addRawAttr(el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({
    name: name,
    value: value
  }, range));
}

function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker(symbol, name, dynamic) {
  return dynamic ? "_p(" + name + ",\"" + symbol + "\")" : symbol + name; // mark the event as captured
}

function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
  modifiers = modifiers || emptyObject; // warn prevent and passive modifier

  /* istanbul ignore if */

  if ( true && warn && modifiers.prevent && modifiers.passive) {
    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.', range);
  } // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.


  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  } // check capture modifier


  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }

  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */


  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;

  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({
    value: value.trim(),
    dynamic: dynamic
  }, range);

  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */

  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr(el, name) {
  return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);

  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);

    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
} // note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.


function getAndRemoveAttr(el, name, removeFromMap) {
  var val;

  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;

    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }

  if (removeFromMap) {
    delete el.attrsMap[name];
  }

  return val;
}

function getAndRemoveAttrByRegex(el, name) {
  var list = el.attrsList;

  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];

    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr;
    }
  }
}

function rangeSetItem(item, range) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }

    if (range.end != null) {
      item.end = range.end;
    }
  }

  return item;
}
/*  */


var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:|^#/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;
var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;
var slotRE = /^v-slot(:|$)|^#/;
var lineBreakRE = /[\r\n]/;
var whitespaceRE = /\s+/g;
var invalidAttributeRE = /[\s"'<>\/=]/;
var decodeHTMLCached = cached(he.decode);
var emptySlotScopeToken = "_empty_"; // configurable state

var warn;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement(tag, attrs, parent) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  };
}
/**
 * Convert HTML string to AST.
 */


function parse(template, options) {
  warn = options.warn || baseWarn;
  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;

  maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
  delimiters = options.delimiters;
  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg, range) {
    if (!warned) {
      warned = true;
      warn(msg, range);
    }
  }

  function closeElement(element) {
    trimEndingWhitespace(element);

    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    } // tree management


    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        if (true) {
          checkRootConstraints(element);
        }

        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else if (true) {
        warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.", {
          start: element.start
        });
      }
    }

    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"';
          (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }

        currentParent.children.push(element);
        element.parent = currentParent;
      }
    } // final children cleanup
    // filter out scoped slots


    element.children = element.children.filter(function (c) {
      return !c.slotScope;
    }); // remove trailing whitespace node again

    trimEndingWhitespace(element); // check pre state

    if (element.pre) {
      inVPre = false;
    }

    if (platformIsPreTag(element.tag)) {
      inPre = false;
    } // apply post-transforms


    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace(el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;

      while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints(el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.', {
        start: el.start
      });
    }

    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);
    }
  }

  parseHTML(template, {
    warn: warn,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start(tag, attrs, unary, start$1, end) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug

      /* istanbul ignore if */

      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);

      if (ns) {
        element.ns = ns;
      }

      if (true) {
        if (options.outputSourceRange) {
          element.start = start$1;
          element.end = end;
          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated;
          }, {});
        }

        attrs.forEach(function (attr) {
          if (invalidAttributeRE.test(attr.name)) {
            warn("Invalid dynamic argument expression: attribute names cannot contain " + "spaces, quotes, <, >, / or =.", {
              start: attr.start + attr.name.indexOf("["),
              end: attr.start + attr.name.length
            });
          }
        });
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
         true && warn('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.', {
          start: element.start
        });
      } // apply pre-transforms


      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);

        if (element.pre) {
          inVPre = true;
        }
      }

      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }

      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;

        if (true) {
          checkRootConstraints(root);
        }
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },
    end: function end(tag, start, end$1) {
      var element = stack[stack.length - 1]; // pop stack

      stack.length -= 1;
      currentParent = stack[stack.length - 1];

      if ( true && options.outputSourceRange) {
        element.end = end$1;
      }

      closeElement(element);
    },
    chars: function chars(text, start, end) {
      if (!currentParent) {
        if (true) {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.', {
              start: start
            });
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.", {
              start: start
            });
          }
        }

        return;
      } // IE textarea placeholder bug

      /* istanbul ignore if */


      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }

      var children = currentParent.children;

      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }

      if (text) {
        if (!inPre && whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE, ' ');
        }

        var res;
        var child;

        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }

        if (child) {
          if ( true && options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }

          children.push(child);
        }
      }
    },
    comment: function comment(text, start, end) {
      // adding anything as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };

        if ( true && options.outputSourceRange) {
          child.start = start;
          child.end = end;
        }

        currentParent.children.push(child);
      }
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var list = el.attrsList;
  var len = list.length;

  if (len) {
    var attrs = el.attrs = new Array(len);

    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };

      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement(element, options) {
  processKey(element); // determine whether this is a plain element after
  // removing structural attributes

  element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;
  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);

  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }

  processAttrs(element);
  return element;
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');

  if (exp) {
    if (true) {
      if (el.tag === 'template') {
        warn("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, 'key'));
      }

      if (el.for) {
        var iterator = el.iterator2 || el.iterator1;
        var parent = el.parent;

        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
          warn("Do not use v-for index as key on <transition-group> children, " + "this is the same as not using keys.", getRawBindingAttr(el, 'key'), true
          /* tip */
          );
        }
      }
    }

    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');

  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;

  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var res = parseFor(exp);

    if (res) {
      extend(el, res);
    } else if (true) {
      warn("Invalid v-for expression: " + exp, el.rawAttrsMap['v-for']);
    }
  }
}

function parseFor(exp) {
  var inMatch = exp.match(forAliasRE);

  if (!inMatch) {
    return;
  }

  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);

  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();

    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }

  return res;
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');

  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }

    var elseif = getAndRemoveAttr(el, 'v-else-if');

    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);

  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (true) {
    warn("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);
  }
}

function findPrevElement(children) {
  var i = children.length;

  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if ( true && children[i].text !== ' ') {
        warn("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.", children[i]);
      }

      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }

  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once = getAndRemoveAttr(el, 'v-once');

  if (once != null) {
    el.once = true;
  }
} // handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">


function processSlotContent(el) {
  var slotScope;

  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */

    if ( true && slotScope) {
      warn("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", el.rawAttrsMap['scope'], true);
    }

    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
    /* istanbul ignore if */
    if ( true && el.attrsMap['v-for']) {
      warn("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", el.rawAttrsMap['slot-scope'], true);
    }

    el.slotScope = slotScope;
  } // slot="xxx"


  var slotTarget = getBindingAttr(el, 'slot');

  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.

    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  } // 2.6 v-slot syntax


  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding) {
        if (true) {
          if (el.slotTarget || el.slotScope) {
            warn("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.parent && !maybeComponent(el.parent)) {
            warn("<template v-slot> can only appear at the root level inside " + "the receiving component", el);
          }
        }

        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding$1) {
        if (true) {
          if (!maybeComponent(el)) {
            warn("v-slot can only be used on components or <template>.", slotBinding$1);
          }

          if (el.slotScope || el.slotTarget) {
            warn("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.scopedSlots) {
            warn("To avoid scope ambiguity, the default slot should also use " + "<template> syntax when there are other named slots.", slotBinding$1);
          }
        } // add the component's children to its default slot


        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true;
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now

        el.children = []; // mark el non-plain so data gets generated

        el.plain = false;
      }
    }
  }
}

function getSlotName(binding) {
  var name = binding.name.replace(slotRE, '');

  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else if (true) {
      warn("v-slot shorthand syntax requires a slot name.", binding);
    }
  }

  return dynamicArgRE.test(name) // dynamic [name]
  ? {
    name: name.slice(1, -1),
    dynamic: true
  } // static name
  : {
    name: "\"" + name + "\"",
    dynamic: false
  };
} // handle <slot/> outlets


function processSlotOutlet(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');

    if ( true && el.key) {
      warn("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.", getRawBindingAttr(el, 'key'));
    }
  }
}

function processComponent(el) {
  var binding;

  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }

  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;

  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;

    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true; // modifiers

      modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier

      if (modifiers) {
        name = name.replace(modifierRE, '');
      }

      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        if ( true && value.trim().length === 0) {
          warn("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"");
        }

        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);

            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }

          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }

          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");

            if (!isDynamic) {
              addHandler(el, "update:" + camelize(name), syncGen, null, false, warn, list[i]);

              if (hyphenate(name) !== camelize(name)) {
                addHandler(el, "update:" + hyphenate(name), syncGen, null, false, warn, list[i]);
              }
            } else {
              // handler w/ dynamic event name
              addHandler(el, "\"update:\"+(" + name + ")", syncGen, null, false, warn, list[i], true // dynamic
              );
            }
          }
        }

        if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        addHandler(el, name, value, modifiers, false, warn, list[i], isDynamic);
      } else {
        // normal directives
        name = name.replace(dirRE, ''); // parse arg

        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;

        if (arg) {
          name = name.slice(0, -(arg.length + 1));

          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }

        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);

        if ( true && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (true) {
        var res = parseText(value, delimiters);

        if (res) {
          warn(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
        }
      }

      addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation

      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor(el) {
  var parent = el;

  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }

    parent = parent.parent;
  }

  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);

  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};

  for (var i = 0, l = attrs.length; i < l; i++) {
    if ( true && map[attrs[i].name] && !isIE && !isEdge) {
      warn('duplicate attribute: ' + attrs[i].name, attrs[i]);
    }

    map[attrs[i].name] = attrs[i].value;
  }

  return map;
} // for script (e.g. type="x/template") or style, do not decode content


function isTextTag(el) {
  return el.tag === 'script' || el.tag === 'style';
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;
/* istanbul ignore next */

function guardIESVGBug(attrs) {
  var res = [];

  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];

    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }

  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;

  while (_el) {
    if (_el.for && _el.alias === value) {
      warn("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap['v-model']);
    }

    _el = _el.parent;
  }
}
/*  */


var isStaticKey;
var isPlatformReservedTag;
var genStaticKeysCached = cached(genStaticKeys);
/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */

function optimize(root, options) {
  if (!root) {
    return;
  }

  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.

  markStatic(root); // second pass: mark static roots.

  markStaticRoots(root, false);
}

function genStaticKeys(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));
}

function markStatic(node) {
  node.static = isStatic(node);

  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }

    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic(child);

      if (!child.static) {
        node.static = false;
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic(block);

        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    } // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.


    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }

    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }

  if (node.type === 3) {
    // text
    return true;
  }

  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;

    if (node.tag !== 'template') {
      return false;
    }

    if (node.for) {
      return true;
    }
  }

  return false;
}
/*  */


var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; // KeyboardEvent.keyCode aliases

var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
}; // KeyboardEvent.key aliases

var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
}; // #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once

var genGuard = function (condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, isNative) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";

  for (var name in events) {
    var handlerCode = genHandler(events[name]);

    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }

  staticHandlers = "{" + staticHandlers.slice(0, -1) + "}";

  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + dynamicHandlers.slice(0, -1) + "])";
  } else {
    return prefix + staticHandlers;
  }
}

function genHandler(handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value;
    }

    return "function($event){" + (isFunctionInvocation ? "return " + handler.value : handler.value) + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];

    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key]; // left/right

        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = handler.modifiers;
        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
          return !modifiers[keyModifier];
        }).map(function (keyModifier) {
          return "$event." + keyModifier + "Key";
        }).join('||'));
      } else {
        keys.push(key);
      }
    }

    if (keys.length) {
      code += genKeyFilter(keys);
    } // Make sure modifiers like prevent and stop get executed after key filtering


    if (genModifierCode) {
      code += genModifierCode;
    }

    var handlerCode = isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : isFunctionInvocation ? "return " + handler.value : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return (// make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join('&&') + ")return null;"
  );
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);

  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }

  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
}
/*  */


function on(el, dir) {
  if ( true && dir.modifiers) {
    warn$1("v-on without argument does not support modifiers.");
  }

  el.wrapListeners = function (code) {
    return "_g(" + code + "," + dir.value + ")";
  };
}
/*  */


function bind(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
  };
}
/*  */


var baseDirectives = {
  on: on,
  bind: bind,
  cloak: noop
};
/*  */

var CodegenState = function CodegenState(options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;

  this.maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};

function generate(ast, options) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("NativeContentView")';
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: state.staticRenderFns
  };
}

function genElement(el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // component or element
    var code;

    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;

      if (!el.plain || el.pre && state.maybeComponent(el)) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    } // module transforms


    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }

    return code;
  }
} // hoist static sub-trees out


function genStatic(el, state) {
  el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.

  var originalPreState = state.pre;

  if (el.pre) {
    state.pre = el.pre;
  }

  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
  state.pre = originalPreState;
  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
} // v-once


function genOnce(el, state) {
  el.onceProcessed = true;

  if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;

    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }

      parent = parent.parent;
    }

    if (!key) {
       true && state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap['v-once']);
      return genElement(el, state);
    }

    return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
  } else {
    return genStatic(el, state);
  }
}

function genIf(el, state, altGen, altEmpty) {
  el.ifProcessed = true; // avoid recursion

  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}

function genIfConditions(conditions, state, altGen, altEmpty) {
  if (!conditions.length) {
    return altEmpty || '_e()';
  }

  var condition = conditions.shift();

  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
  } else {
    return "" + genTernaryExp(condition.block);
  } // v-if with v-once should generate code like (a)?_m(0):_m(1)


  function genTernaryExp(el) {
    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
  }
}

function genFor(el, state, altGen, altHelper) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if ( true && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", el.rawAttrsMap['v-for'], true
    /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion

  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
}

function genData$2(el, state) {
  var data = '{'; // directives first.
  // directives may mutate the el's other properties before they are generated.

  var dirs = genDirectives(el, state);

  if (dirs) {
    data += dirs + ',';
  } // key


  if (el.key) {
    data += "key:" + el.key + ",";
  } // ref


  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }

  if (el.refInFor) {
    data += "refInFor:true,";
  } // pre


  if (el.pre) {
    data += "pre:true,";
  } // record original tag name for components using "is" attribute


  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  } // module data generation functions


  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  } // attributes


  if (el.attrs) {
    data += "attrs:" + genProps(el.attrs) + ",";
  } // DOM props


  if (el.props) {
    data += "domProps:" + genProps(el.props) + ",";
  } // event handlers


  if (el.events) {
    data += genHandlers(el.events, false) + ",";
  }

  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true) + ",";
  } // slot target
  // only for non-scoped slots


  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + el.slotTarget + ",";
  } // scoped slots


  if (el.scopedSlots) {
    data += genScopedSlots(el, el.scopedSlots, state) + ",";
  } // component v-model


  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  } // inline-template


  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);

    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }

  data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.

  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + el.tag + "\"," + genProps(el.dynamicAttrs) + ")";
  } // v-bind data wrap


  if (el.wrapData) {
    data = el.wrapData(data);
  } // v-on data wrap


  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }

  return data;
}

function genDirectives(el, state) {
  var dirs = el.directives;

  if (!dirs) {
    return;
  }

  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;

  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];

    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }

    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:" + (dir.isDynamicArg ? dir.arg : "\"" + dir.arg + "\"") : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }

  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el, state) {
  var ast = el.children[0];

  if ( true && (el.children.length !== 1 || ast.type !== 1)) {
    state.warn('Inline-template components must have exactly one child element.', {
      start: el.start
    });
  }

  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(el, slots, state) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    ;
  }); // #9534: if a component with scoped slots is inside a conditional branch,
  // it's possible for the same component to be reused but with different
  // compiled slot content. To avoid that, we generate a unique key based on
  // the generated code of all the slot contents.

  var needsKey = !!el.if; // OR when it is inside another scoped slot or v-for (the reactivity may be
  // disconnected due to the intermediate scope variable)
  // #9438, #9506
  // TODO: this can be further optimized by properly analyzing in-scope bindings
  // and skip force updating ones that do not actually use scope variables.

  if (!needsForceUpdate) {
    var parent = el.parent;

    while (parent) {
      if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent.for) {
        needsForceUpdate = true;
        break;
      }

      if (parent.if) {
        needsKey = true;
      }

      parent = parent.parent;
    }
  }

  var generatedSlots = Object.keys(slots).map(function (key) {
    return genScopedSlot(slots[key], state);
  }).join(',');
  return "scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? ",null,false," + hash(generatedSlots) : "") + ")";
}

function hash(str) {
  var hash = 5381;
  var i = str.length;

  while (i) {
    hash = hash * 33 ^ str.charCodeAt(--i);
  }

  return hash >>> 0;
}

function containsSlotChild(el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true;
    }

    return el.children.some(containsSlotChild);
  }

  return false;
}

function genScopedSlot(el, state) {
  var isLegacySyntax = el.attrsMap['slot-scope'];

  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null");
  }

  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot);
  }

  var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
  var fn = "function(" + slotScope + "){" + "return " + (el.tag === 'template' ? el.if && isLegacySyntax ? "(" + el.if + ")?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}"; // reverse proxy v-slot without scope on this.$slots

  var reverseProxy = slotScope ? "" : ",proxy:true";
  return "{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}";
}

function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
  var children = el.children;

  if (children.length) {
    var el$1 = children[0]; // optimize single v-for

    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      var normalizationType = checkSkip ? state.maybeComponent(el$1) ? ",1" : ",0" : "";
      return "" + (altGenElement || genElement)(el$1, state) + normalizationType;
    }

    var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
    var gen = altGenNode || genNode;
    return "[" + children.map(function (c) {
      return gen(c, state);
    }).join(',') + "]" + (normalizationType$1 ? "," + normalizationType$1 : '');
  }
} // determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed


function getNormalizationType(children, maybeComponent) {
  var res = 0;

  for (var i = 0; i < children.length; i++) {
    var el = children[i];

    if (el.type !== 1) {
      continue;
    }

    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }

    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }

  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function genNode(node, state) {
  if (node.type === 1) {
    return genElement(node, state);
  } else if (node.type === 3 && node.isComment) {
    return genComment(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genComment(comment) {
  return "_e(" + JSON.stringify(comment.text) + ")";
}

function genSlot(el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {
    return {
      // slot props are camelized
      name: camelize(attr.name),
      value: attr.value,
      dynamic: attr.dynamic
    };
  })) : null;
  var bind = el.attrsMap['v-bind'];

  if ((attrs || bind) && !children) {
    res += ",null";
  }

  if (attrs) {
    res += "," + attrs;
  }

  if (bind) {
    res += (attrs ? '' : ',null') + "," + bind;
  }

  return res + ')';
} // componentName is el.component, take it as argument to shun flow's pessimistic refinement


function genComponent(componentName, el, state) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var staticProps = "";
  var dynamicProps = "";

  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);

    if (prop.dynamic) {
      dynamicProps += prop.name + "," + value + ",";
    } else {
      staticProps += "\"" + prop.name + "\":" + value + ",";
    }
  }

  staticProps = "{" + staticProps.slice(0, -1) + "}";

  if (dynamicProps) {
    return "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])";
  } else {
    return staticProps;
  }
} // #3895, #4268


function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}
/*  */
// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed


var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b'); // these unary operators should not be used as property/method names

var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)'); // strip strings in expressions

var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g; // detect problematic expressions in a template

function detectErrors(ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode(node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];

        if (value) {
          var range = node.rawAttrsMap[name];

          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", warn, range);
          } else if (name === 'v-slot' || name[0] === '#') {
            checkFunctionParameterExpression(value, name + "=\"" + value + "\"", warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", warn, range);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", warn, range);
          }
        }
      }
    }

    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent(exp, text, warn, range) {
  var stripped = exp.replace(stripStringRE, '');
  var keywordMatch = stripped.match(unaryOperatorsRE);

  if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {
    warn("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim(), range);
  }

  checkExpression(exp, text, warn, range);
}

function checkFor(node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier(ident, type, text, warn, range) {
  if (typeof ident === 'string') {
    try {
      new Function("var " + ident + "=_");
    } catch (e) {
      warn("invalid " + type + " \"" + ident + "\" in expression: " + text.trim(), range);
    }
  }
}

function checkExpression(exp, text, warn, range) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);

    if (keywordMatch) {
      warn("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim(), range);
    } else {
      warn("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
    }
  }
}

function checkFunctionParameterExpression(exp, text, warn, range) {
  try {
    new Function(exp, '');
  } catch (e) {
    warn("invalid function parameter expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
  }
}
/*  */


var range = 2;

function generateCodeFrame(source, start, end) {
  if (start === void 0) start = 0;
  if (end === void 0) end = source.length;
  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];

  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;

    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) {
          continue;
        }

        res.push("" + (j + 1) + repeat(" ", 3 - String(j + 1).length) + "|  " + lines[j]);
        var lineLength = lines[j].length;

        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat(" ", pad) + repeat("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat("^", length$1));
          }

          count += lineLength + 1;
        }
      }

      break;
    }
  }

  return res.join('\n');
}

function repeat(str, n) {
  var result = '';

  if (n > 0) {
    while (true) {
      // eslint-disable-line
      if (n & 1) {
        result += str;
      }

      n >>>= 1;

      if (n <= 0) {
        break;
      }

      str += str;
    }
  }

  return result;
}
/*  */


function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({
      err: err,
      code: code
    });
    return noop;
  }
}

function createCompileToFunctionFn(compile) {
  var cache = Object.create(null);
  return function compileToFunctions(template, options, vm) {
    options = extend({}, options);
    var warn = options.warn || warn$1;
    delete options.warn;
    /* istanbul ignore if */

    if (true) {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    } // check cache


    var key = options.delimiters ? String(options.delimiters) + template : template;

    if (cache[key]) {
      return cache[key];
    } // compile


    var compiled = compile(template, options); // check compilation errors/tips

    if (true) {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn("Error compiling template:\n\n" + e.msg + "\n\n" + generateCodeFrame(template, e.start, e.end), vm);
          });
        } else {
          warn("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
            return "- " + e;
          }).join('\n') + '\n', vm);
        }
      }

      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) {
            return tip(e.msg, vm);
          });
        } else {
          compiled.tips.forEach(function (msg) {
            return tip(msg, vm);
          });
        }
      }
    } // turn code into functions


    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors);
    }); // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use

    /* istanbul ignore if */

    if (true) {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;
          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }

    return cache[key] = res;
  };
}
/*  */


function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {
    function compile(template, options) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function (msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if ( true && options.outputSourceRange) {
          // $flow-disable-line
          var leadingSpaceLength = template.match(/^\s*/)[0].length;

          warn = function (msg, range, tip) {
            var data = {
              msg: msg
            };

            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength;
              }

              if (range.end != null) {
                data.end = range.end + leadingSpaceLength;
              }
            }

            (tip ? tips : errors).push(data);
          };
        } // merge custom modules


        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
        } // merge custom directives


        if (options.directives) {
          finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
        } // copy other options


        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;
      var compiled = baseCompile(template.trim(), finalOptions);

      if (true) {
        detectErrors(compiled.ast, warn);
      }

      compiled.errors = errors;
      compiled.tips = tips;
      return compiled;
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    };
  };
}
/*  */
// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.


var createCompiler = createCompilerCreator(function baseCompile(template, options) {
  var ast = parse(template.trim(), options);

  if (options.optimize !== false) {
    optimize(ast, options);
  }

  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
});

function transformNode$2(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');

  if ( true && staticClass) {
    var expression = parseText(staticClass, options.delimiters);

    if (expression) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
    }
  }

  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }

  var classBinding = getBindingAttr(el, 'class', false
  /* getStatic */
  );

  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData$1(el) {
  var data = '';

  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }

  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }

  return data;
}

var class_ = {
  staticKeys: ['staticClass'],
  transformNode: transformNode$2,
  genData: genData$1
};
var normalize = cached(camelize);

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  var ref = parseStaticStyle(staticStyle, options);
  var dynamic = ref.dynamic;
  var styleResult = ref.styleResult;

  if ( true && dynamic) {
    warn("style=\"" + String(staticStyle) + "\": " + 'Interpolation inside attributes has been deprecated. ' + 'Use v-bind or the colon shorthand instead.');
  }

  if (!dynamic && styleResult) {
    el.staticStyle = styleResult;
  }

  var styleBinding = getBindingAttr(el, 'style', false
  /* getStatic */
  );

  if (styleBinding) {
    el.styleBinding = styleBinding;
  } else if (dynamic) {
    el.styleBinding = styleResult;
  }
}

function genData(el) {
  var data = '';

  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }

  if (el.styleBinding) {
    data += "style:" + el.styleBinding + ",";
  }

  return data;
}

function parseStaticStyle(staticStyle, options) {
  // "width: 200px; height: 200px;" -> {width: 200, height: 200}
  // "width: 200px; height: {{y}}" -> {width: 200, height: y}
  var dynamic = false;
  var styleResult = '';

  if (staticStyle) {
    var styleList = staticStyle.trim().split(';').map(function (style) {
      var result = style.trim().split(':');

      if (result.length !== 2) {
        return;
      }

      var key = normalize(result[0].trim());
      var value = result[1].trim();
      var dynamicValue = parseText(value, options.delimiters);

      if (dynamicValue) {
        dynamic = true;
        return key + ':' + dynamicValue;
      }

      return key + ':' + JSON.stringify(value);
    }).filter(function (result) {
      return result;
    });

    if (styleList.length) {
      styleResult = '{' + styleList.join(',') + '}';
    }
  }

  return {
    dynamic: dynamic,
    styleResult: styleResult
  };
}

var style = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData
};

function preTransformNode$2(el) {
  var vfor;

  if (normalizeElementName(el.tag) === 'nativelistview') {
    vfor = getAndRemoveAttr(el, 'v-for');
    delete el.attrsMap['v-for'];

    if ( true && vfor) {
      warn$1("The v-for directive is not supported on a " + el.tag + ", " + 'Use the "for" attribute instead. For example, instead of ' + "<" + el.tag + " v-for=\"" + vfor + "\"> use <" + el.tag + " for=\"" + vfor + "\">.");
    }
  }

  var exp = getAndRemoveAttr(el, 'for') || vfor;

  if (!exp) {
    return;
  }

  var res = parseFor(exp);

  if (!res) {
    if (true) {
      warn$1("Invalid for expression: " + exp);
    }

    return;
  }

  addRawAttr(el, ':items', res.for);
  addRawAttr(el, '+alias', res.alias);

  if (res.iterator1) {
    addRawAttr(el, '+index', res.iterator1);
  }
}

var for_ = {
  preTransformNode: preTransformNode$2
};

function preTransformNode$1(el) {
  if (el.tag !== 'router-view') {
    return;
  }

  if (el.parent && el.parent.tag && normalizeElementName(el.parent.tag) === 'nativeframe') {
    addAttr(el.parent, 'hasRouterView', 'true');
  }
}

var router = {
  preTransformNode: preTransformNode$1
};

function preTransformNode(el) {
  if (el.parent && el.parent.tag === 'v-template') {
    var alias = el.parent.parent.attrsMap['+alias'] || 'item';
    var index = el.parent.parent.attrsMap['+index'] || '$index';
    el.slotScope = buildScopeString(alias, index);
  }
}

var vTemplate = {
  preTransformNode: preTransformNode
};

function buildScopeString(alias, index) {
  return "{ " + alias + ", " + index + ", $even, $odd }";
} // transforms ~test -> v-view:test


function transformNode(el) {
  var attr = Object.keys(el.attrsMap).find(function (attr) {
    return attr.startsWith('~');
  });

  if (attr) {
    var attrName = attr.substr(1);
    var ref = attrName.split('.');
    var arg = ref[0];
    var modifiers = ref.slice(1);
    modifiers = modifiers.reduce(function (mods, mod) {
      mods[mod] = true;
      return mods;
    }, {});
    getAndRemoveAttr(el, attr, true);
    addDirective(el, 'view', "v-view:" + attrName, '', arg, false, modifiers);
  }
}

var view$1 = {
  transformNode: transformNode
};
var modules = [class_, style, vTemplate, for_, router, view$1];

function model(el, dir) {
  if (el.type === 1 && isKnownView(el.tag)) {
    genViewComponentModel(el, dir.value, dir.modifiers);
  } else {
    genComponentModel(el, dir.value, dir.modifiers);
  }
}

function genViewComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;
  var ref$1 = getViewMeta(el.tag).model;
  var prop = ref$1.prop;
  var baseValueExpression = '$event';
  var valueExpression = baseValueExpression + ".object[" + JSON.stringify(prop) + "]";

  if (trim) {
    valueExpression = "(typeof " + valueExpression + " === 'string'" + "? " + valueExpression + ".trim()" + ": " + valueExpression + ")";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var assignment = genAssignmentCode(value, valueExpression);
  el.model = {
    value: "(" + value + ")",
    expression: JSON.stringify(value),
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}

var directives = {
  model: model
};
var baseOptions = {
  modules: modules,
  directives: directives,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  preserveWhitespace: false,
  staticKeys: genStaticKeys$1(modules)
};
var ref = createCompiler(baseOptions);
var compileToFunctions = ref.compileToFunctions;

function Vue(options) {
  if ( true && !(this instanceof Vue)) {
    warn$1('Vue is a constructor and should be called with the `new` keyword');
  }

  this._init(options);
}

initMixin$1(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    } // additional parameters


    var args = toArray(arguments, 1);
    args.unshift(this);

    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }

    installedPlugins.push(plugin);
    return this;
  };
}
/*  */


function initMixin(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
/*  */


function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;
  /**
   * Class inheritance
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;

    if ( true && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };

    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.

    if (Sub.options.props) {
      initProps(Sub);
    }

    if (Sub.options.computed) {
      initComputed(Sub);
    } // allow further extension/mixin/plugin usage


    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use; // create asset registers, so extended classes
    // can have their private assets too.

    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    }); // enable recursive self-lookup

    if (name) {
      Sub.options.components[name] = Sub;
    } // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.


    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options); // cache constructor

    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps(Comp) {
  var props = Comp.options.props;

  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed(Comp) {
  var computed = Comp.options.computed;

  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}
/*  */


function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if ( true && type === 'component') {
          validateComponentName(id);
        }

        if (type === 'component' && isPlainObject$1(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }

        if (type === 'directive' && typeof definition === 'function') {
          definition = {
            bind: definition,
            update: definition
          };
        }

        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}
/*  */


function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;

  for (var key in cache) {
    var cachedNode = cache[key];

    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);

      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached = cache[key];

  if (cached && (!current || cached.tag !== current.tag)) {
    cached.componentInstance.$destroy();
  }

  cache[key] = null;
  remove$2(keys, key);
}

var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: 'keep-alive',
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },
  destroyed: function destroyed() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },
  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;

    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;

      if ( // not included
      include && (!name || !matches(include, name)) || // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance; // make current key freshest

        remove$2(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key); // prune oldest entry

        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }

    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive: KeepAlive
};
/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};

  configDef.get = function () {
    return config;
  };

  if (true) {
    configDef.set = function () {
      warn$1('Do not replace the Vue.config object, set individual fields instead.');
    };
  }

  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.

  Vue.util = {
    warn: warn$1,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive
  };
  Vue.set = set$1;
  Vue.delete = del;
  Vue.nextTick = nextTick; // 2.6 explicit observable API

  Vue.observable = function (obj) {
    observe(obj);
    return obj;
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  }); // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.

  Vue.options._base = Vue;
  extend(Vue.options.components, builtInComponents);
  initUse(Vue);
  initMixin(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
}); // expose FunctionalRenderContext for ssr runtime helper installation

Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});
Vue.version = '2.6.12'; // recursively search for possible transition defined inside the component root

function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;
    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;
    var originalVisibility = el.__vOriginalVisibility = el.getAttribute('visibility') === 'none' ? '' : el.getAttribute('visibility');

    if (value && transition) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.setAttribute('visibility', originalVisibility);
      });
    } else {
      el.setAttribute('visibility', value ? originalVisibility : 'collapsed');
    }
  },
  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;
    /* istanbul ignore if */

    if (!value === !oldValue) {
      return;
    }

    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;

    if (transition) {
      vnode.data.show = true;

      if (value) {
        enter(vnode, function () {
          el.setAttribute('visibility', el.__vOriginalVisibility);
        });
      } else {
        leave(vnode, function () {
          el.setAttribute('visibility', 'collapsed');
        });
      }
    } else {
      el.setAttribute('visibility', value ? el.__vOriginalVisibility : 'collapsed');
    }
  },
  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.setAttribute('visibility', el.__vOriginalVisibility);
    }
  }
};
var view = {
  inserted: function inserted(el, ref) {
    var arg = ref.arg;
    var modifiers = ref.modifiers;
    var parent = el.parentNode.nativeView;

    if (parent) {
      if (modifiers.array) {
        parent[arg] = (parent[arg] || []).push(el.nativeView);
      } else {
        parent[arg] = el.nativeView;
      }
    }
  }
};
var platformDirectives = {
  show: show,
  view: view
};
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isUnknownElement = isUnknownElement;
Vue.$document = Vue.prototype.$document = new DocumentNode(); // Exposed for advanced uses only, not public API

Vue.__flushCallbacks__ = flushCallbacks;
Vue.compile = compileToFunctions;
Vue.registerElement = registerElement;
Object.assign(Vue.options.directives, platformDirectives);
Vue.prototype.__patch__ = patch;

Vue.prototype.$mount = function (el, hydrating) {
  var options = this.$options; // resolve template/el and convert to render function

  if (!options.render) {
    var template = options.template;

    if (template && typeof template !== 'string') {
      warn$1('invalid template option: ' + template, this);
      return this;
    }

    if (template) {
      var ref = compileToFunctions(template, {
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;
    }
  }

  return mountComponent(this, el, hydrating);
};

Vue.prototype.$start = function () {
  var self = this;
  var AppConstructor = Vue.extend(this.$options); // register NS components into Vue

  Object.values(getElementMap()).forEach(function (entry) {
    Vue.component(entry.meta.component.name, entry.meta.component);
  });
  core.Application.run({
    create: function create() {
      if (self.$el) {
        self.$destroy();
        self = new AppConstructor();
      }

      self.$mount();
      return self.$el.nativeView;
    }
  });
}; // Define a `nativeView` getter in every NS vue instance


Object.defineProperty(Vue.prototype, 'nativeView', {
  get: function get() {
    return this.$el ? this.$el.nativeView : undefined;
  }
});
var sequentialCounter$1 = 0;

function serializeModalOptions(options) {
  if (false) {}

  var allowed = ['fullscreen'];
  return Object.keys(options).filter(function (key) {
    return allowed.includes(key);
  }).map(function (key) {
    return key + ": " + options[key];
  }).concat("uid: " + ++sequentialCounter$1).join(', ');
}

function getTargetView(target) {
  if (isObject$1(target) && isDef(target.$el)) {
    return target.$el.nativeView;
  } else if (isDef(target.nativeView)) {
    return target.nativeView;
  } else if (target[VUE_ELEMENT_REF]) {
    return target;
  }
}

function _findParentModalEntry(vm) {
  if (!vm) {
    return false;
  }

  var entry = vm.$parent;

  while (entry && entry.$options.name !== 'ModalEntry') {
    entry = entry.$parent;
  }

  return entry;
}

var ModalPlugin = {
  install: function install(Vue) {
    Vue.mixin({
      created: function created() {
        var self = this;
        this.$modal = {
          close: function close(data) {
            var entry = _findParentModalEntry(self);

            if (entry) {
              entry.closeCb(data);
            }
          }
        };
      }
    });

    Vue.prototype.$showModal = function (component, options) {
      var this$1 = this;
      return new Promise(function (resolve) {
        var resolved = false;

        var closeCb = function (data) {
          if (resolved) {
            return;
          }

          resolved = true;
          resolve(data);
          modalPage.closeModal(); // emitted to show up in devtools
          // for debugging purposes

          navEntryInstance.$emit('modal:close', data);
          navEntryInstance.$destroy();
        }; // build options object with defaults


        options = Object.assign({
          target: this$1.$root
        }, options, {
          context: null,
          closeCallback: closeCb
        });
        var navEntryInstance = new Vue({
          name: 'ModalEntry',
          parent: options.target,
          methods: {
            closeCb: closeCb
          },
          render: function (h) {
            return h(component, {
              props: options.props,
              key: serializeModalOptions(options)
            });
          }
        });
        var modalPage = navEntryInstance.$mount().$el.nativeView;
        updateDevtools();
        getTargetView(options.target).showModal(modalPage, options);
      });
    };
  }
};
var sequentialCounter = 0;

function serializeNavigationOptions(options) {
  if (false) {}

  var allowed = ['backstackVisible', 'clearHistory'];
  return Object.keys(options).filter(function (key) {
    return allowed.includes(key);
  }).map(function (key) {
    return key + ": " + options[key];
  }).concat("uid: " + ++sequentialCounter).join(', ');
}

function getFrameInstance(frame) {
  // get the frame that we need to navigate
  // this can be a frame id (String)
  // a Vue ref to a frame
  // a Frame ViewNode
  // or a Frame instance
  if (isObject$1(frame) && isDef(frame.$el)) {
    frame = frame.$el.nativeView;
  } else if (isPrimitive(frame)) {
    frame = __webpack_require__("@nativescript/core").Frame.getFrameById(frame);
  } else if (isDef(frame.nativeView)) {
    frame = frame.nativeView;
  } // finally get the component instance for this frame


  return getFrame(frame.id);
}

function findParentFrame(vm) {
  if (!vm) {
    return false;
  }

  var entry = vm.$parent;

  while (entry && entry.$options.name !== 'Frame') {
    entry = entry.$parent;
  }

  return entry;
}

var NavigatorPlugin = {
  install: function install(Vue) {
    Vue.navigateBack = Vue.prototype.$navigateBack = function (options, backstackEntry) {
      if (backstackEntry === void 0) backstackEntry = null;
      var parentFrame = findParentFrame(this);
      var defaultOptions = {
        frame: parentFrame ? parentFrame : 'default'
      };
      options = Object.assign({}, defaultOptions, options);
      var frame = getFrameInstance(options.frame);
      frame.back(backstackEntry);
    };

    Vue.navigateTo = Vue.prototype.$navigateTo = function (component, options) {
      var defaultOptions = {
        frame: 'default'
      }; // build options object with defaults

      options = Object.assign({}, defaultOptions, options);
      return new Promise(function (resolve) {
        var frame = getFrameInstance(options.frame);
        var key = serializeNavigationOptions(options);
        var navEntryInstance = new Vue({
          abstract: true,
          functional: true,
          name: 'NavigationEntry',
          parent: frame,
          frame: frame,
          render: function (h) {
            return h(component, {
              props: options.props,
              key: key
            });
          }
        });
        var page = navEntryInstance.$mount().$el.nativeView;
        updateDevtools();
        var resolveOnEvent = options.resolveOnEvent; // ensure we dont resolve twice event though this should never happen!

        var resolved = false;

        var handler = function (args) {
          if (args.isBackNavigation) {
            page.off('navigatedFrom', handler);
            navEntryInstance.$destroy();
          }
        };

        page.on('navigatedFrom', handler);

        if (resolveOnEvent) {
          var resolveHandler = function (args) {
            if (!resolved) {
              resolved = true;
              resolve(page);
            }

            page.off(resolveOnEvent, resolveHandler);
          };

          page.on(resolveOnEvent, resolveHandler);
        } // ensure that the navEntryInstance vue instance is destroyed when the
        // page is disposed (clearHistory: true for example)


        var dispose = page.disposeNativeView;

        page.disposeNativeView = function () {
          var args = [],
              len = arguments.length;

          while (len--) args[len] = arguments[len];

          navEntryInstance.$destroy();
          dispose.call(page, args);
        };

        frame.navigate(Object.assign({}, options, {
          create: function () {
            return page;
          }
        }));

        if (!resolveOnEvent) {
          resolved = true;
          resolve(page);
        }
      });
    };
  }
};
Vue.config.silent = true;
Vue.config.suppressRenderLogs = false;
setVue(Vue);
Vue.use(ModalPlugin);
Vue.use(NavigatorPlugin);

global.__onLiveSyncCore = function () {
  var frame = __webpack_require__("@nativescript/core").Frame.topmost();

  if (frame) {
    if (frame.currentPage && frame.currentPage.modal) {
      frame.currentPage.modal.closeModal();
    }

    if (frame.currentPage) {
      frame.currentPage.addCssFile(__webpack_require__("@nativescript/core").Application.getCssFileName());
    }
  }
};

module.exports = Vue;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/vue-hot-reload-api/dist/index.js":
/***/ (function(module, exports) {

var Vue; // late bind

var version;
var map = Object.create(null);

if (typeof window !== 'undefined') {
  window.__VUE_HOT_MAP__ = map;
}

var installed = false;
var isBrowserify = false;
var initHookName = 'beforeCreate';

exports.install = function (vue, browserify) {
  if (installed) {
    return;
  }

  installed = true;
  Vue = vue.__esModule ? vue.default : vue;
  version = Vue.version.split('.').map(Number);
  isBrowserify = browserify; // compat with < 2.0.0-alpha.7

  if (Vue.config._lifecycleHooks.indexOf('init') > -1) {
    initHookName = 'init';
  }

  exports.compatible = version[0] >= 2;

  if (!exports.compatible) {
    console.warn('[HMR] You are using a version of vue-hot-reload-api that is ' + 'only compatible with Vue.js core ^2.0.0.');
    return;
  }
};
/**
 * Create a record for a hot module, which keeps track of its constructor
 * and instances
 *
 * @param {String} id
 * @param {Object} options
 */


exports.createRecord = function (id, options) {
  if (map[id]) {
    return;
  }

  var Ctor = null;

  if (typeof options === 'function') {
    Ctor = options;
    options = Ctor.options;
  }

  makeOptionsHot(id, options);
  map[id] = {
    Ctor: Ctor,
    options: options,
    instances: []
  };
};
/**
 * Check if module is recorded
 *
 * @param {String} id
 */


exports.isRecorded = function (id) {
  return typeof map[id] !== 'undefined';
};
/**
 * Make a Component options object hot.
 *
 * @param {String} id
 * @param {Object} options
 */


function makeOptionsHot(id, options) {
  if (options.functional) {
    var render = options.render;

    options.render = function (h, ctx) {
      var instances = map[id].instances;

      if (ctx && instances.indexOf(ctx.parent) < 0) {
        instances.push(ctx.parent);
      }

      return render(h, ctx);
    };
  } else {
    injectHook(options, initHookName, function () {
      var record = map[id];

      if (!record.Ctor) {
        record.Ctor = this.constructor;
      }

      record.instances.push(this);
    });
    injectHook(options, 'beforeDestroy', function () {
      var instances = map[id].instances;
      instances.splice(instances.indexOf(this), 1);
    });
  }
}
/**
 * Inject a hook to a hot reloadable component so that
 * we can keep track of it.
 *
 * @param {Object} options
 * @param {String} name
 * @param {Function} hook
 */


function injectHook(options, name, hook) {
  var existing = options[name];
  options[name] = existing ? Array.isArray(existing) ? existing.concat(hook) : [existing, hook] : [hook];
}

function tryWrap(fn) {
  return function (id, arg) {
    try {
      fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn('Something went wrong during Vue component hot-reload. Full reload required.');
    }
  };
}

function updateOptions(oldOptions, newOptions) {
  for (var key in oldOptions) {
    if (!(key in newOptions)) {
      delete oldOptions[key];
    }
  }

  for (var key$1 in newOptions) {
    oldOptions[key$1] = newOptions[key$1];
  }
}

exports.rerender = tryWrap(function (id, options) {
  var record = map[id];

  if (!options) {
    record.instances.slice().forEach(function (instance) {
      instance.$forceUpdate();
    });
    return;
  }

  if (typeof options === 'function') {
    options = options.options;
  }

  if (record.Ctor) {
    record.Ctor.options.render = options.render;
    record.Ctor.options.staticRenderFns = options.staticRenderFns;
    record.instances.slice().forEach(function (instance) {
      instance.$options.render = options.render;
      instance.$options.staticRenderFns = options.staticRenderFns; // reset static trees
      // pre 2.5, all static trees are cached together on the instance

      if (instance._staticTrees) {
        instance._staticTrees = [];
      } // 2.5.0


      if (Array.isArray(record.Ctor.options.cached)) {
        record.Ctor.options.cached = [];
      } // 2.5.3


      if (Array.isArray(instance.$options.cached)) {
        instance.$options.cached = [];
      } // post 2.5.4: v-once trees are cached on instance._staticTrees.
      // Pure static trees are cached on the staticRenderFns array
      // (both already reset above)
      // 2.6: temporarily mark rendered scoped slots as unstable so that
      // child components can be forced to update


      var restore = patchScopedSlots(instance);
      instance.$forceUpdate();
      instance.$nextTick(restore);
    });
  } else {
    // functional or no instance created yet
    record.options.render = options.render;
    record.options.staticRenderFns = options.staticRenderFns; // handle functional component re-render

    if (record.options.functional) {
      // rerender with full options
      if (Object.keys(options).length > 2) {
        updateOptions(record.options, options);
      } else {
        // template-only rerender.
        // need to inject the style injection code for CSS modules
        // to work properly.
        var injectStyles = record.options._injectStyles;

        if (injectStyles) {
          var render = options.render;

          record.options.render = function (h, ctx) {
            injectStyles.call(ctx);
            return render(h, ctx);
          };
        }
      }

      record.options._Ctor = null; // 2.5.3

      if (Array.isArray(record.options.cached)) {
        record.options.cached = [];
      }

      record.instances.slice().forEach(function (instance) {
        instance.$forceUpdate();
      });
    }
  }
});
exports.reload = tryWrap(function (id, options) {
  var record = map[id];

  if (options) {
    if (typeof options === 'function') {
      options = options.options;
    }

    makeOptionsHot(id, options);

    if (record.Ctor) {
      if (version[1] < 2) {
        // preserve pre 2.2 behavior for global mixin handling
        record.Ctor.extendOptions = options;
      }

      var newCtor = record.Ctor.super.extend(options); // prevent record.options._Ctor from being overwritten accidentally

      newCtor.options._Ctor = record.options._Ctor;
      record.Ctor.options = newCtor.options;
      record.Ctor.cid = newCtor.cid;
      record.Ctor.prototype = newCtor.prototype;

      if (newCtor.release) {
        // temporary global mixin strategy used in < 2.0.0-alpha.6
        newCtor.release();
      }
    } else {
      updateOptions(record.options, options);
    }
  }

  record.instances.slice().forEach(function (instance) {
    if (instance.$vnode && instance.$vnode.context) {
      instance.$vnode.context.$forceUpdate();
    } else {
      console.warn('Root or manually mounted instance modified. Full reload required.');
    }
  });
}); // 2.6 optimizes template-compiled scoped slots and skips updates if child
// only uses scoped slots. We need to patch the scoped slots resolving helper
// to temporarily mark all scoped slots as unstable in order to force child
// updates.

function patchScopedSlots(instance) {
  if (!instance._u) {
    return;
  } // https://github.com/vuejs/vue/blob/dev/src/core/instance/render-helpers/resolve-scoped-slots.js


  var original = instance._u;

  instance._u = function (slots) {
    try {
      // 2.6.4 ~ 2.6.6
      return original(slots, true);
    } catch (e) {
      // 2.5 / >= 2.6.7
      return original(slots, null, true);
    }
  };

  return function () {
    instance._u = original;
  };
}

/***/ }),

/***/ "../node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BuYXRpdmVzY3JpcHQvd2VicGFjay9oZWxwZXJzL2hvdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BuYXRpdmVzY3JpcHQvd2VicGFjay9oZWxwZXJzL2xvYWQtYXBwbGljYXRpb24tY3NzLXJlZ3VsYXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AbmF0aXZlc2NyaXB0L3dlYnBhY2svaGVscGVycy9sb2FkLWFwcGxpY2F0aW9uLWNzcy5qcyIsIndlYnBhY2s6Ly8vaG1yLXVwZGF0ZS50cyIsIndlYnBhY2s6Ly8vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9uYXRpdmVzY3JpcHQtdnVlL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGkvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMiXSwibmFtZXMiOlsiaG1yUHJlZml4IiwibG9nIiwiaW5mbyIsIm1lc3NhZ2UiLCJjb25zb2xlIiwid2FybiIsImVycm9yIiwicmVmcmVzaCIsImhvdE9wdGlvbnMiLCJpZ25vcmVVbmFjY2VwdGVkIiwiaWdub3JlRGVjbGluZWQiLCJpZ25vcmVFcnJvcmVkIiwib25VbmFjY2VwdGVkIiwiZGF0YSIsImNoYWluIiwiY29uY2F0IiwibGFzdCIsImxlbmd0aCIsInBvcCIsImZvckVhY2giLCJtb2QiLCJvbkRlY2xpbmVkIiwib25FcnJvcmVkIiwibW9kdWxlSWQiLCJ0eXBlIiwibmV4dEhhc2giLCJjdXJyZW50SGFzaCIsInVwVG9EYXRlIiwiaW5kZXhPZiIsIl9fd2VicGFja19oYXNoX18iLCJyZXN1bHQiLCJtb2R1bGVzIiwiYXBwbGllZE1vZHVsZXMiLCJ1bmFjY2VwdGVkIiwiZmlsdGVyIiwibnVtYmVySWRzIiwiZXZlcnkiLCJjaGVjayIsIm9wdGlvbnMiLCJtb2R1bGUiLCJob3QiLCJ0aGVuIiwiYXBwbHkiLCJuZXh0Q2hlY2siLCJjYXRjaCIsImVyciIsInN0YXR1cyIsInN0YWNrIiwidXBkYXRlIiwibGF0ZXN0SGFzaCIsImdldE5leHRIYXNoIiwiaGFzaCIsImdldEZpbGVDb250ZW50IiwiZmlsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVhZFRleHQiLCJob3RVcGRhdGVDb250ZW50IiwibWFuaWZlc3QiLCJKU09OIiwicGFyc2UiLCJuZXdIYXNoIiwiaCIsInJlamVjdCIsImV4cG9ydHMiLCJjaGVja1N0YXRlIiwiaW5pdGlhbEhhc2giLCJsb2FkQ3NzIiwicmVxdWlyZSIsImFwcENzc0NvbnRleHQiLCJnbG9iYWwiLCJyZWdpc3RlcldlYnBhY2tNb2R1bGVzIiwibG9hZE1vZHVsZUZuIiwibnNDb3JlIiwiQXBwbGljYXRpb24iLCJsb2FkQXBwQ3NzIiwidXNlU291cmNlTWFwIiwibGlzdCIsInRvU3RyaW5nIiwibWFwIiwiaXRlbSIsImNvbnRlbnQiLCJjc3NXaXRoTWFwcGluZ1RvU3RyaW5nIiwiam9pbiIsImkiLCJtZWRpYVF1ZXJ5IiwiZGVkdXBlIiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsImlkIiwiX2kiLCJwdXNoIiwiY3NzTWFwcGluZyIsImJ0b2EiLCJzb3VyY2VNYXBwaW5nIiwidG9Db21tZW50Iiwic291cmNlVVJMcyIsInNvdXJjZXMiLCJzb3VyY2UiLCJzb3VyY2VSb290Iiwic291cmNlTWFwIiwiYmFzZTY0IiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJzdHJpbmdpZnkiLCJwcm9jZXNzIiwiZW52IiwiY29yZSIsImVtcHR5T2JqZWN0IiwiT2JqZWN0IiwiZnJlZXplIiwiaXNVbmRlZiIsInYiLCJ1bmRlZmluZWQiLCJpc0RlZiIsImlzVHJ1ZSIsImlzRmFsc2UiLCJpc1ByaW1pdGl2ZSIsInZhbHVlIiwiaXNPYmplY3QkMSIsIm9iaiIsIl90b1N0cmluZyIsInByb3RvdHlwZSIsInRvUmF3VHlwZSIsImNhbGwiLCJzbGljZSIsImlzUGxhaW5PYmplY3QkMSIsImlzUmVnRXhwIiwiaXNWYWxpZEFycmF5SW5kZXgiLCJ2YWwiLCJuIiwicGFyc2VGbG9hdCIsIlN0cmluZyIsIk1hdGgiLCJmbG9vciIsImlzRmluaXRlIiwiaXNQcm9taXNlIiwiQXJyYXkiLCJpc0FycmF5IiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwiY3JlYXRlIiwic3BsaXQiLCJ0b0xvd2VyQ2FzZSIsImlzQnVpbHRJblRhZyIsImlzUmVzZXJ2ZWRBdHRyaWJ1dGUiLCJyZW1vdmUkMiIsImFyciIsImluZGV4Iiwic3BsaWNlIiwiaGFzT3duUHJvcGVydHkiLCJoYXNPd24iLCJrZXkiLCJjYWNoZWQiLCJmbiIsImNhY2hlIiwiY2FjaGVkRm4iLCJoaXQiLCJjYW1lbGl6ZVJFIiwiY2FtZWxpemUiLCJyZXBsYWNlIiwiXyIsImMiLCJ0b1VwcGVyQ2FzZSIsImNhcGl0YWxpemUiLCJjaGFyQXQiLCJoeXBoZW5hdGVSRSIsImh5cGhlbmF0ZSIsInBvbHlmaWxsQmluZCIsImN0eCIsImJvdW5kRm4iLCJhIiwibCIsImFyZ3VtZW50cyIsIl9sZW5ndGgiLCJuYXRpdmVCaW5kIiwiYmluZCIsImJpbmQkMSIsIkZ1bmN0aW9uIiwidG9BcnJheSIsInN0YXJ0IiwicmV0IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0JDEiLCJyZXMiLCJub29wIiwiYiIsIm5vIiwiaWRlbnRpdHkiLCJnZW5TdGF0aWNLZXlzJDEiLCJyZWR1Y2UiLCJrZXlzIiwibSIsInN0YXRpY0tleXMiLCJsb29zZUVxdWFsIiwiaXNPYmplY3RBIiwiaXNPYmplY3RCIiwiaXNBcnJheUEiLCJpc0FycmF5QiIsImUiLCJEYXRlIiwiZ2V0VGltZSIsImtleXNBIiwia2V5c0IiLCJsb29zZUluZGV4T2YiLCJvbmNlIiwiY2FsbGVkIiwidW5pY29kZVJlZ0V4cCIsImlzUmVzZXJ2ZWQiLCJjaGFyQ29kZUF0IiwiZGVmIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJiYWlsUkUiLCJSZWdFeHAiLCJwYXJzZVBhdGgiLCJwYXRoIiwidGVzdCIsInNlZ21lbnRzIiwiaGFzUHJvdG8iLCJpbkJyb3dzZXIiLCJ3aW5kb3ciLCJpbldlZXgiLCJXWEVudmlyb25tZW50IiwicGxhdGZvcm0iLCJ3ZWV4UGxhdGZvcm0iLCJVQSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzSUUiLCJpc0VkZ2UiLCJpc0lPUyIsIm1hdGNoIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJpc05hdGl2ZSIsIkN0b3IiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsIl9TZXQiLCJTZXQiLCJzZXQiLCJoYXMiLCJhZGQiLCJjbGVhciIsIlNTUl9BVFRSIiwiQVNTRVRfVFlQRVMiLCJMSUZFQ1lDTEVfSE9PS1MiLCJjb25maWciLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJzaWxlbnQiLCJwcm9kdWN0aW9uVGlwIiwiZGV2dG9vbHMiLCJwZXJmb3JtYW5jZSIsImVycm9ySGFuZGxlciIsIndhcm5IYW5kbGVyIiwiaWdub3JlZEVsZW1lbnRzIiwia2V5Q29kZXMiLCJpc1Jlc2VydmVkVGFnIiwiaXNSZXNlcnZlZEF0dHIiLCJpc1Vua25vd25FbGVtZW50IiwiZ2V0VGFnTmFtZXNwYWNlIiwicGFyc2VQbGF0Zm9ybVRhZ05hbWUiLCJtdXN0VXNlUHJvcCIsImFzeW5jIiwiX2xpZmVjeWNsZUhvb2tzIiwid2FybiQxIiwidGlwIiwiZ2VuZXJhdGVDb21wb25lbnRUcmFjZSIsImZvcm1hdENvbXBvbmVudE5hbWUiLCJoYXNDb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJ0cmFjZSIsImluY2x1ZGVGaWxlIiwiJHJvb3QiLCJjaWQiLCJfaXNWdWUiLCIkb3B0aW9ucyIsImNvbnN0cnVjdG9yIiwibmFtZSIsIl9jb21wb25lbnRUYWciLCJfX2ZpbGUiLCJyZXBlYXQkMSIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwidWlkJDIiLCJEZXAiLCJzdWJzIiwiYWRkU3ViIiwic3ViIiwicmVtb3ZlU3ViIiwiZGVwZW5kIiwidGFyZ2V0IiwiYWRkRGVwIiwibm90aWZ5Iiwic29ydCIsInRhcmdldFN0YWNrIiwicHVzaFRhcmdldCIsInBvcFRhcmdldCIsIlZOb2RlIiwidGFnIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZuQ29udGV4dCIsImZuT3B0aW9ucyIsImZuU2NvcGVJZCIsImNvbXBvbmVudEluc3RhbmNlIiwicGFyZW50IiwicmF3IiwiaXNTdGF0aWMiLCJpc1Jvb3RJbnNlcnQiLCJpc0NvbW1lbnQiLCJpc0Nsb25lZCIsImlzT25jZSIsImFzeW5jTWV0YSIsImlzQXN5bmNQbGFjZWhvbGRlciIsInByb3RvdHlwZUFjY2Vzc29ycyQyIiwiY2hpbGQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY3JlYXRlRW1wdHlWTm9kZSIsIm5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwidm5vZGUiLCJjbG9uZWQiLCJhcnJheVByb3RvIiwiYXJyYXlNZXRob2RzIiwibWV0aG9kc1RvUGF0Y2giLCJtZXRob2QiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJhcmdzIiwibGVuIiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsImFycmF5S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJzaG91bGRPYnNlcnZlIiwidG9nZ2xlT2JzZXJ2aW5nIiwiT2JzZXJ2ZXIiLCJ2bUNvdW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUiLCJpdGVtcyIsIm9ic2VydmUiLCJzcmMiLCJfX3Byb3RvX18iLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwic2hhbGxvdyIsInByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0dGVyIiwic2V0dGVyIiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsInNldCQxIiwibWF4IiwiZGVsIiwic3RyYXRzIiwiZWwiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJmcm9tIiwidG9WYWwiLCJmcm9tVmFsIiwibWVyZ2VEYXRhT3JGbiIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayQxIiwiZGVkdXBlSG9va3MiLCJob29rcyIsImhvb2siLCJtZXJnZUFzc2V0cyIsImFzc2VydE9iamVjdFR5cGUiLCJrZXkkMSIsInByb3BzIiwibWV0aG9kcyIsImluamVjdCIsImNvbXB1dGVkIiwicHJvdmlkZSIsImNoZWNrQ29tcG9uZW50cyIsImNvbXBvbmVudHMiLCJ2YWxpZGF0ZUNvbXBvbmVudE5hbWUiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZUluamVjdCIsIm5vcm1hbGl6ZWQiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJkaXJzIiwiZGlyZWN0aXZlcyIsIm1lcmdlT3B0aW9ucyIsIl9iYXNlIiwiZXh0ZW5kcyIsIm1peGlucyIsIm1lcmdlRmllbGQiLCJzdHJhdCIsInJlc29sdmVBc3NldCIsIndhcm5NaXNzaW5nIiwiYXNzZXRzIiwiY2FtZWxpemVkSWQiLCJQYXNjYWxDYXNlSWQiLCJ2YWxpZGF0ZVByb3AiLCJwcm9wT3B0aW9ucyIsInByb3AiLCJhYnNlbnQiLCJib29sZWFuSW5kZXgiLCJnZXRUeXBlSW5kZXgiLCJCb29sZWFuIiwic3RyaW5nSW5kZXgiLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZE9ic2VydmUiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJnZXRJbnZhbGlkVHlwZU1lc3NhZ2UiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwidCIsImlzU2FtZVR5cGUiLCJyZWNlaXZlZFR5cGUiLCJleHBlY3RlZFZhbHVlIiwic3R5bGVWYWx1ZSIsInJlY2VpdmVkVmFsdWUiLCJpc0V4cGxpY2FibGUiLCJpc0Jvb2xlYW4iLCJOdW1iZXIiLCJleHBsaWNpdFR5cGVzIiwic29tZSIsImVsZW0iLCJoYW5kbGVFcnJvciIsImN1ciIsImVycm9yQ2FwdHVyZWQiLCJjYXB0dXJlIiwiZ2xvYmFsSGFuZGxlRXJyb3IiLCJpbnZva2VXaXRoRXJyb3JIYW5kbGluZyIsImhhbmRsZXIiLCJfaGFuZGxlZCIsImxvZ0Vycm9yIiwiY2FsbGJhY2tzIiwicGVuZGluZyIsImZsdXNoQ2FsbGJhY2tzIiwiY29waWVzIiwidGltZXJGdW5jIiwicCIsInNldFRpbWVvdXQiLCJNdXRhdGlvbk9ic2VydmVyIiwiY291bnRlciIsIm9ic2VydmVyIiwidGV4dE5vZGUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwiY2hhcmFjdGVyRGF0YSIsInNldEltbWVkaWF0ZSIsIm5leHRUaWNrIiwiY2IiLCJfcmVzb2x2ZSIsInJlZiQxIiwicmVnaXN0ZXJSZWYiLCJvbGRWbm9kZSIsInJlZiIsImRlc3Ryb3kiLCJpc1JlbW92YWwiLCJyZWZzIiwiJHJlZnMiLCJyZWZJbkZvciIsInNlZW5PYmplY3RzIiwidHJhdmVyc2UiLCJfdHJhdmVyc2UiLCJzZWVuIiwiaXNBIiwiaXNGcm96ZW4iLCJkZXBJZCIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJpbmRleCQxIiwicmVzZXRTY2hlZHVsZXJTdGF0ZSIsImdldE5vdyIsIm5vdyIsImNyZWF0ZUV2ZW50IiwidGltZVN0YW1wIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJiZWZvcmUiLCJydW4iLCJ1c2VyIiwiZXhwcmVzc2lvbiIsImFjdGl2YXRlZFF1ZXVlIiwidXBkYXRlZFF1ZXVlIiwiY2FsbEFjdGl2YXRlZEhvb2tzIiwiY2FsbFVwZGF0ZWRIb29rcyIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJlbWl0IiwiX3dhdGNoZXIiLCJfaXNNb3VudGVkIiwiX2lzRGVzdHJveWVkIiwiY2FsbEhvb2skMSIsInF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50IiwiX2luYWN0aXZlIiwiYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsInF1ZXVlV2F0Y2hlciIsInVpZCQxIiwiV2F0Y2hlciIsImV4cE9yRm4iLCJpc1JlbmRlcldhdGNoZXIiLCJfd2F0Y2hlcnMiLCJkZWVwIiwibGF6eSIsInN5bmMiLCJhY3RpdmUiLCJkaXJ0eSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsImV2YWx1YXRlIiwidGVhcmRvd24iLCJfaXNCZWluZ0Rlc3Ryb3llZCIsIm1hcmsiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJub3JtYWxpemVFdmVudCIsInBhc3NpdmUiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwiYXJndW1lbnRzJDEiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbiIsIm9sZE9uIiwicmVtb3ZlIiwiY3JlYXRlT25jZUhhbmRsZXIiLCJvbGQiLCJldmVudCIsInBhcmFtcyIsIm1lcmdlVk5vZGVIb29rIiwiaG9va0tleSIsIm9sZEhvb2siLCJ3cmFwcGVkSG9vayIsIm1lcmdlZCIsImV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEiLCJhdHRycyIsImFsdEtleSIsImtleUluTG93ZXJDYXNlIiwiY2hlY2tQcm9wIiwicHJlc2VydmUiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsImlzVGV4dE5vZGUiLCJuZXN0ZWRJbmRleCIsImxhc3RJbmRleCIsInNoaWZ0IiwiX2lzVkxpc3QiLCJpbml0UHJveHkiLCJhbGxvd2VkR2xvYmFscyIsIndhcm5Ob25QcmVzZW50Iiwid2FyblJlc2VydmVkUHJlZml4IiwiaGFzUHJveHkiLCJQcm94eSIsImlzQnVpbHRJbk1vZGlmaWVyIiwiaGFzSGFuZGxlciIsImlzQWxsb3dlZCIsIiRkYXRhIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsInNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiIsInByb3h5Iiwic291cmNlS2V5IiwicHJveHlHZXR0ZXIiLCJwcm94eVNldHRlciIsImluaXRTdGF0ZSIsImluaXRQcm9wcyQxIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsIl9kYXRhIiwiaW5pdENvbXB1dGVkJDEiLCJpbml0V2F0Y2giLCJwcm9wc09wdGlvbnMiLCJfcHJvcEtleXMiLCJpc1Jvb3QiLCJsb29wIiwiaHlwaGVuYXRlZEtleSIsImlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCIsImdldERhdGEiLCJjb21wdXRlZFdhdGNoZXJPcHRpb25zIiwid2F0Y2hlcnMiLCJfY29tcHV0ZWRXYXRjaGVycyIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlR2V0dGVySW52b2tlciIsImNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlV2F0Y2hlciIsIiR3YXRjaCIsInN0YXRlTWl4aW4iLCJWdWUiLCJkYXRhRGVmIiwicHJvcHNEZWYiLCIkc2V0IiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsInVud2F0Y2hGbiIsImluaXRQcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJyZXNvbHZlSW5qZWN0IiwicHJvdmlkZUtleSIsInByb3ZpZGVEZWZhdWx0IiwidWlkIiwiaW5pdE1peGluJDEiLCJfaW5pdCIsIl91aWQiLCJfaXNDb21wb25lbnQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwiX3NlbGYiLCJpbml0TGlmZWN5Y2xlIiwiaW5pdEV2ZW50cyIsImluaXRSZW5kZXIiLCJfbmFtZSIsIiRtb3VudCIsInBhcmVudFZub2RlIiwiX3BhcmVudFZub2RlIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwiX3BhcmVudExpc3RlbmVycyIsImxpc3RlbmVycyIsIl9yZW5kZXJDaGlsZHJlbiIsInN0YXRpY1JlbmRlckZucyIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsInNsb3QiLCJuYW1lJDEiLCJpc1doaXRlc3BhY2UiLCJub3JtYWxpemVTY29wZWRTbG90cyIsIm5vcm1hbFNsb3RzIiwicHJldlNsb3RzIiwiaGFzTm9ybWFsU2xvdHMiLCJpc1N0YWJsZSIsIiRzdGFibGUiLCIka2V5IiwiX25vcm1hbGl6ZWQiLCIkaGFzTm9ybWFsIiwibm9ybWFsaXplU2NvcGVkU2xvdCIsImtleSQyIiwicHJveHlOb3JtYWxTbG90IiwicmVuZGVyTGlzdCIsIml0ZXJhdG9yIiwibmV4dCIsImRvbmUiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwiJHNjb3BlZFNsb3RzIiwibm9kZXMiLCIkc2xvdHMiLCIkY3JlYXRlRWxlbWVudCIsInJlc29sdmVGaWx0ZXIiLCJpc0tleU5vdE1hdGNoIiwiZXhwZWN0IiwiYWN0dWFsIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5LZXlDb2RlIiwiZXZlbnRLZXlOYW1lIiwiYnVpbHRJbktleU5hbWUiLCJtYXBwZWRLZXlDb2RlIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCJjYW1lbGl6ZWRLZXkiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwibWFya1N0YXRpYyQxIiwibWFya09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImJpbmRPYmplY3RMaXN0ZW5lcnMiLCJleGlzdGluZyIsIm91cnMiLCJyZXNvbHZlU2NvcGVkU2xvdHMiLCJoYXNEeW5hbWljS2V5cyIsImNvbnRlbnRIYXNoS2V5IiwiYmluZER5bmFtaWNLZXlzIiwiYmFzZU9iaiIsInZhbHVlcyIsInByZXBlbmRNb2RpZmllciIsInN5bWJvbCIsImluc3RhbGxSZW5kZXJIZWxwZXJzIiwiX28iLCJfbiIsIl9zIiwiX2wiLCJfdCIsIl9xIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsIl9kIiwiX3AiLCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCIsInRoaXMkMSIsImNvbnRleHRWbSIsIl9vcmlnaW5hbCIsImlzQ29tcGlsZWQiLCJfY29tcGlsZWQiLCJuZWVkTm9ybWFsaXphdGlvbiIsImluamVjdGlvbnMiLCJzY29wZWRTbG90cyIsIl9zY29wZUlkIiwiX2MiLCJkIiwiY3JlYXRlRWxlbWVudCQxIiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJyZW5kZXJDb250ZXh0IiwiY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCIsInZub2RlcyIsImNsb25lIiwiZGV2dG9vbHNNZXRhIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsImluaXQiLCJoeWRyYXRpbmciLCJrZWVwQWxpdmUiLCJtb3VudGVkTm9kZSIsInByZXBhdGNoIiwiY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSIsImFjdGl2ZUluc3RhbmNlIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJpbnNlcnQiLCIkZGVzdHJveSIsImRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsImJhc2VDdG9yIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50IiwiY3JlYXRlQXN5bmNQbGFjZWhvbGRlciIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJmdW5jdGlvbmFsIiwibmF0aXZlT24iLCJhYnN0cmFjdCIsImluc3RhbGxDb21wb25lbnRIb29rcyIsImlubGluZVRlbXBsYXRlIiwidG9NZXJnZSIsIl9tZXJnZWQiLCJtZXJnZUhvb2siLCJmMSIsImYyIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsIiR2bm9kZSIsInByZSIsImFwcGx5TlMiLCJyZWdpc3RlckRlZXBCaW5kaW5ncyIsImZvcmNlIiwic3R5bGUiLCJjbGFzcyIsIl92bm9kZSIsInBhcmVudERhdGEiLCJjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UiLCJyZW5kZXJNaXhpbiIsIiRuZXh0VGljayIsIl9yZW5kZXIiLCJyZW5kZXJFcnJvciIsImUkMSIsImVuc3VyZUN0b3IiLCJjb21wIiwiYmFzZSIsIl9fZXNNb2R1bGUiLCJ0b1N0cmluZ1RhZyIsImZhY3RvcnkiLCJlcnJvckNvbXAiLCJyZXNvbHZlZCIsIm93bmVyIiwib3duZXJzIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwidGltZXJMb2FkaW5nIiwidGltZXJUaW1lb3V0IiwiJG9uIiwiZm9yY2VSZW5kZXIiLCJyZW5kZXJDb21wbGV0ZWQiLCIkZm9yY2VVcGRhdGUiLCJjbGVhclRpbWVvdXQiLCJyZWFzb24iLCJjb21wb25lbnQiLCJkZWxheSIsInRpbWVvdXQiLCJnZXRGaXJzdENvbXBvbmVudENoaWxkIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJ1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMiLCJ0YXJnZXQkMSIsImFkZCQxIiwicmVtb3ZlJDEiLCIkb2ZmIiwiY3JlYXRlT25jZUhhbmRsZXIkMSIsIl90YXJnZXQiLCJvbmNlSGFuZGxlciIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiaG9va1JFIiwiJG9uY2UiLCJpJDEiLCJjYnMiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50Iiwic2V0QWN0aXZlSW5zdGFuY2UiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCIkY2hpbGRyZW4iLCJfZGlyZWN0SW5hY3RpdmUiLCJsaWZlY3ljbGVNaXhpbiIsIl91cGRhdGUiLCJwcmV2RWwiLCIkZWwiLCJwcmV2Vm5vZGUiLCJyZXN0b3JlQWN0aXZlSW5zdGFuY2UiLCJfX3BhdGNoX18iLCJfX3Z1ZV9fIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsInJlbmRlckNoaWxkcmVuIiwibmV3U2NvcGVkU2xvdHMiLCJvbGRTY29wZWRTbG90cyIsImhhc0R5bmFtaWNTY29wZWRTbG90IiwibmVlZHNGb3JjZVVwZGF0ZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJkaXJlY3QiLCJqIiwiaXNUZXh0SW5wdXRUeXBlIiwiZW1wdHlOb2RlIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJub2RlT3BzIiwiZW1wdHlOb2RlQXQiLCJ0YWdOYW1lIiwiY3JlYXRlUm1DYiIsImNoaWxkRWxtIiwicmVtb3ZlTm9kZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImluVlByZSIsImlnbm9yZSIsImNyZWF0aW5nRWxtSW5WUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwicGFyZW50RWxtIiwicmVmRWxtIiwibmVzdGVkIiwib3duZXJBcnJheSIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZUVsZW1lbnQiLCJzZXRTY29wZSIsImNyZWF0ZUNoaWxkcmVuIiwiaW52b2tlQ3JlYXRlSG9va3MiLCJjcmVhdGVDb21tZW50IiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJjaGVja0R1cGxpY2F0ZUtleXMiLCJzZXRTdHlsZVNjb3BlIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJ2bm9kZVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwibmV4dFNpYmxpbmciLCJmaW5kSWR4SW5PbGQiLCJzZWVuS2V5cyIsImVuZCIsImh5ZHJhdGUiLCJzZXRUZXh0Q29udGVudCIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJpbml0aWFsIiwiaHlkcmF0aW9uQmFpbGVkIiwiaXNSZW5kZXJlZE1vZHVsZSIsImFzc2VydE5vZGVNYXRjaCIsImhhc0NoaWxkTm9kZXMiLCJpbm5lckhUTUwiLCJjaGlsZHJlbk1hdGNoIiwiY2hpbGROb2RlIiwiZmlyc3RDaGlsZCIsImNoaWxkTm9kZXMiLCJmdWxsSW52b2tlIiwibm9kZVR5cGUiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsIl9sZWF2ZUNiIiwicGF0Y2hhYmxlIiwiaSQyIiwiZGlyZWN0aXZlcyQxIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJkaXIiLCJjYWxsSG9vayIsIm9sZEFyZyIsImFyZyIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHJpYnV0ZSIsImdlbkNsYXNzRm9yVm5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJkeW5hbWljQ2xhc3MiLCJzdHJpbmdpZnlDbGFzcyIsInN0cmluZ2lmeUFycmF5Iiwic3RyaW5naWZ5T2JqZWN0Iiwic3RyaW5naWZpZWQiLCJ1cGRhdGVDbGFzcyIsIm9sZERhdGEiLCJjbHMiLCJ0cmFuc2l0aW9uQ2xhc3MiLCJfdHJhbnNpdGlvbkNsYXNzZXMiLCJfcHJldkNsYXNzIiwiY2xhc3NfJDEiLCJvbGRIYW5kbGVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVwZGF0ZURPTUxpc3RlbmVycyIsImV2ZW50cyIsIm5vcm1hbGl6ZSQxIiwiY3JlYXRlU3R5bGUiLCJzdGF0aWNTdHlsZSIsInVwZGF0ZVN0eWxlIiwic2V0U3R5bGUiLCJvbGRTdHlsZSIsIm5lZWRDbG9uZSIsInRvT2JqZWN0Iiwic3R5bGUkMSIsIndoaXRlc3BhY2VSRSQxIiwiYWRkQ2xhc3MiLCJ0cmltIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwiZW50ZXIiLCJ0b2dnbGVEaXNwbGF5IiwiY2FuY2VsbGVkIiwiX2VudGVyQ2IiLCJhcHBlYXJDbGFzcyIsImFwcGVhclRvQ2xhc3MiLCJhcHBlYXJBY3RpdmVDbGFzcyIsImJlZm9yZUVudGVyIiwiYWZ0ZXJFbnRlciIsImVudGVyQ2FuY2VsbGVkIiwiYmVmb3JlQXBwZWFyIiwiYXBwZWFyIiwiYWZ0ZXJBcHBlYXIiLCJhcHBlYXJDYW5jZWxsZWQiLCJkdXJhdGlvbiIsInRyYW5zaXRpb25Ob2RlIiwiaXNBcHBlYXIiLCJzdGFydENsYXNzIiwiYWN0aXZlQ2xhc3MiLCJ0b0NsYXNzIiwiYmVmb3JlRW50ZXJIb29rIiwiZW50ZXJIb29rIiwiYWZ0ZXJFbnRlckhvb2siLCJlbnRlckNhbmNlbGxlZEhvb2siLCJleHBsaWNpdEVudGVyRHVyYXRpb24iLCJjaGVja0R1cmF0aW9uIiwiZXhwZWN0c0NTUyIsInVzZXJXYW50c0NvbnRyb2wiLCJnZXRIb29rQXJndW1lbnRzTGVuZ3RoIiwic2hvdyIsInBlbmRpbmdOb2RlIiwiX3BlbmRpbmciLCJpc1ZhbGlkRHVyYXRpb24iLCJsZWF2ZSIsImJlZm9yZUxlYXZlIiwiYWZ0ZXJMZWF2ZSIsImxlYXZlQ2FuY2VsbGVkIiwiZGVsYXlMZWF2ZSIsImV4cGxpY2l0TGVhdmVEdXJhdGlvbiIsInBlcmZvcm1MZWF2ZSIsImludm9rZXJGbnMiLCJfZW50ZXIiLCJwbGF0Zm9ybU1vZHVsZXMiLCJhY3Rpb25CYXIiLCJhbmRyb2lkIiwiZnJhbWVzIiwiTWFwIiwic2V0RnJhbWUiLCJmcmFtZSIsImdldEZyYW1lIiwiZGVsZXRlRnJhbWUiLCJkZWxldGUiLCJjbGVhckhpc3RvcnkiLCJiYWNrc3RhY2tWaXNpYmxlIiwiaGFzUm91dGVyVmlldyIsInByb3BlcnRpZXMiLCJjcmVhdGVkIiwiYXNzaWduIiwiJHByb3BzIiwiZGVzdHJveWVkIiwiX2dldEZyYW1lIiwibmF0aXZlVmlldyIsIl9lbnN1cmVUcmFuc2l0aW9uT2JqZWN0IiwiX2NvbXBvc2VUcmFuc2l0aW9uIiwiZW50cnkiLCJpc0FuZHJvaWQiLCJwbGF0Zm9ybUVudHJ5UHJvcCIsImVudHJ5UHJvcCIsInBsYXRmb3JtUHJvcCIsIm5vdGlmeUZpcnN0UGFnZU1vdW50ZWQiLCJwYWdlVm0iLCJuYXZpZ2F0ZSIsImJhY2siLCJnb0JhY2siLCJwYWdlIiwiaXNCYWNrTmF2aWdhdGlvbiIsIm9mZiIsImJhY2tzdGFja0VudHJ5IiwiaW9zIiwiVlVFX1ZJRVciLCJ0aWQiLCJ2VGVtcGxhdGUkMSIsImlmIiwibW91bnRlZCIsIiR0ZW1wbGF0ZXMiLCJUZW1wbGF0ZUJhZyIsInJlZ2lzdGVyVGVtcGxhdGUiLCJfdGVtcGxhdGVNYXAiLCJwcm90b3R5cGVBY2Nlc3NvcnMkMSIsInNlbGVjdG9yRm4iLCJjb25kaXRpb24iLCJzY29wZWRGbiIsImNvbmRpdGlvbkZuIiwiZ2V0Q29uZGl0aW9uRm4iLCJrZXllZFRlbXBsYXRlIiwiVnVlS2V5ZWRUZW1wbGF0ZSIsInNlbGYiLCJ0ZW1wbGF0ZVNlbGVjdG9yRm4iLCJlbnRyaWVzIiwiY3VyciIsImdldEtleWVkVGVtcGxhdGUiLCJwYXRjaFRlbXBsYXRlIiwiZ2V0QXZhaWxhYmxlIiwiZ2V0S2V5ZWRUZW1wbGF0ZXMiLCJfa2V5IiwiX3Njb3BlZEZuIiwicHJvdG90eXBlQWNjZXNzb3JzJDEkMSIsImNyZWF0ZVZpZXciLCJsaXN0VmlldyIsIk9ic2VydmFibGVBcnJheSIsIml0ZW1UYXAiLCJnZXRJdGVtQ29udGV4dCIsIm9uSXRlbVRhcCIsImdldEl0ZW0iLCJvbkl0ZW1Mb2FkaW5nIiwib2JqZWN0IiwiY3VycmVudEl0ZW0iLCJfaXRlbVRlbXBsYXRlU2VsZWN0b3IiLCJ2aWV3IiwiaWR4IiwiYWxpYXMiLCJpbmRleF9hbGlhcyIsIiRldmVuIiwiJG9kZCIsIl9WdWUiLCJzZXRWdWUiLCJjYW5CZUxlZnRPcGVuVGFnIiwiZ2V0Vmlld01ldGEiLCJpc1VuYXJ5VGFnIiwidGFnTmFtZXNwYWNlIiwiaXNLbm93blZpZXciLCJWVUVfVkVSU0lPTiIsIk5TX1ZVRV9WRVJTSU9OIiwiaW5mb1RyYWNlIiwic3VwcHJlc3NSZW5kZXJMb2dzIiwidXBkYXRlRGV2dG9vbHMiLCJQQUdFX1JFRiIsIl9maW5kUGFyZW50RnJhbWUiLCJmaXJzdFBhZ2VNb3VudGVkIiwiY3VycmVudFBhZ2UiLCJkaXNwb3NlIiwiZGlzcG9zZU5hdGl2ZVZpZXciLCJ0YWJWaWV3IiwicmVnaXN0ZXJUYWIiLCJ0YWJWaWV3SXRlbSIsIl9uYXRpdmVWaWV3IiwiYm90dG9tTmF2aWdhdGlvbiIsInJlZ2lzdGVyVGFiU3RyaXAiLCJ0YWJTdHJpcCIsInJlZ2lzdGVyVGFiQ29udGVudEl0ZW0iLCJ0YWJDb250ZW50SXRlbSIsInRhYnMiLCJyZWdpc3RlclRhYlN0cmlwSXRlbSIsInRhYlN0cmlwSXRlbSIsInRyYW5zaXRpb25Qcm9wcyIsIm1vZGUiLCJnZXRSZWFsQ2hpbGQiLCJjb21wT3B0aW9ucyIsImV4dHJhY3RUcmFuc2l0aW9uRGF0YSIsInBsYWNlaG9sZGVyIiwicmF3Q2hpbGQiLCJoYXNQYXJlbnRUcmFuc2l0aW9uIiwiaXNTYW1lQ2hpbGQiLCJvbGRDaGlsZCIsImlzTm90VGV4dE5vZGUiLCJpc1ZTaG93RGlyZWN0aXZlIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJlbGVtZW50TWFwIiwibmF0aXZlUmVnRXhwIiwiZGFzaFJlZ0V4cCIsImRlZmF1bHRWaWV3TWV0YSIsInNraXBBZGRUb0RvbSIsIm5vcm1hbGl6ZUVsZW1lbnROYW1lIiwiZWxlbWVudE5hbWUiLCJyZWdpc3RlckVsZW1lbnQiLCJyZXNvbHZlciIsIm1ldGEiLCJub3JtYWxpemVkTmFtZSIsImdldEVsZW1lbnRNYXAiLCJnZXRWaWV3Q2xhc3MiLCJUeXBlRXJyb3IiLCJBY3Rpb25CYXIiLCJfcmVtb3ZlVmlldyIsIkFjdGlvbkl0ZW0iLCJMaXN0VmlldyIsIk5hdmlnYXRpb25CdXR0b24iLCJUYWJWaWV3IiwiVGFiVmlld0l0ZW0iLCJCb3R0b21OYXZpZ2F0aW9uIiwiVGFicyIsIlRhYlN0cmlwIiwiVGFiU3RyaXBJdGVtIiwiVGFiQ29udGVudEl0ZW0iLCJMYWJlbCIsIkRhdGVQaWNrZXIiLCJBYnNvbHV0ZUxheW91dCIsIkFjdGl2aXR5SW5kaWNhdG9yIiwiQnV0dG9uIiwiQ29udGVudFZpZXciLCJEb2NrTGF5b3V0IiwiR3JpZExheW91dCIsIkh0bWxWaWV3IiwiSW1hZ2UiLCJMaXN0UGlja2VyIiwiUGFnZSIsIlBsYWNlaG9sZGVyIiwiUHJvZ3Jlc3MiLCJQcm94eVZpZXdDb250YWluZXIiLCJTY3JvbGxWaWV3IiwiU2VhcmNoQmFyIiwiU2VnbWVudGVkQmFyIiwiU2VnbWVudGVkQmFySXRlbSIsIlNsaWRlciIsIlN0YWNrTGF5b3V0IiwiRmxleGJveExheW91dCIsIlN3aXRjaCIsIlRleHRGaWVsZCIsIlRleHRWaWV3IiwiVGltZVBpY2tlciIsIldlYlZpZXciLCJXcmFwTGF5b3V0IiwiRm9ybWF0dGVkU3RyaW5nIiwiaW5zZXJ0Q2hpbGQiLCJhdEluZGV4Iiwic3BhbnMiLCJTcGFuIiwiRnJhbWUiLCJpc29iamVjdCIsImlzT2JqZWN0IiwiaXNPYmplY3RPYmplY3QiLCJvIiwiaXNQbGFpbk9iamVjdCIsImN0b3IiLCJwcm90IiwibWVyZ2UiLCJpc1ZhbGlkS2V5Iiwib3JpZyIsImNyZWF0ZUtleSIsIm1lbW8iLCJjaGFyIiwic2VwYXJhdG9yIiwicGF0dGVybiIsInNldFZhbHVlIiwiVmlldyIsImlzVmlldyIsIkxheW91dEJhc2UiLCJpc0xheW91dCIsImlzQ29udGVudFZpZXciLCJwYXJlbnRWaWV3IiwiY2hpbGRWaWV3IiwiZ2V0Q2hpbGRJbmRleCIsImFkZENoaWxkIiwiX2FkZFZpZXciLCJfYWRkQ2hpbGRGcm9tQnVpbGRlciIsInJlbW92ZUNoaWxkJDEiLCJYTUxfQVRUUklCVVRFUyIsIlZpZXdOb2RlIiwiX3RhZ05hbWUiLCJwcmV2U2libGluZyIsIl9vd25lckRvY3VtZW50IiwiX21ldGEiLCJwcm90b3R5cGVBY2Nlc3NvcnMiLCJsYXN0Q2hpbGQiLCJvd25lckRvY3VtZW50IiwiRXJyb3IiLCJudiIsIlV0aWxzIiwic3RhcnRzV2l0aCIsInN1YnN0ciIsImVuZHNXaXRoIiwiWG1sUGFyc2VyIiwiX2RlcmVmZXJlbmNlRW50aXRpZXMiLCJzZXRUZXh0IiwicmVmZXJlbmNlTm9kZSIsIlZVRV9FTEVNRU5UX1JFRiIsIkVsZW1lbnROb2RlIiwidmlld0NsYXNzIiwiQ29tbWVudE5vZGUiLCJUZXh0Tm9kZSIsIkRvY3VtZW50Tm9kZSIsImRvY3VtZW50RWxlbWVudCIsIm5hbWVzcGFjZSIsIm5hbWVzcGFjZU1hcCIsIm5ld05vZGUiLCJlbGVtZW50Tm9kZSIsInNjb3BlSWQiLCJtb2R1bGVzJDEiLCJoZSIsImRlY29kZSIsImh0bWwiLCJpc05vblBocmFzaW5nVGFnIiwiYXR0cmlidXRlIiwiZHluYW1pY0FyZ0F0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsImlzUGxhaW5UZXh0RWxlbWVudCIsInJlQ2FjaGUiLCJkZWNvZGluZ01hcCIsImVuY29kZWRBdHRyIiwiZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMiLCJpc0lnbm9yZU5ld2xpbmVUYWciLCJzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUiLCJkZWNvZGVBdHRyIiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJyZSIsInBhcnNlSFRNTCIsImV4cGVjdEhUTUwiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJzaG91bGRLZWVwQ29tbWVudCIsInN1YnN0cmluZyIsImFkdmFuY2UiLCJjb25kaXRpb25hbEVuZCIsImRvY3R5cGVNYXRjaCIsImVuZFRhZ01hdGNoIiwiY3VySW5kZXgiLCJwYXJzZUVuZFRhZyIsInN0YXJ0VGFnTWF0Y2giLCJwYXJzZVN0YXJ0VGFnIiwiaGFuZGxlU3RhcnRUYWciLCJyZXN0IiwiY2hhcnMiLCJlbmRUYWdMZW5ndGgiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwicmVzdCQxIiwiYWxsIiwiYXR0ciIsInVuYXJ5U2xhc2giLCJ1bmFyeSIsInNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiIsIm91dHB1dFNvdXJjZVJhbmdlIiwibG93ZXJDYXNlZFRhZyIsInBvcyIsImxvd2VyQ2FzZWRUYWdOYW1lIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInBhcnNlRmlsdGVycyIsImV4cCIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJwcmV2IiwiZmlsdGVycyIsInB1c2hGaWx0ZXIiLCJ3cmFwRmlsdGVyIiwiZGVmYXVsdFRhZ1JFIiwicmVnZXhFc2NhcGVSRSIsImJ1aWxkUmVnZXgiLCJkZWxpbWl0ZXJzIiwib3BlbiIsImNsb3NlIiwicGFyc2VUZXh0IiwidGFnUkUiLCJ0b2tlbnMiLCJyYXdUb2tlbnMiLCJ0b2tlblZhbHVlIiwiZXhlYyIsImdlbkNvbXBvbmVudE1vZGVsIiwibnVtYmVyIiwiYmFzZVZhbHVlRXhwcmVzc2lvbiIsInZhbHVlRXhwcmVzc2lvbiIsImFzc2lnbm1lbnQiLCJnZW5Bc3NpZ25tZW50Q29kZSIsInBhcnNlTW9kZWwiLCJjaHIiLCJleHByZXNzaW9uUG9zIiwiZXhwcmVzc2lvbkVuZFBvcyIsImxhc3RJbmRleE9mIiwiZW9mIiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0IiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJiYXNlV2FybiIsInJhbmdlIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJkeW5hbWljIiwicmFuZ2VTZXRJdGVtIiwicGxhaW4iLCJhZGRBdHRyIiwiZHluYW1pY0F0dHJzIiwiYWRkUmF3QXR0ciIsImF0dHJzTWFwIiwiYXR0cnNMaXN0IiwiYWRkRGlyZWN0aXZlIiwiaXNEeW5hbWljQXJnIiwicHJlcGVuZE1vZGlmaWVyTWFya2VyIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsInByZXZlbnQiLCJyaWdodCIsIm1pZGRsZSIsIm5hdGl2ZSIsIm5hdGl2ZUV2ZW50cyIsIm5ld0hhbmRsZXIiLCJ1bnNoaWZ0IiwiZ2V0UmF3QmluZGluZ0F0dHIiLCJyYXdBdHRyc01hcCIsImdldEJpbmRpbmdBdHRyIiwiZ2V0U3RhdGljIiwiZHluYW1pY1ZhbHVlIiwiZ2V0QW5kUmVtb3ZlQXR0ciIsInN0YXRpY1ZhbHVlIiwicmVtb3ZlRnJvbU1hcCIsImdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4Iiwib25SRSIsImRpclJFIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJzdHJpcFBhcmVuc1JFIiwiZHluYW1pY0FyZ1JFIiwiYXJnUkUiLCJiaW5kUkUiLCJtb2RpZmllclJFIiwic2xvdFJFIiwibGluZUJyZWFrUkUiLCJ3aGl0ZXNwYWNlUkUiLCJpbnZhbGlkQXR0cmlidXRlUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwiZW1wdHlTbG90U2NvcGVUb2tlbiIsInRyYW5zZm9ybXMiLCJwcmVUcmFuc2Zvcm1zIiwicG9zdFRyYW5zZm9ybXMiLCJwbGF0Zm9ybUlzUHJlVGFnIiwicGxhdGZvcm1NdXN0VXNlUHJvcCIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwibWF5YmVDb21wb25lbnQiLCJjcmVhdGVBU1RFbGVtZW50IiwibWFrZUF0dHJzTWFwIiwiaXNQcmVUYWciLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJ3aGl0ZXNwYWNlT3B0aW9uIiwid2hpdGVzcGFjZSIsInJvb3QiLCJjdXJyZW50UGFyZW50IiwiaW5QcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImNsb3NlRWxlbWVudCIsImVsZW1lbnQiLCJ0cmltRW5kaW5nV2hpdGVzcGFjZSIsInByb2Nlc3NlZCIsInByb2Nlc3NFbGVtZW50IiwiZWxzZWlmIiwiZWxzZSIsImNoZWNrUm9vdENvbnN0cmFpbnRzIiwiYWRkSWZDb25kaXRpb24iLCJibG9jayIsImZvcmJpZGRlbiIsInByb2Nlc3NJZkNvbmRpdGlvbnMiLCJzbG90U2NvcGUiLCJzbG90VGFyZ2V0IiwibGFzdE5vZGUiLCJjb21tZW50cyIsInN0YXJ0JDEiLCJndWFyZElFU1ZHQnVnIiwiY3VtdWxhdGVkIiwiaXNGb3JiaWRkZW5UYWciLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc0ZvciIsInByb2Nlc3NJZiIsInByb2Nlc3NPbmNlIiwiZW5kJDEiLCJpc1RleHRUYWciLCJwcm9jZXNzS2V5IiwicHJvY2Vzc1JlZiIsInByb2Nlc3NTbG90Q29udGVudCIsInByb2Nlc3NTbG90T3V0bGV0IiwicHJvY2Vzc0NvbXBvbmVudCIsInByb2Nlc3NBdHRycyIsImZvciIsIml0ZXJhdG9yMiIsIml0ZXJhdG9yMSIsImNoZWNrSW5Gb3IiLCJwYXJzZUZvciIsImluTWF0Y2giLCJpdGVyYXRvck1hdGNoIiwiZmluZFByZXZFbGVtZW50IiwiaWZDb25kaXRpb25zIiwic2xvdFRhcmdldER5bmFtaWMiLCJzbG90QmluZGluZyIsImdldFNsb3ROYW1lIiwic2xvdEJpbmRpbmckMSIsImR5bmFtaWMkMSIsInNsb3RDb250YWluZXIiLCJiaW5kaW5nIiwic2xvdE5hbWUiLCJzeW5jR2VuIiwiaXNEeW5hbWljIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsImNhbWVsIiwiYXJnTWF0Y2giLCJjaGVja0ZvckFsaWFzTW9kZWwiLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsIl9lbCIsImlzU3RhdGljS2V5IiwiaXNQbGF0Zm9ybVJlc2VydmVkVGFnIiwiZ2VuU3RhdGljS2V5c0NhY2hlZCIsImdlblN0YXRpY0tleXMiLCJvcHRpbWl6ZSIsIm1hcmtTdGF0aWMiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJsJDEiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJmbkludm9rZVJFIiwic2ltcGxlUGF0aFJFIiwiZXNjIiwidGFiIiwic3BhY2UiLCJ1cCIsImxlZnQiLCJkb3duIiwia2V5TmFtZXMiLCJnZW5HdWFyZCIsIm1vZGlmaWVyQ29kZSIsInN0b3AiLCJjdHJsIiwiYWx0IiwiZ2VuSGFuZGxlcnMiLCJwcmVmaXgiLCJzdGF0aWNIYW5kbGVycyIsImR5bmFtaWNIYW5kbGVycyIsImhhbmRsZXJDb2RlIiwiZ2VuSGFuZGxlciIsImlzTWV0aG9kUGF0aCIsImlzRnVuY3Rpb25FeHByZXNzaW9uIiwiaXNGdW5jdGlvbkludm9jYXRpb24iLCJjb2RlIiwiZ2VuTW9kaWZpZXJDb2RlIiwia2V5TW9kaWZpZXIiLCJnZW5LZXlGaWx0ZXIiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwicGFyc2VJbnQiLCJrZXlDb2RlIiwia2V5TmFtZSIsIndyYXBMaXN0ZW5lcnMiLCJ3cmFwRGF0YSIsImJhc2VEaXJlY3RpdmVzIiwiY2xvYWsiLCJDb2RlZ2VuU3RhdGUiLCJkYXRhR2VuRm5zIiwib25jZUlkIiwiZ2VuZXJhdGUiLCJhc3QiLCJzdGF0ZSIsImdlbkVsZW1lbnQiLCJzdGF0aWNQcm9jZXNzZWQiLCJnZW5TdGF0aWMiLCJvbmNlUHJvY2Vzc2VkIiwiZ2VuT25jZSIsImZvclByb2Nlc3NlZCIsImdlbkZvciIsImlmUHJvY2Vzc2VkIiwiZ2VuSWYiLCJnZW5DaGlsZHJlbiIsImdlblNsb3QiLCJnZW5Db21wb25lbnQiLCJnZW5EYXRhJDIiLCJvcmlnaW5hbFByZVN0YXRlIiwiYWx0R2VuIiwiYWx0RW1wdHkiLCJnZW5JZkNvbmRpdGlvbnMiLCJjb25kaXRpb25zIiwiZ2VuVGVybmFyeUV4cCIsImFsdEhlbHBlciIsImdlbkRpcmVjdGl2ZXMiLCJnZW5Qcm9wcyIsImdlblNjb3BlZFNsb3RzIiwiZ2VuSW5saW5lVGVtcGxhdGUiLCJoYXNSdW50aW1lIiwibmVlZFJ1bnRpbWUiLCJnZW4iLCJpbmxpbmVSZW5kZXJGbnMiLCJjb250YWluc1Nsb3RDaGlsZCIsIm5lZWRzS2V5IiwiZ2VuZXJhdGVkU2xvdHMiLCJnZW5TY29wZWRTbG90IiwiaXNMZWdhY3lTeW50YXgiLCJyZXZlcnNlUHJveHkiLCJjaGVja1NraXAiLCJhbHRHZW5FbGVtZW50IiwiYWx0R2VuTm9kZSIsImVsJDEiLCJub3JtYWxpemF0aW9uVHlwZSQxIiwiZ2V0Tm9ybWFsaXphdGlvblR5cGUiLCJnZW5Ob2RlIiwibmVlZHNOb3JtYWxpemF0aW9uIiwiZ2VuQ29tbWVudCIsImdlblRleHQiLCJ0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMiLCJjb21wb25lbnROYW1lIiwic3RhdGljUHJvcHMiLCJkeW5hbWljUHJvcHMiLCJwcm9oaWJpdGVkS2V5d29yZFJFIiwidW5hcnlPcGVyYXRvcnNSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0cmlwcGVkIiwia2V5d29yZE1hdGNoIiwiY2hlY2tJZGVudGlmaWVyIiwiaWRlbnQiLCJnZW5lcmF0ZUNvZGVGcmFtZSIsImxpbmVzIiwiY291bnQiLCJyZXBlYXQiLCJsaW5lTGVuZ3RoIiwicGFkIiwibGVuZ3RoJDEiLCJtaW4iLCJjcmVhdGVGdW5jdGlvbiIsImVycm9ycyIsImNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4iLCJjb21waWxlIiwiY29tcGlsZVRvRnVuY3Rpb25zIiwiY29tcGlsZWQiLCJ0aXBzIiwiZm5HZW5FcnJvcnMiLCJjcmVhdGVDb21waWxlckNyZWF0b3IiLCJiYXNlQ29tcGlsZSIsImNyZWF0ZUNvbXBpbGVyIiwiYmFzZU9wdGlvbnMiLCJmaW5hbE9wdGlvbnMiLCJsZWFkaW5nU3BhY2VMZW5ndGgiLCJ0cmFuc2Zvcm1Ob2RlJDIiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhJDEiLCJjbGFzc18iLCJ0cmFuc2Zvcm1Ob2RlIiwiZ2VuRGF0YSIsIm5vcm1hbGl6ZSIsInRyYW5zZm9ybU5vZGUkMSIsInBhcnNlU3RhdGljU3R5bGUiLCJzdHlsZVJlc3VsdCIsInN0eWxlQmluZGluZyIsInN0eWxlTGlzdCIsInByZVRyYW5zZm9ybU5vZGUkMiIsInZmb3IiLCJmb3JfIiwicHJlVHJhbnNmb3JtTm9kZSIsInByZVRyYW5zZm9ybU5vZGUkMSIsInJvdXRlciIsImJ1aWxkU2NvcGVTdHJpbmciLCJ2VGVtcGxhdGUiLCJmaW5kIiwiYXR0ck5hbWUiLCJtb2RzIiwidmlldyQxIiwiZ2VuVmlld0NvbXBvbmVudE1vZGVsIiwiaW5pdFVzZSIsInVzZSIsInBsdWdpbiIsImluc3RhbGxlZFBsdWdpbnMiLCJfaW5zdGFsbGVkUGx1Z2lucyIsImluc3RhbGwiLCJpbml0TWl4aW4iLCJtaXhpbiIsImluaXRFeHRlbmQiLCJTdXBlciIsIlN1cGVySWQiLCJjYWNoZWRDdG9ycyIsIl9DdG9yIiwiU3ViIiwiVnVlQ29tcG9uZW50IiwiaW5pdFByb3BzIiwiaW5pdENvbXB1dGVkIiwiQ29tcCIsImluaXRBc3NldFJlZ2lzdGVycyIsImRlZmluaXRpb24iLCJnZXRDb21wb25lbnROYW1lIiwibWF0Y2hlcyIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwicGF0dGVyblR5cGVzIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwib2JzZXJ2YWJsZSIsInNzckNvbnRleHQiLCJ2ZXJzaW9uIiwibG9jYXRlTm9kZSIsIm9yaWdpbmFsVmlzaWJpbGl0eSIsIl9fdk9yaWdpbmFsVmlzaWJpbGl0eSIsInVuYmluZCIsImFycmF5IiwicGxhdGZvcm1EaXJlY3RpdmVzIiwiJGRvY3VtZW50IiwiX19mbHVzaENhbGxiYWNrc19fIiwiJHN0YXJ0IiwiQXBwQ29uc3RydWN0b3IiLCJzZXF1ZW50aWFsQ291bnRlciQxIiwic2VyaWFsaXplTW9kYWxPcHRpb25zIiwiYWxsb3dlZCIsImluY2x1ZGVzIiwiZ2V0VGFyZ2V0VmlldyIsIl9maW5kUGFyZW50TW9kYWxFbnRyeSIsIk1vZGFsUGx1Z2luIiwiJG1vZGFsIiwiY2xvc2VDYiIsIiRzaG93TW9kYWwiLCJtb2RhbFBhZ2UiLCJjbG9zZU1vZGFsIiwibmF2RW50cnlJbnN0YW5jZSIsImNsb3NlQ2FsbGJhY2siLCJzaG93TW9kYWwiLCJzZXF1ZW50aWFsQ291bnRlciIsInNlcmlhbGl6ZU5hdmlnYXRpb25PcHRpb25zIiwiZ2V0RnJhbWVJbnN0YW5jZSIsImdldEZyYW1lQnlJZCIsImZpbmRQYXJlbnRGcmFtZSIsIk5hdmlnYXRvclBsdWdpbiIsIm5hdmlnYXRlQmFjayIsIiRuYXZpZ2F0ZUJhY2siLCJwYXJlbnRGcmFtZSIsImRlZmF1bHRPcHRpb25zIiwibmF2aWdhdGVUbyIsIiRuYXZpZ2F0ZVRvIiwicmVzb2x2ZU9uRXZlbnQiLCJyZXNvbHZlSGFuZGxlciIsIl9fb25MaXZlU3luY0NvcmUiLCJ0b3Btb3N0IiwibW9kYWwiLCJhZGRDc3NGaWxlIiwiZ2V0Q3NzRmlsZU5hbWUiLCJfX1ZVRV9IT1RfTUFQX18iLCJpbnN0YWxsZWQiLCJpc0Jyb3dzZXJpZnkiLCJpbml0SG9va05hbWUiLCJ2dWUiLCJicm93c2VyaWZ5IiwiY29tcGF0aWJsZSIsImNyZWF0ZVJlY29yZCIsIm1ha2VPcHRpb25zSG90IiwiaW5zdGFuY2VzIiwiaXNSZWNvcmRlZCIsImluamVjdEhvb2siLCJyZWNvcmQiLCJ0cnlXcmFwIiwidXBkYXRlT3B0aW9ucyIsIm9sZE9wdGlvbnMiLCJuZXdPcHRpb25zIiwicmVyZW5kZXIiLCJpbnN0YW5jZSIsInJlc3RvcmUiLCJwYXRjaFNjb3BlZFNsb3RzIiwiaW5qZWN0U3R5bGVzIiwiX2luamVjdFN0eWxlcyIsInJlbG9hZCIsIm5ld0N0b3IiLCJyZWxlYXNlIiwiZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxNQUFNQSxTQUFTLEdBQUcsTUFBbEI7QUFDQSxNQUFNQyxHQUFHLEdBQUc7QUFDUkMsTUFBSSxFQUFHQyxPQUFELElBQWFDLE9BQU8sQ0FBQ0YsSUFBUixDQUFjLEdBQUVGLFNBQVUsSUFBR0csT0FBUSxFQUFyQyxDQURYO0FBRVJFLE1BQUksRUFBR0YsT0FBRCxJQUFhQyxPQUFPLENBQUNDLElBQVIsQ0FBYyxHQUFFTCxTQUFVLElBQUdHLE9BQVEsRUFBckMsQ0FGWDtBQUdSRyxPQUFLLEVBQUdILE9BQUQsSUFBYUMsT0FBTyxDQUFDRSxLQUFSLENBQWUsR0FBRU4sU0FBVSxJQUFHRyxPQUFRLEVBQXRDO0FBSFosQ0FBWjtBQUtBLE1BQU1JLE9BQU8sR0FBRyxrRUFBaEI7QUFDQSxNQUFNQyxVQUFVLEdBQUc7QUFDZkMsa0JBQWdCLEVB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pHQSxJQUFJbS9DLENBQUosQyxDQUVBOztBQUNBQSxDQUFDLEdBQUksWUFBVztBQUNmLFNBQU8sSUFBUDtBQUNBLENBRkcsRUFBSjs7QUFJQSxJQUFJO0FBQ0g7QUFDQUEsR0FBQyxHQUFHQSxDQUFDLElBQUksSUFBSS9wRCxRQUFKLENBQWEsYUFBYixHQUFUO0FBQ0EsQ0FIRCxDQUdFLE9BQU91QixDQUFQLEVBQVU7QUFDWDtBQUNBLE1BQUksT0FBT3dCLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0NnbkQsQ0FBQyxHQUFHaG5ELE1BQUo7QUFDaEMsQyxDQUVEO0FBQ0E7QUFDQTs7O0FBRUE1TCxNQUFNLENBQUN5QixPQUFQLEdBQWlCbXhELENBQWpCLEMiLCJmaWxlIjoidmVuZG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaG1yUHJlZml4ID0gJ0hNUjonO1xuY29uc3QgbG9nID0ge1xuICAgIGluZm86IChtZXNzYWdlKSA9PiBjb25zb2xlLmluZm8oYCR7aG1yUHJlZml4fSAke21lc3NhZ2V9YCksXG4gICAgd2FybjogKG1lc3NhZ2UpID0+IGNvbnNvbGUud2FybihgJHtobXJQcmVmaXh9ICR7bWVzc2FnZX1gKSxcbiAgICBlcnJvcjogKG1lc3NhZ2UpID0+IGNvbnNvbGUuZXJyb3IoYCR7aG1yUHJlZml4fSAke21lc3NhZ2V9YCksXG59O1xuY29uc3QgcmVmcmVzaCA9ICdBcHBsaWNhdGlvbiBuZWVkcyB0byBiZSByZXN0YXJ0ZWQgaW4gb3JkZXIgdG8gYXBwbHkgdGhlIGNoYW5nZXMuJztcbmNvbnN0IGhvdE9wdGlvbnMgPSB7XG4gICAgaWdub3JlVW5hY2NlcHRlZDogZmFsc2UsXG4gICAgaWdub3JlRGVjbGluZWQ6IGZhbHNlLFxuICAgIGlnbm9yZUVycm9yZWQ6IGZhbHNlLFxuICAgIG9uVW5hY2NlcHRlZChkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNoYWluID0gW10uY29uY2F0KGRhdGEuY2hhaW4pO1xuICAgICAgICBjb25zdCBsYXN0ID0gY2hhaW5bY2hhaW4ubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGxhc3QgPT09IDApIHtcbiAgICAgICAgICAgIGNoYWluLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nLndhcm4oYElnbm9yZWQgYW4gdXBkYXRlIHRvIHVuYWNjZXB0ZWQgbW9kdWxlOiBgKTtcbiAgICAgICAgY2hhaW4uZm9yRWFjaChtb2QgPT4gbG9nLndhcm4oYCAgICAgICAgIOKerSAke21vZH1gKSk7XG4gICAgfSxcbiAgICBvbkRlY2xpbmVkKGRhdGEpIHtcbiAgICAgICAgbG9nLndhcm4oYElnbm9yZWQgYW4gdXBkYXRlIHRvIGRlY2xpbmVkIG1vZHVsZTpgKTtcbiAgICAgICAgZGF0YS5jaGFpbi5mb3JFYWNoKG1vZCA9PiBsb2cud2FybihgICAgICAgICAg4p6tICR7bW9kfWApKTtcbiAgICB9LFxuICAgIG9uRXJyb3JlZChkYXRhKSB7XG4gICAgICAgIGxvZy53YXJuKFxuICAgICAgICAgICAgYElnbm9yZWQgYW4gZXJyb3Igd2hpbGUgdXBkYXRpbmcgbW9kdWxlICR7ZGF0YS5tb2R1bGVJZH0gPCR7ZGF0YS50eXBlfT5gXG4gICAgICAgICk7XG4gICAgICAgIGxvZy53YXJuKGRhdGEuZXJyb3IpO1xuICAgIH0sXG59O1xuXG5sZXQgbmV4dEhhc2g7XG5sZXQgY3VycmVudEhhc2g7XG5cbmZ1bmN0aW9uIHVwVG9EYXRlKCkge1xuICAgIHJldHVybiBuZXh0SGFzaC5pbmRleE9mKF9fd2VicGFja19oYXNoX18pID49IDA7XG59XG5cbmZ1bmN0aW9uIHJlc3VsdChtb2R1bGVzLCBhcHBsaWVkTW9kdWxlcykge1xuICAgIGNvbnN0IHVuYWNjZXB0ZWQgPSBtb2R1bGVzLmZpbHRlcihcbiAgICAgICAgKG1vZHVsZUlkKSA9PiBhcHBsaWVkTW9kdWxlcyAmJiBhcHBsaWVkTW9kdWxlcy5pbmRleE9mKG1vZHVsZUlkKSA8IDBcbiAgICApO1xuXG4gICAgaWYgKHVuYWNjZXB0ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICBsb2cud2FybignVGhlIGZvbGxvd2luZyBtb2R1bGVzIGNvdWxkIG5vdCBiZSB1cGRhdGVkOicpO1xuXG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlSWQgb2YgdW5hY2NlcHRlZCkge1xuICAgICAgICAgICAgbG9nLndhcm4oYCAgICAgICAgICDiprsgJHttb2R1bGVJZH1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKGFwcGxpZWRNb2R1bGVzIHx8IFtdKS5sZW5ndGgpIHtcbiAgICAgICAgbG9nLmluZm8oJ05vIE1vZHVsZXMgVXBkYXRlZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsb2cuaW5mbygnVGhlIGZvbGxvd2luZyBtb2R1bGVzIHdlcmUgdXBkYXRlZDonKTtcblxuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZUlkIG9mIGFwcGxpZWRNb2R1bGVzKSB7XG4gICAgICAgICAgICBsb2cuaW5mbyhgICAgICAgICAg4oa7ICR7bW9kdWxlSWR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBudW1iZXJJZHMgPSBhcHBsaWVkTW9kdWxlcy5ldmVyeShcbiAgICAgICAgICAgIChtb2R1bGVJZCkgPT4gdHlwZW9mIG1vZHVsZUlkID09PSAnbnVtYmVyJ1xuICAgICAgICApO1xuICAgICAgICBpZiAobnVtYmVySWRzKSB7XG4gICAgICAgICAgICBsb2cuaW5mbyhcbiAgICAgICAgICAgICAgICAnUGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBOYW1lZE1vZHVsZXNQbHVnaW4gZm9yIG1vZHVsZSBuYW1lcy4nXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjaGVjayhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1vZHVsZS5ob3RcbiAgICAgICAgLmNoZWNrKClcbiAgICAgICAgLnRoZW4oKG1vZHVsZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghbW9kdWxlcykge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKFxuICAgICAgICAgICAgICAgICAgICBgQ2Fubm90IGZpbmQgdXBkYXRlLiAke3JlZnJlc2h9YFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtb2R1bGUuaG90XG4gICAgICAgICAgICAgICAgLmFwcGx5KGhvdE9wdGlvbnMpXG4gICAgICAgICAgICAgICAgLnRoZW4oKGFwcGxpZWRNb2R1bGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0Q2hlY2s7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXBUb0RhdGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dENoZWNrID0gY2hlY2sob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQobW9kdWxlcywgYXBwbGllZE1vZHVsZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cFRvRGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgbW9kaWZ5IG1lc3NhZ2UgLSBDTEkgZGVwZW5kcyBvbiB0aGlzIGV4YWN0IGNvbnRlbnQgdG8gZGV0ZXJtaW5lIGhtciBvcGVyYXRpb24gc3RhdHVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmluZm8oYFN1Y2Nlc3NmdWxseSBhcHBsaWVkIHVwZGF0ZSB3aXRoIGhtciBoYXNoICR7Y3VycmVudEhhc2h9LiBBcHAgaXMgdXAgdG8gZGF0ZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Q2hlY2sgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IG1vZHVsZS5ob3Quc3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChbJ2Fib3J0JywgJ2ZhaWwnXS5pbmRleE9mKHN0YXR1cykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IG1vZGlmeSBtZXNzYWdlIC0gQ0xJIGRlcGVuZHMgb24gdGhpcyBleGFjdCBjb250ZW50IHRvIGRldGVybWluZSBobXIgb3BlcmF0aW9uIHN0YXR1cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgQ2Fubm90IGFwcGx5IHVwZGF0ZSB3aXRoIGhtciBoYXNoICR7Y3VycmVudEhhc2h9LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKGVyci5tZXNzYWdlIHx8IGVyci5zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cuZXJyb3IoYFVwZGF0ZSBmYWlsZWQ6ICR7ZXJyLm1lc3NhZ2UgfHwgZXJyLnN0YWNrfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBtb2R1bGUuaG90LnN0YXR1cygpO1xuICAgICAgICAgICAgaWYgKFsnYWJvcnQnLCAnZmFpbCddLmluZGV4T2Yoc3RhdHVzKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKGBDYW5ub3QgY2hlY2sgZm9yIHVwZGF0ZS4gJHtyZWZyZXNofWApO1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihlcnIubWVzc2FnZSB8fCBlcnIuc3RhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoYFVwZGF0ZSBjaGVjayBmYWlsZWQ6ICR7ZXJyLm1lc3NhZ2UgfHwgZXJyLnN0YWNrfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn1cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgICBsb2cuaW5mbygnSG90IE1vZHVsZSBSZXBsYWNlbWVudCBFbmFibGVkLiBXYWl0aW5nIGZvciBzaWduYWwuJyk7XG59IGVsc2Uge1xuICAgIGxvZy5lcnJvcignSG90IE1vZHVsZSBSZXBsYWNlbWVudCBpcyBkaXNhYmxlZC4nKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlKGxhdGVzdEhhc2gsIG9wdGlvbnMpIHtcbiAgICBuZXh0SGFzaCA9IGxhdGVzdEhhc2g7XG4gICAgaWYgKCF1cFRvRGF0ZSgpKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG1vZHVsZS5ob3Quc3RhdHVzKCk7XG5cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2lkbGUnKSB7XG4gICAgICAgICAgICAvL0RvIG5vdCBtb2RpZnkgbWVzc2FnZSAtIENMSSBkZXBlbmRzIG9uIHRoaXMgZXhhY3QgY29udGVudCB0byBkZXRlcm1pbmUgaG1yIG9wZXJhdGlvbiBzdGF0dXMuXG4gICAgICAgICAgICBsb2cuaW5mbyhgQ2hlY2tpbmcgZm9yIHVwZGF0ZXMgdG8gdGhlIGJ1bmRsZSB3aXRoIGhtciBoYXNoICR7Y3VycmVudEhhc2h9LmApO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrKG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKFsnYWJvcnQnLCAnZmFpbCddLmluZGV4T2Yoc3RhdHVzKSA+PSAwKSB7XG4gICAgICAgICAgICBsb2cud2FybihcbiAgICAgICAgICAgICAgICBgQ2Fubm90IGFwcGx5IHVwZGF0ZS4gQSBwcmV2aW91cyB1cGRhdGUgJHtzdGF0dXN9ZWQuICR7cmVmcmVzaH1gXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZ2V0TmV4dEhhc2goaGFzaCwgZ2V0RmlsZUNvbnRlbnQpIHtcbiAgICBjb25zdCBmaWxlID0gZ2V0RmlsZUNvbnRlbnQoYCR7aGFzaH0uaG90LXVwZGF0ZS5qc29uYCk7XG4gICAgaWYgKCFmaWxlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaGFzaCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGUucmVhZFRleHQoKS50aGVuKGhvdFVwZGF0ZUNvbnRlbnQgPT4ge1xuICAgICAgICBpZiAoaG90VXBkYXRlQ29udGVudCkge1xuICAgICAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBKU09OLnBhcnNlKGhvdFVwZGF0ZUNvbnRlbnQpO1xuICAgICAgICAgICAgY29uc3QgbmV3SGFzaCA9IG1hbmlmZXN0Lmg7XG4gICAgICAgICAgICByZXR1cm4gZ2V0TmV4dEhhc2gobmV3SGFzaCwgZ2V0RmlsZUNvbnRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShoYXNoKTtcbiAgICAgICAgfVxuICAgIH0pLmNhdGNoKGVycm9yID0+IFByb21pc2UucmVqZWN0KGVycm9yKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2hlY2tTdGF0ZShpbml0aWFsSGFzaCwgZ2V0RmlsZUNvbnRlbnQpIHtcbiAgICBjdXJyZW50SGFzaCA9IGluaXRpYWxIYXNoO1xuICAgIHJldHVybiBnZXROZXh0SGFzaChpbml0aWFsSGFzaCwgZ2V0RmlsZUNvbnRlbnQpLnRoZW4obmV4dEhhc2ggPT4ge1xuICAgICAgICBpZiAobmV4dEhhc2ggIT0gaW5pdGlhbEhhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGUobmV4dEhhc2gsIHt9KTtcbiAgICAgICAgfVxuICAgIH0pXG59XG4iLCJjb25zdCBsb2FkQ3NzID0gcmVxdWlyZShcIi4vbG9hZC1hcHBsaWNhdGlvbi1jc3NcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgbG9hZENzcyhmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgYXBwQ3NzQ29udGV4dCA9IHJlcXVpcmUuY29udGV4dChcIn4vXCIsIGZhbHNlLCAvXlxcLlxcL2FwcFxcLihjc3N8c2Nzc3xsZXNzfHNhc3MpJC8pO1xuICAgICAgICBnbG9iYWwucmVnaXN0ZXJXZWJwYWNrTW9kdWxlcyhhcHBDc3NDb250ZXh0KTtcbiAgICB9KTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxvYWRNb2R1bGVGbikge1xuICAgIGNvbnN0IG5zQ29yZSA9IHJlcXVpcmUoXCJAbmF0aXZlc2NyaXB0L2NvcmVcIik7XG4gICAgcmVxdWlyZShcIkBuYXRpdmVzY3JpcHQvY29yZS91aS9zdHlsaW5nL3N0eWxlLXNjb3BlXCIpO1xuXG4gICAgbG9hZE1vZHVsZUZuKCk7XG5cbiAgICBuc0NvcmUuQXBwbGljYXRpb24ubG9hZEFwcENzcygpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhtclVwZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGhvdCA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2hvdFwiKTtcbmZ1bmN0aW9uIGhtclVwZGF0ZSgpIHtcbiAgICBjb25zdCBjb3JlRmlsZSA9IHJlcXVpcmUoJ0BuYXRpdmVzY3JpcHQvY29yZScpO1xuICAgIGNvbnN0IGN1cnJlbnRBcHBGb2xkZXIgPSBjb3JlRmlsZS5rbm93bkZvbGRlcnMuY3VycmVudEFwcCgpO1xuICAgIGNvbnN0IGxhdGVzdEhhc2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fWydoJ10oKTtcbiAgICByZXR1cm4gaG90KGxhdGVzdEhhc2gsIChmaWxlbmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBmdWxsRmlsZVBhdGggPSBjb3JlRmlsZS5wYXRoLmpvaW4oY3VycmVudEFwcEZvbGRlci5wYXRoLCBmaWxlbmFtZSk7XG4gICAgICAgIHJldHVybiBjb3JlRmlsZS5GaWxlLmV4aXN0cyhmdWxsRmlsZVBhdGgpID8gY3VycmVudEFwcEZvbGRlci5nZXRGaWxlKGZpbGVuYW1lKSA6IG51bGw7XG4gICAgfSk7XG59XG5leHBvcnRzLmhtclVwZGF0ZSA9IGhtclVwZGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtci11cGRhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhtclVwZGF0ZSA9IHZvaWQgMDtcbnZhciBobXJfdXBkYXRlXzEgPSByZXF1aXJlKFwiLi9obXItdXBkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaG1yVXBkYXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBobXJfdXBkYXRlXzEuaG1yVXBkYXRlOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59IiwiXG4vKiFcbiAqIE5hdGl2ZVNjcmlwdC1WdWUgdjIuOC40XG4gKiAoVXNpbmcgVnVlIHYyLjYuMTIpXG4gKiAoYykgMjAxNy0yMDIxIHJpZ29yNzg5XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbmdsb2JhbC5wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MgfHwge31cbmdsb2JhbC5wcm9jZXNzLmVudiA9IGdsb2JhbC5wcm9jZXNzLmVudiB8fCB7fVxuXG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQG5hdGl2ZXNjcmlwdC9jb3JlJyk7XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCQxIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUsIGUuZy4sIFtvYmplY3QgT2JqZWN0XS5cbiAqL1xudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0JDEgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiAoXG4gICAgaXNEZWYodmFsKSAmJlxuICAgIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWwuY2F0Y2ggPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IEFycmF5LmlzQXJyYXkodmFsKSB8fCAoaXNQbGFpbk9iamVjdCQxKHZhbCkgJiYgdmFsLnRvU3RyaW5nID09PSBfdG9TdHJpbmcpXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiByZW1vdmUkMiAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCxcbiAqIGUuZy4sIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICogc2luY2UgbmF0aXZlIGJpbmQgaXMgbm93IHBlcmZvcm1hbnQgZW5vdWdoIGluIG1vc3QgYnJvd3NlcnMuXG4gKiBCdXQgcmVtb3ZpbmcgaXQgd291bGQgbWVhbiBicmVha2luZyBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluXG4gKiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cblxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbmZ1bmN0aW9uIG5hdGl2ZUJpbmQgKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZuLmJpbmQoY3R4KVxufVxuXG52YXIgYmluZCQxID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgPyBuYXRpdmVCaW5kXG4gIDogcG9seWZpbGxCaW5kO1xuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCQxIChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdHJpbmcgY29udGFpbmluZyBzdGF0aWMga2V5cyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICB9LCBbXSkuam9pbignLCcpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QkMShhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0JDEoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKClcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGxvb3NlbHkgZXF1YWwgdmFsdWUgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxuICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogdW5pY29kZSBsZXR0ZXJzIHVzZWQgZm9yIHBhcnNpbmcgaHRtbCB0YWdzLCBjb21wb25lbnQgbmFtZXMgYW5kIHByb3BlcnR5IHBhdGhzLlxuICogdXNpbmcgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1My9zZW1hbnRpY3Mtc2NyaXB0aW5nLmh0bWwjcG90ZW50aWFsY3VzdG9tZWxlbWVudG5hbWVcbiAqIHNraXBwaW5nIFxcdTEwMDAwLVxcdUVGRkZGIGR1ZSB0byBpdCBmcmVlemluZyB1cCBQaGFudG9tSlNcbiAqL1xudmFyIHVuaWNvZGVSZWdFeHAgPSAvYS16QS1aXFx1MDBCN1xcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwM0YtXFx1MjA0MFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRC87XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gbmV3IFJlZ0V4cCgoXCJbXlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiLiRfXFxcXGRdXCIpKTtcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcblVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xuKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG52YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xuVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5VQSAmJiAvcGhhbnRvbWpzLy50ZXN0KFVBKTtcblVBICYmIFVBLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLyk7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyID0gZmFsc2U7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCcsXG4gICdlcnJvckNhcHR1cmVkJyxcbiAgJ3NlcnZlclByZWZldGNoJ1xuXTtcblxuLyogICovXG5cblxuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHVwZGF0ZXMgYXN5bmNocm9ub3VzbHkuIEludGVuZGVkIHRvIGJlIHVzZWQgYnkgVnVlIFRlc3QgVXRpbHNcbiAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cbiAgICovXG4gIGFzeW5jOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pO1xuXG4vKiAgKi9cblxudmFyIHdhcm4kMSA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuJDEgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm07XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQkMSA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQkMSgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkJDIrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSQyKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XG4gICAgLy8gc3VicyBhcmVuJ3Qgc29ydGVkIGluIHNjaGVkdWxlciBpZiBub3QgcnVubmluZyBhc3luY1xuICAgIC8vIHdlIG5lZWQgdG8gc29ydCB0aGVtIG5vdyB0byBtYWtlIHN1cmUgdGhleSBmaXJlIGluIGNvcnJlY3RcbiAgICAvLyBvcmRlclxuICAgIHN1YnMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyBUaGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyBUaGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIG9ubHkgb25lIHdhdGNoZXJcbi8vIGNhbiBiZSBldmFsdWF0ZWQgYXQgYSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAodGFyZ2V0KSB7XG4gIHRhcmdldFN0YWNrLnB1c2godGFyZ2V0KTtcbiAgRGVwLnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgdGFyZ2V0U3RhY2sucG9wKCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFja1t0YXJnZXRTdGFjay5sZW5ndGggLSAxXTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zLFxuICBhc3luY0ZhY3Rvcnlcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQyID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzJDIuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDIgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICAvLyAjNzk3NVxuICAgIC8vIGNsb25lIGNoaWxkcmVuIGFycmF5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGluIGNhc2Ugb2YgY2xvbmluZ1xuICAgIC8vIGEgY2hpbGQuXG4gICAgdm5vZGUuY2hpbGRyZW4gJiYgdm5vZGUuY2hpbGRyZW4uc2xpY2UoKSxcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmFzeW5jTWV0YSA9IHZub2RlLmFzeW5jTWV0YTtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1xuXG52YXIgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dO1xuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAqL1xudmFyIHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgIHByb3RvQXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29weUF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZShvYmosIGtleXNbaV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QkMSh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QkMSh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuICBpZiAoKCFnZXR0ZXIgfHwgc2V0dGVyKSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFsID0gb2JqW2tleV07XG4gIH1cblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIC8vICM3OTgxOiBmb3IgYWNjZXNzb3IgcHJvcGVydGllcyB3aXRob3V0IHNldHRlclxuICAgICAgaWYgKGdldHRlciAmJiAhc2V0dGVyKSB7IHJldHVybiB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCQxICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuJDEoKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDEoXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSlcbiAgKSB7XG4gICAgd2FybiQxKChcIkNhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQxKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcblxuICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgID8gUmVmbGVjdC5vd25LZXlzKGZyb20pXG4gICAgOiBPYmplY3Qua2V5cyhmcm9tKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIC8vIGluIGNhc2UgdGhlIG9iamVjdCBpcyBhbHJlYWR5IG9ic2VydmVkLi4uXG4gICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIHsgY29udGludWUgfVxuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQkMSh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdG9WYWwgIT09IGZyb21WYWwgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QkMSh0b1ZhbCkgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QkMShmcm9tVmFsKVxuICAgICkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMShcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHZhciByZXMgPSBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWw7XG4gIHJldHVybiByZXNcbiAgICA/IGRlZHVwZUhvb2tzKHJlcylcbiAgICA6IHJlc1xufVxuXG5mdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlcy5pbmRleE9mKGhvb2tzW2ldKSA9PT0gLTEpIHtcbiAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2skMTtcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcbiAgaWYgKCFuZXcgUmVnRXhwKChcIl5bYS16QS1aXVtcXFxcLVxcXFwuMC05X1wiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiXSokXCIpKS50ZXN0KG5hbWUpKSB7XG4gICAgd2FybiQxKFxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICdzaG91bGQgY29uZm9ybSB0byB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lIGluIGh0bWw1IHNwZWNpZmljYXRpb24uJ1xuICAgICk7XG4gIH1cbiAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xuICAgIHdhcm4kMShcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybiQxKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QkMShwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QkMSh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMShcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShwcm9wcykpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucywgdm0pIHtcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxuICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCQxKGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0JDEodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMShcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJpbmplY3RcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlIChuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0JDEodmFsdWUpKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICBub3JtYWxpemVEaXJlY3RpdmVzJDEoY2hpbGQpO1xuXG4gIC8vIEFwcGx5IGV4dGVuZHMgYW5kIG1peGlucyBvbiB0aGUgY2hpbGQgb3B0aW9ucyxcbiAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxuICAvLyB0aGUgcmVzdWx0IG9mIGFub3RoZXIgbWVyZ2VPcHRpb25zIGNhbGwuXG4gIC8vIE9ubHkgbWVyZ2VkIG9wdGlvbnMgaGFzIHRoZSBfYmFzZSBwcm9wZXJ0eS5cbiAgaWYgKCFjaGlsZC5fYmFzZSkge1xuICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgfVxuICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybiQxKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBib29sZWFuIGNhc3RpbmdcbiAgdmFyIGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcbiAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxuICAgICAgLy8gYm9vbGVhbiBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgICB2YXIgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gIH1cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAvLyBza2lwIHZhbGlkYXRpb24gZm9yIHdlZXggcmVjeWNsZS1saXN0IGNoaWxkIGNvbXBvbmVudCBwcm9wc1xuICAgICEoZmFsc2UgIClcbiAgKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0JDEoZGVmKSkge1xuICAgIHdhcm4kMShcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybiQxKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuJDEoXG4gICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCQxKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1NhbWVUeXBlIChhLCBiKSB7XG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UgKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gIHZhciBtZXNzYWdlID0gXCJJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuXCIgK1xuICAgIFwiIEV4cGVjdGVkIFwiICsgKGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgdmFyIHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XG4gIHZhciBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxuICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IFwiIHdpdGggdmFsdWUgXCIgKyBleHBlY3RlZFZhbHVlO1xuICB9XG4gIG1lc3NhZ2UgKz0gXCIsIGdvdCBcIiArIHJlY2VpdmVkVHlwZSArIFwiIFwiO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcbiAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBcIndpdGggdmFsdWUgXCIgKyByZWNlaXZlZFZhbHVlICsgXCIuXCI7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2Vcbn1cblxuZnVuY3Rpb24gc3R5bGVWYWx1ZSAodmFsdWUsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgcmV0dXJuIChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoTnVtYmVyKHZhbHVlKSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlICh2YWx1ZSkge1xuICB2YXIgZXhwbGljaXRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XG4gIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW07IH0pXG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbiAoKSB7XG4gIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgcmV0dXJuIGFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbic7IH0pXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICAvLyBEZWFjdGl2YXRlIGRlcHMgdHJhY2tpbmcgd2hpbGUgcHJvY2Vzc2luZyBlcnJvciBoYW5kbGVyIHRvIGF2b2lkIHBvc3NpYmxlIGluZmluaXRlIHJlbmRlcmluZy5cbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVleC9pc3N1ZXMvMTUwNVxuICBwdXNoVGFyZ2V0KCk7XG4gIHRyeSB7XG4gICAgaWYgKHZtKSB7XG4gICAgICB2YXIgY3VyID0gdm07XG4gICAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG4gIH0gZmluYWxseSB7XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcgKFxuICBoYW5kbGVyLFxuICBjb250ZXh0LFxuICBhcmdzLFxuICB2bSxcbiAgaW5mb1xuKSB7XG4gIHZhciByZXM7XG4gIHRyeSB7XG4gICAgcmVzID0gYXJncyA/IGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncykgOiBoYW5kbGVyLmNhbGwoY29udGV4dCk7XG4gICAgaWYgKHJlcyAmJiAhcmVzLl9pc1Z1ZSAmJiBpc1Byb21pc2UocmVzKSAmJiAhcmVzLl9oYW5kbGVkKSB7XG4gICAgICByZXMuY2F0Y2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvICsgXCIgKFByb21pc2UvYXN5bmMpXCIpOyB9KTtcbiAgICAgIC8vIGlzc3VlICM5NTExXG4gICAgICAvLyBhdm9pZCBjYXRjaCB0cmlnZ2VyaW5nIG11bHRpcGxlIHRpbWVzIHdoZW4gbmVzdGVkIGNhbGxzXG4gICAgICByZXMuX2hhbmRsZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZiB0aGUgdXNlciBpbnRlbnRpb25hbGx5IHRocm93cyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gdGhlIGhhbmRsZXIsXG4gICAgICAvLyBkbyBub3QgbG9nIGl0IHR3aWNlXG4gICAgICBpZiAoZSAhPT0gZXJyKSB7XG4gICAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMSgoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgY2FsbGJhY2tzID0gW107XG52YXIgcGVuZGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxuLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XG4vLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXG4vLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXG4vLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Ncbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxuLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG52YXIgdGltZXJGdW5jO1xuXG4vLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbi8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4vLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4vLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIEluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbn0gZWxzZSBpZiAoIWlzSUUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbikpIHtcbiAgLy8gVXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgLy8gZS5nLiBQaGFudG9tSlMsIGlPUzcsIEFuZHJvaWQgNC40XG4gIC8vICgjNjQ2NiBNdXRhdGlvbk9ic2VydmVyIGlzIHVucmVsaWFibGUgaW4gSUUxMSlcbiAgdmFyIGNvdW50ZXIgPSAxO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaENhbGxiYWNrcyk7XG4gIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gIH0pO1xuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgLy8gRmFsbGJhY2sgdG8gc2V0SW1tZWRpYXRlLlxuICAvLyBUZWNobmljYWxseSBpdCBsZXZlcmFnZXMgdGhlIChtYWNybykgdGFzayBxdWV1ZSxcbiAgLy8gYnV0IGl0IGlzIHN0aWxsIGEgYmV0dGVyIGNob2ljZSB0aGFuIHNldFRpbWVvdXQuXG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gRmFsbGJhY2sgdG8gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayAoY2IsIGN0eCkge1xuICB2YXIgX3Jlc29sdmU7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9yZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZShjdHgpO1xuICAgIH1cbiAgfSk7XG4gIGlmICghcGVuZGluZykge1xuICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgIHRpbWVyRnVuYygpO1xuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pXG4gIH1cbn1cblxuLyogICovXG5cbnZhciByZWYkMSA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFpc0RlZihrZXkpKSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZSQyKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QkMSh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXgkMSA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXgkMSA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXG52YXIgZ2V0Tm93ID0gRGF0ZS5ub3c7XG5cbi8vIERldGVybWluZSB3aGF0IGV2ZW50IHRpbWVzdGFtcCB0aGUgYnJvd3NlciBpcyB1c2luZy4gQW5ub3lpbmdseSwgdGhlXG4vLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xuLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXG4vLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXG4vLyBBbGwgSUUgdmVyc2lvbnMgdXNlIGxvdy1yZXMgZXZlbnQgdGltZXN0YW1wcywgYW5kIGhhdmUgcHJvYmxlbWF0aWMgY2xvY2tcbi8vIGltcGxlbWVudGF0aW9ucyAoIzk2MzIpXG5pZiAoaW5Ccm93c2VyICYmICFpc0lFKSB7XG4gIHZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgaWYgKFxuICAgIHBlcmZvcm1hbmNlICYmXG4gICAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGdldE5vdygpID4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JykudGltZVN0YW1wXG4gICkge1xuICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcbiAgICAvLyBzbWFsbGVyIHRoYW4gaXQsIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXIgdGltZXN0YW1wcyBhc1xuICAgIC8vIHdlbGwuXG4gICAgZ2V0Tm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7IH07XG4gIH1cbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGdldE5vdygpO1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4JDEgPSAwOyBpbmRleCQxIDwgcXVldWUubGVuZ3RoOyBpbmRleCQxKyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXgkMV07XG4gICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgIH1cbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICB3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgPyAoXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3YXRjaGVyLnZtXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxuICB2YXIgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICB2YXIgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcblxuICByZXNldFNjaGVkdWxlclN0YXRlKCk7XG5cbiAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXG4gIGNhbGxBY3RpdmF0ZWRIb29rcyhhY3RpdmF0ZWRRdWV1ZSk7XG4gIGNhbGxVcGRhdGVkSG9va3ModXBkYXRlZFF1ZXVlKTtcblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChnbG9iYWwuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBnbG9iYWwuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5lbWl0KCdmbHVzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIHZhciBpID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGNhbGxIb29rJDEodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4JDEgJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25maWcuYXN5bmMpIHtcbiAgICAgICAgZmx1c2hTY2hlZHVsZXJRdWV1ZSgpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbnZhciB1aWQkMSA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9ucyxcbiAgaXNSZW5kZXJXYXRjaGVyXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICB9XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gICAgdGhpcy5iZWZvcmUgPSBvcHRpb25zLmJlZm9yZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQxOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IG5vb3A7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMShcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgIH1cbiAgICBwb3BUYXJnZXQoKTtcbiAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCQxKHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSQyKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIC8vIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKVxuICAgIH07XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMsIHZtKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjbG9uZWRbaV0sIG51bGwsIGFyZ3VtZW50cyQxLCB2bSwgXCJ2LW9uIGhhbmRsZXJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSxcbiAgY3JlYXRlT25jZUhhbmRsZXIsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoaXNVbmRlZihjdXIpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMShcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIsIHZtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RydWUoZXZlbnQub25jZSkpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlJDIoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXG4gICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIHdhcm5SZXNlcnZlZFByZWZpeCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4kMShcbiAgICAgIFwiUHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIG11c3QgYmUgYWNjZXNzZWQgd2l0aCBcXFwiJGRhdGEuXCIgKyBrZXkgKyBcIlxcXCIgYmVjYXVzZSBcIiArXG4gICAgICAncHJvcGVydGllcyBzdGFydGluZyB3aXRoIFwiJFwiIG9yIFwiX1wiIGFyZSBub3QgcHJveGllZCBpbiB0aGUgVnVlIGluc3RhbmNlIHRvICcgK1xuICAgICAgJ3ByZXZlbnQgY29uZmxpY3RzIHdpdGggVnVlIGludGVybmFscy4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9hcGkvI2RhdGEnLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJveHkpO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybiQxKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJiAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICBlbHNlIHsgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHMkMSh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQkMSh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgaWYgKCFpc1Jvb3QpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICB9XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIChcIlxcXCJcIiArIGh5cGhlbmF0ZWRLZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jvb3QgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdCQxKGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQxKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQxKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgZGF0YSBnZXR0ZXJzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgd2FybiQxKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybiQxKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuJDEoKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXG4gIHRhcmdldCxcbiAga2V5LFxuICB1c2VyRGVmXG4pIHtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgIDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmLmdldClcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXQgfHwgbm9vcDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlckludm9rZXIoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgdHlwZSBcXFwiXCIgKyAodHlwZW9mIG1ldGhvZHNba2V5XSkgKyBcIlxcXCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoKGtleSBpbiB2bSkgJiYgaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kJDEobWV0aG9kc1trZXldLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBoYW5kbGVyLFxuICBvcHRpb25zXG4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QkMShoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybiQxKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybiQxKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0JDE7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdCQxKGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IsIHZtLCAoXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgaGFzT3duKHNvdXJjZS5fcHJvdmlkZWQsIHByb3ZpZGVLZXkpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybiQxKChcIkluamVjdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbm90IGZvdW5kXCIpLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCsrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rJDEodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rJDEodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcblxuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcblxuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBsYXRlc3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbi8qICAqL1xuXG5cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHJldHVybiB7fVxuICB9XG4gIHZhciBzbG90cyA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgfVxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgZm9yICh2YXIgbmFtZSQxIGluIHNsb3RzKSB7XG4gICAgaWYgKHNsb3RzW25hbWUkMV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90cyAoXG4gIHNsb3RzLFxuICBub3JtYWxTbG90cyxcbiAgcHJldlNsb3RzXG4pIHtcbiAgdmFyIHJlcztcbiAgdmFyIGhhc05vcm1hbFNsb3RzID0gT2JqZWN0LmtleXMobm9ybWFsU2xvdHMpLmxlbmd0aCA+IDA7XG4gIHZhciBpc1N0YWJsZSA9IHNsb3RzID8gISFzbG90cy4kc3RhYmxlIDogIWhhc05vcm1hbFNsb3RzO1xuICB2YXIga2V5ID0gc2xvdHMgJiYgc2xvdHMuJGtleTtcbiAgaWYgKCFzbG90cykge1xuICAgIHJlcyA9IHt9O1xuICB9IGVsc2UgaWYgKHNsb3RzLl9ub3JtYWxpemVkKSB7XG4gICAgLy8gZmFzdCBwYXRoIDE6IGNoaWxkIGNvbXBvbmVudCByZS1yZW5kZXIgb25seSwgcGFyZW50IGRpZCBub3QgY2hhbmdlXG4gICAgcmV0dXJuIHNsb3RzLl9ub3JtYWxpemVkXG4gIH0gZWxzZSBpZiAoXG4gICAgaXNTdGFibGUgJiZcbiAgICBwcmV2U2xvdHMgJiZcbiAgICBwcmV2U2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmXG4gICAga2V5ID09PSBwcmV2U2xvdHMuJGtleSAmJlxuICAgICFoYXNOb3JtYWxTbG90cyAmJlxuICAgICFwcmV2U2xvdHMuJGhhc05vcm1hbFxuICApIHtcbiAgICAvLyBmYXN0IHBhdGggMjogc3RhYmxlIHNjb3BlZCBzbG90cyB3LyBubyBub3JtYWwgc2xvdHMgdG8gcHJveHksXG4gICAgLy8gb25seSBuZWVkIHRvIG5vcm1hbGl6ZSBvbmNlXG4gICAgcmV0dXJuIHByZXZTbG90c1xuICB9IGVsc2Uge1xuICAgIHJlcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSQxIGluIHNsb3RzKSB7XG4gICAgICBpZiAoc2xvdHNba2V5JDFdICYmIGtleSQxWzBdICE9PSAnJCcpIHtcbiAgICAgICAgcmVzW2tleSQxXSA9IG5vcm1hbGl6ZVNjb3BlZFNsb3Qobm9ybWFsU2xvdHMsIGtleSQxLCBzbG90c1trZXkkMV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBleHBvc2Ugbm9ybWFsIHNsb3RzIG9uIHNjb3BlZFNsb3RzXG4gIGZvciAodmFyIGtleSQyIGluIG5vcm1hbFNsb3RzKSB7XG4gICAgaWYgKCEoa2V5JDIgaW4gcmVzKSkge1xuICAgICAgcmVzW2tleSQyXSA9IHByb3h5Tm9ybWFsU2xvdChub3JtYWxTbG90cywga2V5JDIpO1xuICAgIH1cbiAgfVxuICAvLyBhdm9yaWF6IHNlZW1zIHRvIG1vY2sgYSBub24tZXh0ZW5zaWJsZSAkc2NvcGVkU2xvdHMgb2JqZWN0XG4gIC8vIGFuZCB3aGVuIHRoYXQgaXMgcGFzc2VkIGRvd24gdGhpcyB3b3VsZCBjYXVzZSBhbiBlcnJvclxuICBpZiAoc2xvdHMgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShzbG90cykpIHtcbiAgICAoc2xvdHMpLl9ub3JtYWxpemVkID0gcmVzO1xuICB9XG4gIGRlZihyZXMsICckc3RhYmxlJywgaXNTdGFibGUpO1xuICBkZWYocmVzLCAnJGtleScsIGtleSk7XG4gIGRlZihyZXMsICckaGFzTm9ybWFsJywgaGFzTm9ybWFsU2xvdHMpO1xuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3Qobm9ybWFsU2xvdHMsIGtleSwgZm4pIHtcbiAgdmFyIG5vcm1hbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPyBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpIDogZm4oe30pO1xuICAgIHJlcyA9IHJlcyAmJiB0eXBlb2YgcmVzID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShyZXMpXG4gICAgICA/IFtyZXNdIC8vIHNpbmdsZSB2bm9kZVxuICAgICAgOiBub3JtYWxpemVDaGlsZHJlbihyZXMpO1xuICAgIHJldHVybiByZXMgJiYgKFxuICAgICAgcmVzLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgKHJlcy5sZW5ndGggPT09IDEgJiYgcmVzWzBdLmlzQ29tbWVudCkgLy8gIzk2NThcbiAgICApID8gdW5kZWZpbmVkXG4gICAgICA6IHJlc1xuICB9O1xuICAvLyB0aGlzIGlzIGEgc2xvdCB1c2luZyB0aGUgbmV3IHYtc2xvdCBzeW50YXggd2l0aG91dCBzY29wZS4gYWx0aG91Z2ggaXQgaXNcbiAgLy8gY29tcGlsZWQgYXMgYSBzY29wZWQgc2xvdCwgcmVuZGVyIGZuIHVzZXJzIHdvdWxkIGV4cGVjdCBpdCB0byBiZSBwcmVzZW50XG4gIC8vIG9uIHRoaXMuJHNsb3RzIGJlY2F1c2UgdGhlIHVzYWdlIGlzIHNlbWFudGljYWxseSBhIG5vcm1hbCBzbG90LlxuICBpZiAoZm4ucHJveHkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ybWFsU2xvdHMsIGtleSwge1xuICAgICAgZ2V0OiBub3JtYWxpemVkLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkXG59XG5cbmZ1bmN0aW9uIHByb3h5Tm9ybWFsU2xvdChzbG90cywga2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzbG90c1trZXldOyB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCQxKHZhbCkpIHtcbiAgICBpZiAoaGFzU3ltYm9sICYmIHZhbFtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICByZXQgPSBbXTtcbiAgICAgIHZhciBpdGVyYXRvciA9IHZhbFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICByZXQucHVzaChyZW5kZXIocmVzdWx0LnZhbHVlLCByZXQubGVuZ3RoKSk7XG4gICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc0RlZihyZXQpKSB7XG4gICAgcmV0ID0gW107XG4gIH1cbiAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIHZhciBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc09iamVjdCQxKGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICAnc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICBub2RlcyA9IHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2s7XG4gIH0gZWxzZSB7XG4gICAgbm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXSB8fCBmYWxsYmFjaztcbiAgfVxuXG4gIHZhciB0YXJnZXQgPSBwcm9wcyAmJiBwcm9wcy5zbG90O1xuICBpZiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJywgeyBzbG90OiB0YXJnZXQgfSwgbm9kZXMpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGVzXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzS2V5Tm90TWF0Y2ggKGV4cGVjdCwgYWN0dWFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdCkpIHtcbiAgICByZXR1cm4gZXhwZWN0LmluZGV4T2YoYWN0dWFsKSA9PT0gLTFcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXhwZWN0ICE9PSBhY3R1YWxcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xuICogcGFzc2luZyBpbiBldmVudEtleU5hbWUgYXMgbGFzdCBhcmd1bWVudCBzZXBhcmF0ZWx5IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbktleUNvZGUsXG4gIGV2ZW50S2V5TmFtZSxcbiAgYnVpbHRJbktleU5hbWVcbikge1xuICB2YXIgbWFwcGVkS2V5Q29kZSA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5LZXlDb2RlO1xuICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWcua2V5Q29kZXNba2V5XSkge1xuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKGJ1aWx0SW5LZXlOYW1lLCBldmVudEtleU5hbWUpXG4gIH0gZWxzZSBpZiAobWFwcGVkS2V5Q29kZSkge1xuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKG1hcHBlZEtleUNvZGUsIGV2ZW50S2V5Q29kZSlcbiAgfSBlbHNlIGlmIChldmVudEtleU5hbWUpIHtcbiAgICByZXR1cm4gaHlwaGVuYXRlKGV2ZW50S2V5TmFtZSkgIT09IGtleVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gIGRhdGEsXG4gIHRhZyxcbiAgdmFsdWUsXG4gIGFzUHJvcCxcbiAgaXNTeW5jXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCQxKHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDEoXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0JDEodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAga2V5ID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXG4gICAgICAgICkge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgICAgaWYgKCEoY2FtZWxpemVkS2V5IGluIGhhc2gpICYmICEoaHlwaGVuYXRlZEtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgbnVsbCxcbiAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICk7XG4gIG1hcmtTdGF0aWMkMSh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWMkMSh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0JDEodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMShcbiAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlcyxcbiAgLy8gdGhlIGZvbGxvd2luZyBhcmUgYWRkZWQgaW4gMi42XG4gIGhhc0R5bmFtaWNLZXlzLFxuICBjb250ZW50SGFzaEtleVxuKSB7XG4gIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzbG90ID0gZm5zW2ldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNsb3QpKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoc2xvdCwgcmVzLCBoYXNEeW5hbWljS2V5cyk7XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICAvLyBtYXJrZXIgZm9yIHJldmVyc2UgcHJveHlpbmcgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICAgIGlmIChzbG90LnByb3h5KSB7XG4gICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmVzW3Nsb3Qua2V5XSA9IHNsb3QuZm47XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50SGFzaEtleSkge1xuICAgIChyZXMpLiRrZXkgPSBjb250ZW50SGFzaEtleTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMgKGJhc2VPYmosIHZhbHVlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBrZXkgPSB2YWx1ZXNbaV07XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleSkge1xuICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYga2V5ICE9PSAnJyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIC8vIG51bGwgaXMgYSBzcGVjaWFsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xuICAgICAgd2FybiQxKFxuICAgICAgICAoXCJJbnZhbGlkIHZhbHVlIGZvciBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCAoZXhwZWN0ZWQgc3RyaW5nIG9yIG51bGwpOiBcIiArIGtleSksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlT2JqXG59XG5cbi8vIGhlbHBlciB0byBkeW5hbWljYWxseSBhcHBlbmQgbW9kaWZpZXIgcnVudGltZSBtYXJrZXJzIHRvIGV2ZW50IG5hbWVzLlxuLy8gZW5zdXJlIG9ubHkgYXBwZW5kIHdoZW4gdmFsdWUgaXMgYWxyZWFkeSBzdHJpbmcsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGNhc3Rcbi8vIHRvIHN0cmluZyBhbmQgY2F1c2UgdGhlIHR5cGUgY2hlY2sgdG8gbWlzcy5cbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllciAodmFsdWUsIHN5bWJvbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHN5bWJvbCArIHZhbHVlIDogdmFsdWVcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG4gIHRhcmdldC5fZCA9IGJpbmREeW5hbWljS2V5cztcbiAgdGFyZ2V0Ll9wID0gcHJlcGVuZE1vZGlmaWVyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgKFxuICBkYXRhLFxuICBwcm9wcyxcbiAgY2hpbGRyZW4sXG4gIHBhcmVudCxcbiAgQ3RvclxuKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgdmFyIGNvbnRleHRWbTtcbiAgaWYgKGhhc093bihwYXJlbnQsICdfdWlkJykpIHtcbiAgICBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgY29udGV4dFZtLl9vcmlnaW5hbCA9IHBhcmVudDtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cbiAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYXJlIGFibGUgdG8gZ2V0IGEgaG9sZCB0byB0aGVcbiAgICAvLyByZWFsIGNvbnRleHQgaW5zdGFuY2UuXG4gICAgY29udGV4dFZtID0gcGFyZW50O1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHBhcmVudCA9IHBhcmVudC5fb3JpZ2luYWw7XG4gIH1cbiAgdmFyIGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xuICB2YXIgbmVlZE5vcm1hbGl6YXRpb24gPSAhaXNDb21waWxlZDtcblxuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcbiAgdGhpcy5zbG90cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMkMS4kc2xvdHMpIHtcbiAgICAgIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKFxuICAgICAgICBkYXRhLnNjb3BlZFNsb3RzLFxuICAgICAgICB0aGlzJDEuJHNsb3RzID0gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcyQxLiRzbG90c1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2NvcGVkU2xvdHMnLCAoe1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuc2xvdHMoKSlcbiAgICB9XG4gIH0pKTtcblxuICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChpc0NvbXBpbGVkKSB7XG4gICAgLy8gZXhwb3NpbmcgJG9wdGlvbnMgZm9yIHJlbmRlclN0YXRpYygpXG4gICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gcHJlLXJlc29sdmUgc2xvdHMgZm9yIHJlbmRlclNsb3QoKVxuICAgIHRoaXMuJHNsb3RzID0gdGhpcy5zbG90cygpO1xuICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy4kc2xvdHMpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQkMShjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQkMShjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG5cbiAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zLCByZW5kZXJDb250ZXh0KSB7XG4gIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAoY2xvbmUuZGV2dG9vbHNNZXRhID0gY2xvbmUuZGV2dG9vbHNNZXRhIHx8IHt9KS5yZW5kZXJDb250ZXh0ID0gcmVuZGVyQ29udGV4dDtcbiAgfVxuICBpZiAoZGF0YS5zbG90KSB7XG4gICAgKGNsb25lLmRhdGEgfHwgKGNsb25lLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIGlmIChcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayQxKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdCQxKEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybiQxKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgdmFyIGFzeW5jRmFjdG9yeTtcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IpO1xuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgZGF0YSA9IHt9O1xuICAgIGlmIChzbG90KSB7XG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50IC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIHBhcmVudDogcGFyZW50XG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZXhpc3RpbmcgPSBob29rc1trZXldO1xuICAgIHZhciB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGlmIChleGlzdGluZyAhPT0gdG9NZXJnZSAmJiAhKGV4aXN0aW5nICYmIGV4aXN0aW5nLl9tZXJnZWQpKSB7XG4gICAgICBob29rc1trZXldID0gZXhpc3RpbmcgPyBtZXJnZUhvb2sodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rIChmMSwgZjIpIHtcbiAgdmFyIG1lcmdlZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgLy8gZmxvdyBjb21wbGFpbnMgYWJvdXQgZXh0cmEgYXJncyB3aGljaCBpcyB3aHkgd2UgdXNlIGFueVxuICAgIGYxKGEsIGIpO1xuICAgIGYyKGEsIGIpO1xuICB9O1xuICBtZXJnZWQuX21lcmdlZCA9IHRydWU7XG4gIHJldHVybiBtZXJnZWRcbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0J1xuICA7KGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgdmFyIGV4aXN0aW5nID0gb25bZXZlbnRdO1xuICB2YXIgY2FsbGJhY2sgPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICBpZiAoaXNEZWYoZXhpc3RpbmcpKSB7XG4gICAgaWYgKFxuICAgICAgQXJyYXkuaXNBcnJheShleGlzdGluZylcbiAgICAgICAgPyBleGlzdGluZy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTFcbiAgICAgICAgOiBleGlzdGluZyAhPT0gY2FsbGJhY2tcbiAgICApIHtcbiAgICAgIG9uW2V2ZW50XSA9IFtjYWxsYmFja10uY29uY2F0KGV4aXN0aW5nKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxIChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDEoXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybiQxKFxuICAgICAgICAnQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xuICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5uYXRpdmVPbikpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIChcIlRoZSAubmF0aXZlIG1vZGlmaWVyIGZvciB2LW9uIGlzIG9ubHkgdmFsaWQgb24gY29tcG9uZW50cyBidXQgaXQgd2FzIHVzZWQgb24gPFwiICsgdGFnICsgXCI+LlwiKSxcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCghZGF0YSB8fCAhZGF0YS5wcmUpICYmIGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAoaXNEZWYobnMpKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIGlmIChpc0RlZihkYXRhKSkgeyByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMsIGZvcmNlKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIG5zID0gdW5kZWZpbmVkO1xuICAgIGZvcmNlID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgKFxuICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gcmVmICM1MzE4XG4vLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHBhcmVudCByZS1yZW5kZXIgd2hlbiBkZWVwIGJpbmRpbmdzIGxpa2UgOnN0eWxlIGFuZFxuLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XG4gIGlmIChpc09iamVjdCQxKGRhdGEuc3R5bGUpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5zdHlsZSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0JDEoZGF0YS5jbGFzcykpIHtcbiAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCQxKHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCQxKHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4kMShcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuJDEoXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gIH1cbn1cblxudmFyIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgdm0uJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLFxuICAgICAgICB2bS4kc2xvdHMsXG4gICAgICAgIHZtLiRzY29wZWRTbG90c1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gbWFpbnRhaW4gYSBzdGFjayBiZWNhdXNlIGFsbCByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgIC8vIHNlcGFyYXRlbHkgZnJvbSBvbmUgYW5vdGhlci4gTmVzdGVkIGNvbXBvbmVudCdzIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gd2hlbiBwYXJlbnQgY29tcG9uZW50IGlzIHBhdGNoZWQuXG4gICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSB2bTtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICB9IGNhdGNoIChlJDEpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlJDEsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkgJiYgdm5vZGUubGVuZ3RoID09PSAxKSB7XG4gICAgICB2bm9kZSA9IHZub2RlWzBdO1xuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QkMShjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvclxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgdmFyIG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAob3duZXIgJiYgaXNEZWYoZmFjdG9yeS5vd25lcnMpICYmIGZhY3Rvcnkub3duZXJzLmluZGV4T2Yob3duZXIpID09PSAtMSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3Rvcnkub3duZXJzLnB1c2gob3duZXIpO1xuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChvd25lciAmJiAhaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgdmFyIG93bmVycyA9IGZhY3Rvcnkub3duZXJzID0gW293bmVyXTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG4gICAgdmFyIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgdmFyIHRpbWVyVGltZW91dCA9IG51bGxcblxuICAgIDsob3duZXIpLiRvbignaG9vazpkZXN0cm95ZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1vdmUkMihvd25lcnMsIG93bmVyKTsgfSk7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG93bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgKG93bmVyc1tpXSkuJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmICh0aW1lckxvYWRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJMb2FkaW5nKTtcbiAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lclRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJUaW1lb3V0KTtcbiAgICAgICAgICB0aW1lclRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDEoXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0JDEocmVzKSkge1xuICAgICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICB0aW1lclRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGFkZCQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0JDEuJG9uKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0JDEuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciQxIChldmVudCwgZm4pIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICBfdGFyZ2V0LiRvZmYoZXZlbnQsIG9uY2VIYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0JDEgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQkMSwgcmVtb3ZlJDEsIGNyZWF0ZU9uY2VIYW5kbGVyJDEsIHZtKTtcbiAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdm0uJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB2bS4kb2ZmKGV2ZW50W2kkMV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgdmFyIGluZm8gPSBcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCI7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2JzW2ldLCB2bSwgYXJncywgdm0sIGluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHNldEFjdGl2ZUluc3RhbmNlKHZtKSB7XG4gIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHZtKTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyh2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2skMSh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUkMihwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2skMSh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rJDEodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwge1xuICAgIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlICgpIHtcbiAgICAgIGlmICh2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayQxKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxuXG4gIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBkeW5hbWljIHNjb3BlZFNsb3RzIChoYW5kLXdyaXR0ZW4gb3IgY29tcGlsZWQgYnV0IHdpdGhcbiAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcbiAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICB2YXIgbmV3U2NvcGVkU2xvdHMgPSBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzO1xuICB2YXIgb2xkU2NvcGVkU2xvdHMgPSB2bS4kc2NvcGVkU2xvdHM7XG4gIHZhciBoYXNEeW5hbWljU2NvcGVkU2xvdCA9ICEhKFxuICAgIChuZXdTY29wZWRTbG90cyAmJiAhbmV3U2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAob2xkU2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmICFvbGRTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgIChuZXdTY29wZWRTbG90cyAmJiB2bS4kc2NvcGVkU2xvdHMuJGtleSAhPT0gbmV3U2NvcGVkU2xvdHMuJGtleSlcbiAgKTtcblxuICAvLyBBbnkgc3RhdGljIHNsb3QgY2hpbGRyZW4gZnJvbSB0aGUgcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgZHVyaW5nIHBhcmVudCdzXG4gIC8vIHVwZGF0ZS4gRHluYW1pYyBzY29wZWQgc2xvdHMgbWF5IGFsc28gaGF2ZSBjaGFuZ2VkLiBJbiBzdWNoIGNhc2VzLCBhIGZvcmNlZFxuICAvLyB1cGRhdGUgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBjb3JyZWN0bmVzcy5cbiAgdmFyIG5lZWRzRm9yY2VVcGRhdGUgPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIGhhc0R5bmFtaWNTY29wZWRTbG90XG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gIHZtLiRhdHRycyA9IHBhcmVudFZub2RlLmRhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgdmFyIHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cblxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcbiAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuXG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2skMSh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayQxKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxICh2bSwgaG9vaykge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgbGlmZWN5Y2xlIGhvb2tzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIHZhciBpbmZvID0gaG9vayArIFwiIGhvb2tcIjtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGhhbmRsZXJzW2ldLCB2bSwgbnVsbCwgdm0sIGluZm8pO1xuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbn1cblxuLyogICovXG5cbm1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxubWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHZub2RlLCBpblZQcmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWluVlByZSAmJlxuICAgICAgIXZub2RlLm5zICYmXG4gICAgICAhKFxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50KHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZikge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmKSkge1xuICAgICAgICBpZiAobm9kZU9wcy5wYXJlbnROb2RlKHJlZikgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaGlsZHJlbik7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUsIGNoaWxkcmVuLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodm5vZGUudGV4dCkpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmZuU2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgICB9XG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgIGkgIT09IHZub2RlLmZuQ29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBmYWxzZSwgdm5vZGVzLCBzdGFydElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAodm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKG5ld0NoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlS2V5cyAoY2hpbGRyZW4pIHtcbiAgICB2YXIgc2VlbktleXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIChcIkR1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnXCIgKyBrZXkgKyBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGMgPSBvbGRDaFtpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKFxuICAgIG9sZFZub2RlLFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4LFxuICAgIHJlbW92ZU9ubHlcbiAgKSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIGNsb25lIHJldXNlZCB2bm9kZVxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgIHZhciBpO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YSkgJiYgaXNEZWYoaSA9IGkuZG9tUHJvcHMpICYmIGlzRGVmKGkgPSBpLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCAoXG4gICAgICAgICFpc1Vua25vd25FbGVtZW50KHZub2RlLCBpblZQcmUpICYmXG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG51bGwsIG51bGwsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xuICAgICAgICAgIHJlbW92ZVZub2Rlcyhbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2soZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGRpci5vbGRBcmcgPSBvbGREaXIuYXJnO1xuICAgICAgY2FsbEhvb2soZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayhkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2soZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZiQxLFxuICBkaXJlY3RpdmVzJDFcbl07XG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEuYXR0cnMgJiYgIXZub2RlLmRhdGEuYXR0cnMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChhdHRycy5fX29iX18pIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgZWxtLnNldEF0dHJpYnV0ZShrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGF0dHJzW2tleV0gPT0gbnVsbCkge1xuICAgICAgZWxtLnNldEF0dHJpYnV0ZShrZXkpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QkMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3Mob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICAhZGF0YS5zdGF0aWNDbGFzcyAmJlxuICAgICFkYXRhLmNsYXNzICYmXG4gICAgKCFvbGREYXRhIHx8ICghb2xkRGF0YS5zdGF0aWNDbGFzcyAmJiAhb2xkRGF0YS5jbGFzcykpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKHRyYW5zaXRpb25DbGFzcykge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIgY2xhc3NfJDEgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0OyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIoKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICByZW1vdmUoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkKGV2ZW50LCBoYW5kbGVyLCBvbmNlLCBjYXB0dXJlKSB7XG4gIGlmIChjYXB0dXJlKSB7XG4gICAgY29uc29sZS5sb2coJ05hdGl2ZVNjcmlwdC1WdWUgZG8gbm90IHN1cHBvcnQgZXZlbnQgaW4gYnViYmxlIHBoYXNlLicpO1xuICAgIHJldHVyblxuICB9XG4gIGlmIChvbmNlKSB7XG4gICAgdmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgdmFyIHJlcyA9IG9sZEhhbmRsZXIuY2FsbC5hcHBseShvbGRIYW5kbGVyLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MgKSk7XG4gICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZShldmVudCwgbnVsbCwgbnVsbCwgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KSB7XG4gIGlmICggX3RhcmdldCA9PT0gdm9pZCAwICkgX3RhcmdldCA9IHRhcmdldDtcblxuICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5vbiAmJiAhdm5vZGUuZGF0YS5vbikge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCA9IHZub2RlLmVsbTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkLCByZW1vdmUsIGNyZWF0ZU9uY2VIYW5kbGVyLCB2bm9kZS5jb250ZXh0KTtcbiAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbnZhciBub3JtYWxpemUkMSA9IGNhY2hlZChjYW1lbGl6ZSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlKG9sZFZub2RlLCB2bm9kZSkge1xuICAvLyBjb25zb2xlLmxvZyhgXFx0XFx0ID09PT4gY3JlYXRlU3R5bGUoJHtvbGRWbm9kZX0sICR7dm5vZGV9KWApXG4gIGlmICghdm5vZGUuZGF0YS5zdGF0aWNTdHlsZSkge1xuICAgIHVwZGF0ZVN0eWxlKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIHN0YXRpY1N0eWxlID0gdm5vZGUuZGF0YS5zdGF0aWNTdHlsZTtcbiAgZm9yICh2YXIgbmFtZSBpbiBzdGF0aWNTdHlsZSkge1xuICAgIGlmIChzdGF0aWNTdHlsZVtuYW1lXSkge1xuICAgICAgZWxtLnNldFN0eWxlKG5vcm1hbGl6ZSQxKG5hbWUpLCBzdGF0aWNTdHlsZVtuYW1lXSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVN0eWxlKG9sZFZub2RlLCB2bm9kZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEuc3R5bGUgJiYgIXZub2RlLmRhdGEuc3R5bGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3R5bGUgPSBvbGRWbm9kZS5kYXRhLnN0eWxlIHx8IHt9O1xuICB2YXIgc3R5bGUgPSB2bm9kZS5kYXRhLnN0eWxlIHx8IHt9O1xuXG4gIHZhciBuZWVkQ2xvbmUgPSBzdHlsZS5fX29iX187XG5cbiAgLy8gaGFuZGxlIGFycmF5IHN5bnRheFxuICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkpIHtcbiAgICBzdHlsZSA9IHZub2RlLmRhdGEuc3R5bGUgPSB0b09iamVjdChzdHlsZSk7XG4gIH1cblxuICAvLyBjbG9uZSB0aGUgc3R5bGUgZm9yIGZ1dHVyZSB1cGRhdGVzLFxuICAvLyBpbiBjYXNlIHRoZSB1c2VyIG11dGF0ZXMgdGhlIHN0eWxlIG9iamVjdCBpbi1wbGFjZS5cbiAgaWYgKG5lZWRDbG9uZSkge1xuICAgIHN0eWxlID0gdm5vZGUuZGF0YS5zdHlsZSA9IGV4dGVuZCh7fSwgc3R5bGUpO1xuICB9XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKCFzdHlsZVtuYW1lXSkge1xuICAgICAgZWxtLnNldFN0eWxlKG5vcm1hbGl6ZSQxKG5hbWUpLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBzdHlsZSkge1xuICAgIGN1ciA9IHN0eWxlW25hbWVdO1xuICAgIGVsbS5zZXRTdHlsZShub3JtYWxpemUkMShuYW1lKSwgY3VyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0b09iamVjdChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIGNyZWF0ZTogY3JlYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG52YXIgd2hpdGVzcGFjZVJFJDEgPSAvXFxzKy87XG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFJDEpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUkMSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZi5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlJDIoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiBlbnRlcih2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcblxuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzID8gYXBwZWFyQ2xhc3MgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPVxuICAgIGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3MgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhciA/IGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlciA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbidcbiAgICAgID8gYXBwZWFyXG4gICAgICA6IGVudGVyXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXIgPyBhZnRlckFwcGVhciB8fCBhZnRlckVudGVyIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyBhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWRcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdCQxKGR1cmF0aW9uKSA/IGR1cmF0aW9uLmVudGVyIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2U7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IChlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pKTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9XG4gICAgICAgIHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAoXG4gICAgICAgIHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlO1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdCQxKGR1cmF0aW9uKSA/IGR1cmF0aW9uLmxlYXZlIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IChlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbihlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVtcbiAgICAgICAgdm5vZGUua2V5XG4gICAgICBdID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24odmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKSA/IGludm9rZXJGbnNbMF0gOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlcihfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtjbGFzc18kMSwgZXZlbnRzLCBhdHRycywgc3R5bGUkMSwgdHJhbnNpdGlvbl07XG5cbnZhciBhY3Rpb25CYXIgPSB7XG4gIHRlbXBsYXRlOiBcIlxcbiAgICA8TmF0aXZlQWN0aW9uQmFyIH5hY3Rpb25CYXIgdi1iaW5kPVxcXCIkYXR0cnNcXFwiIHYtb249XFxcIiRsaXN0ZW5lcnNcXFwiPlxcbiAgICAgIDxzbG90IC8+XFxuICAgIDwvTmF0aXZlQWN0aW9uQmFyPlxcbiAgXCJcbn07XG5cbnZhciBhbmRyb2lkID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCByZWYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG5cbiAgICBpZiAoZ2xvYmFsLmlzQW5kcm9pZCkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuXG4gICAgfVxuICB9XG59O1xuXG52YXIgZnJhbWVzID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBzZXRGcmFtZShpZCwgZnJhbWUpIHtcbiAgcmV0dXJuIGZyYW1lcy5zZXQoaWQsIGZyYW1lKVxufVxuXG5mdW5jdGlvbiBnZXRGcmFtZShpZCkge1xuICByZXR1cm4gZnJhbWVzLmdldChpZClcbn1cblxuZnVuY3Rpb24gZGVsZXRlRnJhbWUoaWQpIHtcbiAgcmV0dXJuIGZyYW1lcy5kZWxldGUoaWQpXG59XG5cbnZhciBmcmFtZSA9IHtcbiAgcHJvcHM6IHtcbiAgICBpZDoge1xuICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnXG4gICAgfSxcbiAgICB0cmFuc2l0aW9uOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgJ2lvczp0cmFuc2l0aW9uJzoge1xuICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0XSxcbiAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgICdhbmRyb2lkOnRyYW5zaXRpb24nOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgY2xlYXJIaXN0b3J5OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGJhY2tzdGFja1Zpc2libGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICAvLyBpbmplY3RlZCBieSB0aGUgdGVtcGxhdGUgY29tcGlsZXJcbiAgICBoYXNSb3V0ZXJWaWV3OiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvcGVydGllczoge31cbiAgICB9XG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4kYXR0cnMsIHRoaXMuJHByb3BzKTtcblxuICAgIHNldEZyYW1lKHRoaXMucHJvcGVydGllcy5pZCwgdGhpcyk7XG4gIH0sXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkKCkge1xuICAgIGRlbGV0ZUZyYW1lKHRoaXMucHJvcGVydGllcy5pZCk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICB2YXIgdm5vZGUgPSBudWxsO1xuXG4gICAgLy8gUmVuZGVyIHNsb3QgdG8gZW5zdXJlIGRlZmF1bHQgcGFnZSBpcyBkaXNwbGF5ZWRcbiAgICBpZiAodGhpcy4kc2xvdHMuZGVmYXVsdCkge1xuICAgICAgaWYgKFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgIHRoaXMuJHNsb3RzLmRlZmF1bHQubGVuZ3RoID4gMVxuICAgICAgKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBcIlRoZSA8RnJhbWU+IGVsZW1lbnQgY2FuIG9ubHkgaGF2ZSBhIHNpbmdsZSBjaGlsZCBlbGVtZW50LCB0aGF0IGlzIHRoZSBkZWZhdWx0UGFnZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSB0aGlzLiRzbG90cy5kZWZhdWx0WzBdO1xuICAgICAgdm5vZGUua2V5ID0gJ2RlZmF1bHQnO1xuICAgIH1cblxuICAgIHJldHVybiBoKFxuICAgICAgJ05hdGl2ZUZyYW1lJyxcbiAgICAgIHtcbiAgICAgICAgYXR0cnM6IHRoaXMucHJvcGVydGllcyxcbiAgICAgICAgb246IHRoaXMuJGxpc3RlbmVyc1xuICAgICAgfSxcbiAgICAgIFt2bm9kZV1cbiAgICApXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBfZ2V0RnJhbWU6IGZ1bmN0aW9uIF9nZXRGcmFtZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRlbC5uYXRpdmVWaWV3XG4gICAgfSxcblxuICAgIF9lbnN1cmVUcmFuc2l0aW9uT2JqZWN0OiBmdW5jdGlvbiBfZW5zdXJlVHJhbnNpdGlvbk9iamVjdCh0cmFuc2l0aW9uKSB7XG4gICAgICBpZiAodHlwZW9mIHRyYW5zaXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7IG5hbWU6IHRyYW5zaXRpb24gfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zaXRpb25cbiAgICB9LFxuXG4gICAgX2NvbXBvc2VUcmFuc2l0aW9uOiBmdW5jdGlvbiBfY29tcG9zZVRyYW5zaXRpb24oZW50cnkpIHtcbiAgICAgIHZhciBpc0FuZHJvaWQgPSBnbG9iYWwuaXNBbmRyb2lkO1xuICAgICAgdmFyIHBsYXRmb3JtRW50cnlQcm9wID0gXCJ0cmFuc2l0aW9uXCIgKyAoaXNBbmRyb2lkID8gJ0FuZHJvaWQnIDogJ2lPUycpO1xuICAgICAgdmFyIGVudHJ5UHJvcCA9IGVudHJ5W3BsYXRmb3JtRW50cnlQcm9wXVxuICAgICAgICA/IHBsYXRmb3JtRW50cnlQcm9wXG4gICAgICAgIDogJ3RyYW5zaXRpb24nO1xuICAgICAgdmFyIHBsYXRmb3JtUHJvcCA9IChpc0FuZHJvaWQgPyAnYW5kcm9pZCcgOiAnaW9zJykgKyBcIjp0cmFuc2l0aW9uXCI7XG4gICAgICB2YXIgcHJvcCA9IHRoaXNbcGxhdGZvcm1Qcm9wXSA/IHBsYXRmb3JtUHJvcCA6ICd0cmFuc2l0aW9uJztcblxuICAgICAgaWYgKGVudHJ5W2VudHJ5UHJvcF0pIHtcbiAgICAgICAgZW50cnlbZW50cnlQcm9wXSA9IHRoaXMuX2Vuc3VyZVRyYW5zaXRpb25PYmplY3QoZW50cnlbZW50cnlQcm9wXSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXNbcHJvcF0pIHtcbiAgICAgICAgZW50cnlbZW50cnlQcm9wXSA9IHRoaXMuX2Vuc3VyZVRyYW5zaXRpb25PYmplY3QodGhpc1twcm9wXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRyeVxuICAgIH0sXG5cbiAgICBub3RpZnlGaXJzdFBhZ2VNb3VudGVkOiBmdW5jdGlvbiBub3RpZnlGaXJzdFBhZ2VNb3VudGVkKHBhZ2VWbSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGJhY2tzdGFja1Zpc2libGU6IHRoaXMuYmFja3N0YWNrVmlzaWJsZSxcbiAgICAgICAgY2xlYXJIaXN0b3J5OiB0aGlzLmNsZWFySGlzdG9yeSxcbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYWdlVm0uJGVsLm5hdGl2ZVZpZXc7IH1cbiAgICAgIH07XG4gICAgICB0aGlzLm5hdmlnYXRlKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24gbmF2aWdhdGUoZW50cnksIGJhY2spIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgICAgaWYgKCBiYWNrID09PSB2b2lkIDAgKSBiYWNrID0gZmFsc2U7XG5cbiAgICAgIHZhciBmcmFtZSA9IHRoaXMuX2dldEZyYW1lKCk7XG5cbiAgICAgIGlmIChiYWNrKSB7XG4gICAgICAgIHJldHVybiBmcmFtZS5nb0JhY2soZW50cnkpXG4gICAgICB9XG5cbiAgICAgIC8vIHJlc29sdmUgdGhlIHBhZ2UgZnJvbSB0aGUgZW50cnkgYW5kIGF0dGFjaCBhIG5hdmlnYXRlZFRvIGxpc3RlbmVyXG4gICAgICAvLyB0byBmaXJlIHRoZSBmcmFtZSBldmVudHNcbiAgICAgIHZhciBwYWdlID0gZW50cnkuY3JlYXRlKCk7XG4gICAgICBwYWdlLm9uY2UoJ25hdmlnYXRlZFRvJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzJDEuJGVtaXQoJ25hdmlnYXRlZCcsIGVudHJ5KTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmlzQmFja05hdmlnYXRpb24pIHtcbiAgICAgICAgICBwYWdlLm9mZignbmF2aWdhdGVkRnJvbScsIGhhbmRsZXIpO1xuXG4gICAgICAgICAgdGhpcyQxLiRlbWl0KCduYXZpZ2F0ZWRCYWNrJywgZW50cnkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcGFnZS5vbignbmF2aWdhdGVkRnJvbScsIGhhbmRsZXIpO1xuXG4gICAgICBlbnRyeS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwYWdlOyB9O1xuXG4gICAgICB0aGlzLl9jb21wb3NlVHJhbnNpdGlvbihlbnRyeSk7XG4gICAgICBmcmFtZS5uYXZpZ2F0ZShlbnRyeSk7XG4gICAgfSxcblxuICAgIGJhY2s6IGZ1bmN0aW9uIGJhY2soYmFja3N0YWNrRW50cnkpIHtcbiAgICAgIGlmICggYmFja3N0YWNrRW50cnkgPT09IHZvaWQgMCApIGJhY2tzdGFja0VudHJ5ID0gbnVsbDtcblxuICAgICAgdGhpcy5uYXZpZ2F0ZShiYWNrc3RhY2tFbnRyeSwgdHJ1ZSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgaW9zID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCByZWYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG5cbiAgICBpZiAoZ2xvYmFsLmlzSU9TKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5cbiAgICB9XG4gIH1cbn07XG5cbnZhciBWVUVfVklFVyA9ICdfX3Z1ZVZOb2RlUmVmX18nO1xuXG52YXIgdGlkID0gMDtcbnZhciB2VGVtcGxhdGUkMSA9IHtcbiAgcHJvcHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuICAgIGlmOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICBpZiAoIXRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuJHRlbXBsYXRlcyA9IHRoaXMuJGVsLnBhcmVudE5vZGUuJHRlbXBsYXRlcyA9IHRoaXMuJHBhcmVudC4kdGVtcGxhdGVzID1cbiAgICAgIHRoaXMuJHBhcmVudC4kdGVtcGxhdGVzIHx8IG5ldyBUZW1wbGF0ZUJhZygpO1xuICAgIHRoaXMuJHRlbXBsYXRlcy5yZWdpc3RlclRlbXBsYXRlKFxuICAgICAgdGhpcy4kcHJvcHMubmFtZSB8fCAodGhpcy4kcHJvcHMuaWYgPyAoXCJ2LXRlbXBsYXRlLVwiICsgKHRpZCsrKSkgOiAnZGVmYXVsdCcpLFxuICAgICAgdGhpcy4kcHJvcHMuaWYsXG4gICAgICB0aGlzLiRzY29wZWRTbG90cy5kZWZhdWx0XG4gICAgKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7fVxufTtcblxudmFyIFRlbXBsYXRlQmFnID0gZnVuY3Rpb24gVGVtcGxhdGVCYWcoKSB7XG4gIHRoaXMuX3RlbXBsYXRlTWFwID0gbmV3IE1hcCgpO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQxID0geyBzZWxlY3RvckZuOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblRlbXBsYXRlQmFnLnByb3RvdHlwZS5yZWdpc3RlclRlbXBsYXRlID0gZnVuY3Rpb24gcmVnaXN0ZXJUZW1wbGF0ZSAobmFtZSwgY29uZGl0aW9uLCBzY29wZWRGbikge1xuICB0aGlzLl90ZW1wbGF0ZU1hcC5zZXQobmFtZSwge1xuICAgIHNjb3BlZEZuOiBzY29wZWRGbixcbiAgICBjb25kaXRpb25GbjogdGhpcy5nZXRDb25kaXRpb25Gbihjb25kaXRpb24pLFxuICAgIGtleWVkVGVtcGxhdGU6IG5ldyBWdWVLZXllZFRlbXBsYXRlKG5hbWUsIHNjb3BlZEZuKVxuICB9KTtcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycyQxLnNlbGVjdG9yRm4uZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbiB0ZW1wbGF0ZVNlbGVjdG9yRm4oaXRlbSkge1xuICAgIHZhciBpdGVyYXRvciA9IHNlbGYuX3RlbXBsYXRlTWFwLmVudHJpZXMoKTtcbiAgICB2YXIgY3VycjtcbiAgICB3aGlsZSAoKGN1cnIgPSBpdGVyYXRvci5uZXh0KCkudmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IGN1cnJbMF07XG4gICAgICAgIHZhciBjb25kaXRpb25GbiA9IGN1cnJbMV0uY29uZGl0aW9uRm47XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoY29uZGl0aW9uRm4oaXRlbSkpIHtcbiAgICAgICAgICByZXR1cm4gbmFtZVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgfVxuICAgIHJldHVybiAnZGVmYXVsdCdcbiAgfVxufTtcblxuVGVtcGxhdGVCYWcucHJvdG90eXBlLmdldENvbmRpdGlvbkZuID0gZnVuY3Rpb24gZ2V0Q29uZGl0aW9uRm4gKGNvbmRpdGlvbikge1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdjdHgnLCAoXCJ3aXRoKGN0eCkgeyByZXR1cm4gISEoXCIgKyBjb25kaXRpb24gKyBcIikgfVwiKSlcbn07XG5cblRlbXBsYXRlQmFnLnByb3RvdHlwZS5nZXRLZXllZFRlbXBsYXRlID0gZnVuY3Rpb24gZ2V0S2V5ZWRUZW1wbGF0ZSAobmFtZSkge1xuICByZXR1cm4gdGhpcy5fdGVtcGxhdGVNYXAuZ2V0KG5hbWUpLmtleWVkVGVtcGxhdGVcbn07XG5cblRlbXBsYXRlQmFnLnByb3RvdHlwZS5wYXRjaFRlbXBsYXRlID0gZnVuY3Rpb24gcGF0Y2hUZW1wbGF0ZSAobmFtZSwgY29udGV4dCwgb2xkVm5vZGUpIHtcbiAgdmFyIHZub2RlID0gdGhpcy5fdGVtcGxhdGVNYXAuZ2V0KG5hbWUpLnNjb3BlZEZuKGNvbnRleHQpO1xuICAvLyBpbiAyLjYgc2NvcGVkRm4gcmV0dXJucyBhbiBhcnJheSFcbiAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgfVxuXG4gIHZhciBuYXRpdmVWaWV3ID0gcGF0Y2gob2xkVm5vZGUsIHZub2RlKS5uYXRpdmVWaWV3O1xuICBuYXRpdmVWaWV3W1ZVRV9WSUVXXSA9IHZub2RlO1xuXG4gIC8vIGZvcmNlIGZsdXNoIFZ1ZSBjYWxsYmFja3Mgc28gYWxsIGNoYW5nZXMgYXJlIGFwcGxpZWQgaW1tZWRpYXRlbHlcbiAgLy8gcmF0aGVyIHRoYW4gb24gbmV4dCB0aWNrXG4gIGZsdXNoQ2FsbGJhY2tzKCk7XG5cbiAgcmV0dXJuIG5hdGl2ZVZpZXdcbn07XG5cblRlbXBsYXRlQmFnLnByb3RvdHlwZS5nZXRBdmFpbGFibGUgPSBmdW5jdGlvbiBnZXRBdmFpbGFibGUgKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl90ZW1wbGF0ZU1hcC5rZXlzKCkpXG59O1xuXG5UZW1wbGF0ZUJhZy5wcm90b3R5cGUuZ2V0S2V5ZWRUZW1wbGF0ZXMgPSBmdW5jdGlvbiBnZXRLZXllZFRlbXBsYXRlcyAoKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3RlbXBsYXRlTWFwLnZhbHVlcygpKS5tYXAoXG4gICAgZnVuY3Rpb24gKHJlZikge1xuICAgICAgICB2YXIga2V5ZWRUZW1wbGF0ZSA9IHJlZi5rZXllZFRlbXBsYXRlO1xuXG4gICAgICAgIHJldHVybiBrZXllZFRlbXBsYXRlO1xuICAgIH1cbiAgKVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRlbXBsYXRlQmFnLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDEgKTtcblxudmFyIFZ1ZUtleWVkVGVtcGxhdGUgPSBmdW5jdGlvbiBWdWVLZXllZFRlbXBsYXRlKGtleSwgc2NvcGVkRm4pIHtcbiAgdGhpcy5fa2V5ID0ga2V5O1xuICB0aGlzLl9zY29wZWRGbiA9IHNjb3BlZEZuO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQxJDEgPSB7IGtleTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMSQxLmtleS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9rZXlcbn07XG5cblZ1ZUtleWVkVGVtcGxhdGUucHJvdG90eXBlLmNyZWF0ZVZpZXcgPSBmdW5jdGlvbiBjcmVhdGVWaWV3ICgpIHtcbiAgLy8gd2UgYXJlIHJldHVybmluZyBudWxsIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGUgZGF0YSBoZXJlXG4gIC8vIHRoZSB2aWV3IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGUgYHBhdGNoVGVtcGxhdGVgIG1ldGhvZCBhYm92ZS5cbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXRpdmVzY3JpcHQtdnVlL25hdGl2ZXNjcmlwdC12dWUvaXNzdWVzLzIyOSNpc3N1ZWNvbW1lbnQtMzkwMzMwNDc0XG4gIHJldHVybiBudWxsXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVnVlS2V5ZWRUZW1wbGF0ZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxJDEgKTtcblxudmFyIGxpc3RWaWV3ID0ge1xuICBwcm9wczoge1xuICAgIGl0ZW1zOiB7XG4gICAgICB0eXBlOiBbQXJyYXksIE9iamVjdF0sXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIE9ic2VydmFibGVBcnJheSA9IHJlcXVpcmUoJ0BuYXRpdmVzY3JpcHQvY29yZScpLk9ic2VydmFibGVBcnJheTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBPYnNlcnZhYmxlQXJyYXlcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgJythbGlhcyc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdpdGVtJ1xuICAgIH0sXG4gICAgJytpbmRleCc6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH1cbiAgfSxcblxuICB0ZW1wbGF0ZTogXCJcXG4gICAgPE5hdGl2ZUxpc3RWaWV3XFxuICAgICAgcmVmPVxcXCJsaXN0Vmlld1xcXCJcXG4gICAgICA6aXRlbXM9XFxcIml0ZW1zXFxcIlxcbiAgICAgIHYtYmluZD1cXFwiJGF0dHJzXFxcIlxcbiAgICAgIHYtb249XFxcImxpc3RlbmVyc1xcXCJcXG4gICAgICBAaXRlbVRhcD1cXFwib25JdGVtVGFwXFxcIlxcbiAgICAgIEBpdGVtTG9hZGluZz1cXFwib25JdGVtTG9hZGluZ1xcXCJcXG4gICAgPlxcbiAgICAgIDxzbG90IC8+XFxuICAgIDwvTmF0aXZlTGlzdFZpZXc+XFxuICBcIixcblxuICB3YXRjaDoge1xuICAgIGl0ZW1zOiB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKG5ld1ZhbCkge1xuICAgICAgICB0aGlzLiRyZWZzLmxpc3RWaWV3LnNldEF0dHJpYnV0ZSgnaXRlbXMnLCBuZXdWYWwpO1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgLy8gd2UgbmVlZCB0byByZW1vdmUgdGhlIGl0ZW1UYXAgaGFuZGxlciBmcm9tIGEgY2xvbmUgb2YgdGhlICRsaXN0ZW5lcnNcbiAgICAvLyBvYmplY3QgYmVjYXVzZSB3ZSBhcmUgZW1pdHRpbmcgdGhlIGV2ZW50IG91cnNlbHZlcyB3aXRoIGFkZGVkIGRhdGEuXG4gICAgdmFyIGxpc3RlbmVycyA9IGV4dGVuZCh7fSwgdGhpcy4kbGlzdGVuZXJzKTtcbiAgICBkZWxldGUgbGlzdGVuZXJzLml0ZW1UYXA7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG5cbiAgICB0aGlzLmdldEl0ZW1Db250ZXh0ID0gZ2V0SXRlbUNvbnRleHQuYmluZCh0aGlzKTtcbiAgfSxcblxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLiR0ZW1wbGF0ZXMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuJHJlZnMubGlzdFZpZXcuc2V0QXR0cmlidXRlKFxuICAgICAgJ2l0ZW1UZW1wbGF0ZXMnLFxuICAgICAgdGhpcy4kdGVtcGxhdGVzLmdldEtleWVkVGVtcGxhdGVzKClcbiAgICApO1xuICAgIHRoaXMuJHJlZnMubGlzdFZpZXcuc2V0QXR0cmlidXRlKCdpdGVtVGVtcGxhdGVTZWxlY3RvcicsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMkMS4kdGVtcGxhdGVzLnNlbGVjdG9yRm4odGhpcyQxLmdldEl0ZW1Db250ZXh0KGl0ZW0sIGluZGV4KSlcbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgb25JdGVtVGFwOiBmdW5jdGlvbiBvbkl0ZW1UYXAoYXJncykge1xuICAgICAgdGhpcy4kZW1pdCgnaXRlbVRhcCcsIGV4dGVuZCh7IGl0ZW06IHRoaXMuZ2V0SXRlbShhcmdzLmluZGV4KSB9LCBhcmdzKSk7XG4gICAgfSxcbiAgICBvbkl0ZW1Mb2FkaW5nOiBmdW5jdGlvbiBvbkl0ZW1Mb2FkaW5nKGFyZ3MpIHtcbiAgICAgIGlmICghdGhpcy4kdGVtcGxhdGVzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSBhcmdzLmluZGV4O1xuICAgICAgdmFyIGl0ZW1zID0gYXJncy5vYmplY3QuaXRlbXM7XG5cbiAgICAgIHZhciBjdXJyZW50SXRlbSA9IHRoaXMuZ2V0SXRlbShpbmRleCk7XG5cbiAgICAgIHZhciBuYW1lID0gYXJncy5vYmplY3QuX2l0ZW1UZW1wbGF0ZVNlbGVjdG9yKGN1cnJlbnRJdGVtLCBpbmRleCwgaXRlbXMpO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmdldEl0ZW1Db250ZXh0KGN1cnJlbnRJdGVtLCBpbmRleCk7XG4gICAgICB2YXIgb2xkVm5vZGUgPSBhcmdzLnZpZXcgJiYgYXJncy52aWV3W1ZVRV9WSUVXXTtcblxuICAgICAgYXJncy52aWV3ID0gdGhpcy4kdGVtcGxhdGVzLnBhdGNoVGVtcGxhdGUobmFtZSwgY29udGV4dCwgb2xkVm5vZGUpO1xuICAgIH0sXG4gICAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHRoaXMuJHJlZnMubGlzdFZpZXcubmF0aXZlVmlldy5yZWZyZXNoKCk7XG4gICAgfSxcbiAgICBnZXRJdGVtOiBmdW5jdGlvbiBnZXRJdGVtKGlkeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLml0ZW1zLmdldEl0ZW0gPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB0aGlzLml0ZW1zLmdldEl0ZW0oaWR4KVxuICAgICAgICA6IHRoaXMuaXRlbXNbaWR4XVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0SXRlbUNvbnRleHQoXG4gIGl0ZW0sXG4gIGluZGV4LFxuICBhbGlhcyxcbiAgaW5kZXhfYWxpYXNcbikge1xuICB2YXIgb2JqO1xuXG4gIGlmICggYWxpYXMgPT09IHZvaWQgMCApIGFsaWFzID0gdGhpcy4kcHJvcHNbJythbGlhcyddO1xuICBpZiAoIGluZGV4X2FsaWFzID09PSB2b2lkIDAgKSBpbmRleF9hbGlhcyA9IHRoaXMuJHByb3BzWycraW5kZXgnXTtcbiAgcmV0dXJuICggb2JqID0ge30sIG9ialthbGlhc10gPSBpdGVtLCBvYmpbaW5kZXhfYWxpYXMgfHwgJyRpbmRleCddID0gaW5kZXgsIG9iai4kZXZlbiA9IGluZGV4ICUgMiA9PT0gMCwgb2JqLiRvZGQgPSBpbmRleCAlIDIgIT09IDAsIG9iaiApXG59XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gbWFrZU1hcCgndGVtcGxhdGUnLCB0cnVlKTtcblxudmFyIF9WdWU7XG5cbmZ1bmN0aW9uIHNldFZ1ZShWdWUpIHtcbiAgX1Z1ZSA9IFZ1ZTtcbn1cblxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBmdW5jdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGdldFZpZXdNZXRhKGVsKS5jYW5CZUxlZnRPcGVuVGFnXG59O1xuXG52YXIgaXNVbmFyeVRhZyA9IGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4gZ2V0Vmlld01ldGEoZWwpLmlzVW5hcnlUYWdcbn07XG5cbmZ1bmN0aW9uIG11c3RVc2VQcm9wKCkge1xuICAvLyBjb25zb2xlLmxvZygnbXVzdFVzZVByb3AnKVxufVxuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UoZWwpIHtcbiAgcmV0dXJuIGdldFZpZXdNZXRhKGVsKS50YWdOYW1lc3BhY2Vcbn1cblxuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudChlbCkge1xuICByZXR1cm4gIWlzS25vd25WaWV3KGVsKVxufVxuXG52YXIgVlVFX1ZFUlNJT04gPSBwcm9jZXNzLmVudi5WVUVfVkVSU0lPTiB8fCAnMi42LjEyJztcbnZhciBOU19WVUVfVkVSU0lPTiA9IHByb2Nlc3MuZW52Lk5TX1ZVRV9WRVJTSU9OIHx8ICcyLjguNCc7XG5cbnZhciBpbmZvVHJhY2UgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgY29uc29sZS5sb2coXG4gICAgXCJOYXRpdmVTY3JpcHQtVnVlIGhhcyBcXFwiVnVlLmNvbmZpZy5zaWxlbnRcXFwiIHNldCB0byB0cnVlLCB0byBzZWUgb3V0cHV0IGxvZ3Mgc2V0IGl0IHRvIGZhbHNlLlwiXG4gICk7XG59KTtcblxuZnVuY3Rpb24gdHJhY2UobWVzc2FnZSkge1xuICBpZiAoX1Z1ZSAmJiBfVnVlLmNvbmZpZy5zaWxlbnQpIHtcbiAgICByZXR1cm4gaW5mb1RyYWNlKClcbiAgfVxuXG4gIGlmIChfVnVlICYmICFfVnVlLmNvbmZpZy5zdXBwcmVzc1JlbmRlckxvZ3MpIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIChcIntOU1Z1ZSAoVnVlOiBcIiArIFZVRV9WRVJTSU9OICsgXCIgfCBOU1Z1ZTogXCIgKyBOU19WVUVfVkVSU0lPTiArIFwiKX0gLT4gXCIgKyBtZXNzYWdlKVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRGV2dG9vbHMoKSB7XG4gIGlmIChnbG9iYWwuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXykge1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWwuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5lbWl0KCdmbHVzaCcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy9cbiAgICB9XG4gIH1cbn1cblxudmFyIFBBR0VfUkVGID0gJ19fdnVlUGFnZVJlZl9fJztcblxudmFyIHBhZ2UgPSB7XG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICByZXR1cm4gaChcbiAgICAgICdOYXRpdmVQYWdlJyxcbiAgICAgIHtcbiAgICAgICAgYXR0cnM6IHRoaXMuJGF0dHJzLFxuICAgICAgICBvbjogdGhpcy4kbGlzdGVuZXJzXG4gICAgICB9LFxuICAgICAgdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgIClcbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMuJGVsLm5hdGl2ZVZpZXdbUEFHRV9SRUZdID0gdGhpcztcblxuICAgIHZhciBmcmFtZSA9IHRoaXMuX2ZpbmRQYXJlbnRGcmFtZSgpO1xuXG4gICAgLy8gd2Ugb25seSBuZWVkIGNhbGwgdGhpcyBmb3IgdGhlIFwiZGVmYXVsdFBhZ2VcIiBvZiB0aGUgZnJhbWVcbiAgICAvLyB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRlc3RpbmcgaWYgYW55IHBhZ2UgaXMgXCJjdXJyZW50XCIgaW4gdGhlIGZyYW1lXG4gICAgaWYgKGZyYW1lICYmICFmcmFtZS5maXJzdFBhZ2VNb3VudGVkICYmICFmcmFtZS4kZWwubmF0aXZlVmlldy5jdXJyZW50UGFnZSkge1xuICAgICAgZnJhbWUuZmlyc3RQYWdlTW91bnRlZCA9IHRydWU7XG4gICAgICBmcmFtZS5ub3RpZnlGaXJzdFBhZ2VNb3VudGVkKHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmlzQmFja05hdmlnYXRpb24pIHtcbiAgICAgICAgdGhpcyQxLiRlbC5uYXRpdmVWaWV3Lm9mZignbmF2aWdhdGVkRnJvbScsIGhhbmRsZXIpO1xuICAgICAgICB0aGlzJDEuJHBhcmVudC4kZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLiRlbC5uYXRpdmVWaWV3Lm9uKCduYXZpZ2F0ZWRGcm9tJywgaGFuZGxlcik7XG5cbiAgICAvLyBlbnN1cmUgdGhhdCB0aGUgcGFyZW50IHZ1ZSBpbnN0YW5jZSBpcyBkZXN0cm95ZWQgd2hlbiB0aGVcbiAgICAvLyBwYWdlIGlzIGRpc3Bvc2VkIChjbGVhckhpc3Rvcnk6IHRydWUgZm9yIGV4YW1wbGUpXG4gICAgdmFyIGRpc3Bvc2UgPSB0aGlzLiRlbC5uYXRpdmVWaWV3LmRpc3Bvc2VOYXRpdmVWaWV3O1xuICAgIHRoaXMuJGVsLm5hdGl2ZVZpZXcuZGlzcG9zZU5hdGl2ZVZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgdGhpcyQxLiRwYXJlbnQuJGRlc3Ryb3koKTtcbiAgICAgIGRpc3Bvc2UuY2FsbCh0aGlzJDEuJGVsLm5hdGl2ZVZpZXcsIGFyZ3MpO1xuICAgICAgdXBkYXRlRGV2dG9vbHMoKTtcbiAgICB9O1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgX2ZpbmRQYXJlbnRGcmFtZTogZnVuY3Rpb24gX2ZpbmRQYXJlbnRGcmFtZSgpIHtcbiAgICAgIHZhciBmcmFtZSA9IHRoaXMuJHBhcmVudDtcblxuICAgICAgd2hpbGUgKGZyYW1lICYmIGZyYW1lLiRvcHRpb25zLm5hbWUgIT09ICdGcmFtZScpIHtcbiAgICAgICAgZnJhbWUgPSBmcmFtZS4kcGFyZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnJhbWVcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0YWJWaWV3ID0ge1xuICBtb2RlbDoge1xuICAgIHByb3A6ICdzZWxlY3RlZEluZGV4JyxcbiAgICBldmVudDogJ3NlbGVjdGVkSW5kZXhDaGFuZ2UnXG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHJldHVybiBoKFxuICAgICAgJ05hdGl2ZVRhYlZpZXcnLFxuICAgICAge1xuICAgICAgICBvbjogdGhpcy4kbGlzdGVuZXJzLFxuICAgICAgICBhdHRyczogdGhpcy4kYXR0cnNcbiAgICAgIH0sXG4gICAgICB0aGlzLiRzbG90cy5kZWZhdWx0XG4gICAgKVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICByZWdpc3RlclRhYjogZnVuY3Rpb24gcmVnaXN0ZXJUYWIodGFiVmlldykge1xuICAgICAgdmFyIGl0ZW1zID0gdGhpcy4kZWwubmF0aXZlVmlldy5pdGVtcyB8fCBbXTtcblxuICAgICAgdGhpcy4kZWwuc2V0QXR0cmlidXRlKCdpdGVtcycsIGl0ZW1zLmNvbmNhdChbdGFiVmlld10pKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0YWJWaWV3SXRlbSA9IHtcbiAgdGVtcGxhdGU6IFwiPE5hdGl2ZVRhYlZpZXdJdGVtPjxzbG90IC8+PC9OYXRpdmVUYWJWaWV3SXRlbT5cIixcblxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIGlmICh0aGlzLiRlbC5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4kMSgnVGFiVmlld0l0ZW0gc2hvdWxkIGNvbnRhaW4gb25seSAxIHJvb3QgZWxlbWVudCcsIHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBfbmF0aXZlVmlldyA9IHRoaXMuJGVsLm5hdGl2ZVZpZXc7XG4gICAgX25hdGl2ZVZpZXcudmlldyA9IHRoaXMuJGVsLmNoaWxkTm9kZXNbMF0ubmF0aXZlVmlldztcbiAgICB0aGlzLiRwYXJlbnQucmVnaXN0ZXJUYWIoX25hdGl2ZVZpZXcpO1xuICB9XG59O1xuXG52YXIgYm90dG9tTmF2aWdhdGlvbiA9IHtcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnc2VsZWN0ZWRJbmRleCcsXG4gICAgZXZlbnQ6ICdzZWxlY3RlZEluZGV4Q2hhbmdlJ1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICByZXR1cm4gaChcbiAgICAgICdOYXRpdmVCb3R0b21OYXZpZ2F0aW9uJyxcbiAgICAgIHtcbiAgICAgICAgb246IHRoaXMuJGxpc3RlbmVycyxcbiAgICAgICAgYXR0cnM6IHRoaXMuJGF0dHJzXG4gICAgICB9LFxuICAgICAgdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgIClcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgcmVnaXN0ZXJUYWJTdHJpcDogZnVuY3Rpb24gcmVnaXN0ZXJUYWJTdHJpcCh0YWJTdHJpcCkge1xuICAgICAgdGhpcy4kZWwuc2V0QXR0cmlidXRlKCd0YWJTdHJpcCcsIHRhYlN0cmlwKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyVGFiQ29udGVudEl0ZW06IGZ1bmN0aW9uIHJlZ2lzdGVyVGFiQ29udGVudEl0ZW0odGFiQ29udGVudEl0ZW0pIHtcbiAgICAgIHZhciBpdGVtcyA9IHRoaXMuJGVsLm5hdGl2ZVZpZXcuaXRlbXMgfHwgW107XG5cbiAgICAgIHRoaXMuJGVsLnNldEF0dHJpYnV0ZSgnaXRlbXMnLCBpdGVtcy5jb25jYXQoW3RhYkNvbnRlbnRJdGVtXSkpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHRhYnMgPSB7XG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ3NlbGVjdGVkSW5kZXgnLFxuICAgIGV2ZW50OiAnc2VsZWN0ZWRJbmRleENoYW5nZSdcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgcmV0dXJuIGgoXG4gICAgICAnTmF0aXZlVGFicycsXG4gICAgICB7XG4gICAgICAgIG9uOiB0aGlzLiRsaXN0ZW5lcnMsXG4gICAgICAgIGF0dHJzOiB0aGlzLiRhdHRyc1xuICAgICAgfSxcbiAgICAgIHRoaXMuJHNsb3RzLmRlZmF1bHRcbiAgICApXG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIHJlZ2lzdGVyVGFiU3RyaXA6IGZ1bmN0aW9uIHJlZ2lzdGVyVGFiU3RyaXAodGFiU3RyaXApIHtcbiAgICAgIHRoaXMuJGVsLnNldEF0dHJpYnV0ZSgndGFiU3RyaXAnLCB0YWJTdHJpcCk7XG4gICAgfSxcbiAgICByZWdpc3RlclRhYkNvbnRlbnRJdGVtOiBmdW5jdGlvbiByZWdpc3RlclRhYkNvbnRlbnRJdGVtKHRhYkNvbnRlbnRJdGVtKSB7XG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLiRlbC5uYXRpdmVWaWV3Lml0ZW1zIHx8IFtdO1xuXG4gICAgICB0aGlzLiRlbC5zZXRBdHRyaWJ1dGUoJ2l0ZW1zJywgaXRlbXMuY29uY2F0KFt0YWJDb250ZW50SXRlbV0pKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0YWJTdHJpcCA9IHtcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHJldHVybiBoKFxuICAgICAgJ05hdGl2ZVRhYlN0cmlwJyxcbiAgICAgIHtcbiAgICAgICAgb246IHRoaXMuJGxpc3RlbmVycyxcbiAgICAgICAgYXR0cnM6IHRoaXMuJGF0dHJzXG4gICAgICB9LFxuICAgICAgdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgIClcbiAgfSxcblxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHZhciBfbmF0aXZlVmlldyA9IHRoaXMuJGVsLm5hdGl2ZVZpZXc7XG4gICAgdGhpcy4kcGFyZW50LnJlZ2lzdGVyVGFiU3RyaXAoX25hdGl2ZVZpZXcpO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICByZWdpc3RlclRhYlN0cmlwSXRlbTogZnVuY3Rpb24gcmVnaXN0ZXJUYWJTdHJpcEl0ZW0odGFiU3RyaXBJdGVtKSB7XG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLiRlbC5uYXRpdmVWaWV3Lml0ZW1zIHx8IFtdO1xuXG4gICAgICB0aGlzLiRlbC5zZXRBdHRyaWJ1dGUoJ2l0ZW1zJywgaXRlbXMuY29uY2F0KFt0YWJTdHJpcEl0ZW1dKSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdGFiU3RyaXBJdGVtID0ge1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgcmV0dXJuIGgoXG4gICAgICAnTmF0aXZlVGFiU3RyaXBJdGVtJyxcbiAgICAgIHtcbiAgICAgICAgb246IHRoaXMuJGxpc3RlbmVycyxcbiAgICAgICAgYXR0cnM6IHRoaXMuJGF0dHJzXG4gICAgICB9LFxuICAgICAgdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgIClcbiAgfSxcblxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHZhciBfbmF0aXZlVmlldyA9IHRoaXMuJGVsLm5hdGl2ZVZpZXc7XG4gICAgdGhpcy4kcGFyZW50LnJlZ2lzdGVyVGFiU3RyaXBJdGVtKF9uYXRpdmVWaWV3KTtcbiAgfVxufTtcblxudmFyIHRhYkNvbnRlbnRJdGVtID0ge1xuICB0ZW1wbGF0ZTogXCI8TmF0aXZlVGFiQ29udGVudEl0ZW0+PHNsb3QgLz48L05hdGl2ZVRhYkNvbnRlbnRJdGVtPlwiLFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgaWYgKHRoaXMuJGVsLmNoaWxkTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgd2FybiQxKCdUYWJDb250ZW50SXRlbSBzaG91bGQgY29udGFpbiBvbmx5IDEgcm9vdCBlbGVtZW50JywgdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIF9uYXRpdmVWaWV3ID0gdGhpcy4kZWwubmF0aXZlVmlldztcbiAgICBfbmF0aXZlVmlldy52aWV3ID0gdGhpcy4kZWwuY2hpbGROb2Rlc1swXS5uYXRpdmVWaWV3O1xuICAgIHRoaXMuJHBhcmVudC5yZWdpc3RlclRhYkNvbnRlbnRJdGVtKF9uYXRpdmVWaWV3KTtcbiAgfVxufTtcblxuLyogICovXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIGlzTm90VGV4dE5vZGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9O1xuXG52YXIgaXNWU2hvd0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfTtcblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihpc05vdFRleHROb2RlKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybiQxKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoaXNWU2hvd0RpcmVjdGl2ZSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxudmFyIGVsZW1lbnRNYXAgPSB7fTtcbnZhciBuYXRpdmVSZWdFeHAgPSAvTmF0aXZlL2dpO1xudmFyIGRhc2hSZWdFeHAgPSAvLS9nO1xuXG52YXIgZGVmYXVsdFZpZXdNZXRhID0ge1xuICBza2lwQWRkVG9Eb206IGZhbHNlLFxuICBpc1VuYXJ5VGFnOiBmYWxzZSxcbiAgdGFnTmFtZXNwYWNlOiAnJyxcbiAgY2FuQmVMZWZ0T3BlblRhZzogZmFsc2UsXG4gIG1vZGVsOiBudWxsLFxuICBjb21wb25lbnQ6IG51bGxcbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVsZW1lbnROYW1lKGVsZW1lbnROYW1lKSB7XG4gIHJldHVybiAoXCJuYXRpdmVcIiArIChlbGVtZW50TmFtZVxuICAgIC5yZXBsYWNlKG5hdGl2ZVJlZ0V4cCwgJycpXG4gICAgLnJlcGxhY2UoZGFzaFJlZ0V4cCwgJycpXG4gICAgLnRvTG93ZXJDYXNlKCkpKVxufVxuXG5mdW5jdGlvbiByZWdpc3RlckVsZW1lbnQoZWxlbWVudE5hbWUsIHJlc29sdmVyLCBtZXRhKSB7XG4gIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZUVsZW1lbnROYW1lKGVsZW1lbnROYW1lKTtcblxuICBtZXRhID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFZpZXdNZXRhLCBtZXRhKTtcblxuICAvLyBhbGxvdyBvdmVycmlkZSBvZiBlbGVtZW50cyBjbGFzc2VzIChOIG9uZXMgZXNwZWNpYWxseSlcbiAgLy8gdGhpcyBpcyB2ZXJ5IHByYWN0aWNhbCBpbiBjYXNlIHlvdSB3YW50IHRvIHRlc3QgbmV3IGNvbXBvbmVudFxuICAvLyBvciBzaW1wbHkgb3ZlcnJpZGUgdGhlIGdsb2JhbCBCdXR0b24gZm9yIGV4YW1wbGVcbiAgaWYgKGVsZW1lbnRNYXBbbm9ybWFsaXplZE5hbWVdKSB7XG4gICAgdHJhY2UoKFwiRWxlbWVudCBmb3IgXCIgKyBlbGVtZW50TmFtZSArIFwiIGFscmVhZHkgcmVnaXN0ZXJlZC5cIikpO1xuICB9XG5cbiAgaWYgKCFtZXRhLmNvbXBvbmVudCkge1xuICAgIC8vIGlmIG5vIFZ1ZSBjb21wb25lbnQgaXMgcGFzc2VkLCB3cmFwIHRoZSBzaW1wbGVyIHZ1ZSBjb21wb25lbnRcbiAgICAvLyB3aGljaCBiaW5kIHRoZSBldmVudHMgYW5kIGF0dHJpYnV0ZXMgdG8gdGhlIE5TIG9uZVxuICAgIG1ldGEuY29tcG9uZW50ID0ge1xuICAgICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICAgIG1vZGVsOiBtZXRhLm1vZGVsLFxuICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoaCwgcmVmKSB7XG4gICAgICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcblxuICAgICAgICByZXR1cm4gaChub3JtYWxpemVkTmFtZSwgZGF0YSwgY2hpbGRyZW4pXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBtZXRhLmNvbXBvbmVudC5uYW1lID0gZWxlbWVudE5hbWU7XG5cbiAgZWxlbWVudE1hcFtub3JtYWxpemVkTmFtZV0gPSB7XG4gICAgcmVzb2x2ZXI6IHJlc29sdmVyLFxuICAgIG1ldGE6IG1ldGFcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudE1hcCgpIHtcbiAgcmV0dXJuIGVsZW1lbnRNYXBcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld0NsYXNzKGVsZW1lbnROYW1lKSB7XG4gIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZUVsZW1lbnROYW1lKGVsZW1lbnROYW1lKTtcbiAgdmFyIGVudHJ5ID0gZWxlbWVudE1hcFtub3JtYWxpemVkTmFtZV07XG5cbiAgaWYgKCFlbnRyeSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKFwiTm8ga25vd24gY29tcG9uZW50IGZvciBlbGVtZW50IFwiICsgZWxlbWVudE5hbWUgKyBcIi5cIikpXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBlbnRyeS5yZXNvbHZlcigpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgKFwiQ291bGQgbm90IGxvYWQgdmlldyBmb3I6IFwiICsgZWxlbWVudE5hbWUgKyBcIi4gXCIgKyBlICsgXCIgXCIgKyAoZS5zdGFjaykpXG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdNZXRhKGVsZW1lbnROYW1lKSB7XG4gIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZUVsZW1lbnROYW1lKGVsZW1lbnROYW1lKTtcblxuICB2YXIgbWV0YSA9IGRlZmF1bHRWaWV3TWV0YTtcbiAgdmFyIGVudHJ5ID0gZWxlbWVudE1hcFtub3JtYWxpemVkTmFtZV07XG5cbiAgaWYgKGVudHJ5ICYmIGVudHJ5Lm1ldGEpIHtcbiAgICBtZXRhID0gZW50cnkubWV0YTtcbiAgfVxuXG4gIHJldHVybiBtZXRhXG59XG5cbmZ1bmN0aW9uIGlzS25vd25WaWV3KGVsZW1lbnROYW1lKSB7XG4gIHJldHVybiBlbGVtZW50TWFwW25vcm1hbGl6ZUVsZW1lbnROYW1lKGVsZW1lbnROYW1lKV1cbn1cblxucmVnaXN0ZXJFbGVtZW50KCdBY3Rpb25CYXInLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5BY3Rpb25CYXI7IH0sIHtcbiAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudCwgY2hpbGQpIHtcbiAgICB0cnkge1xuICAgICAgcGFyZW50Lm5hdGl2ZVZpZXcuX3JlbW92ZVZpZXcoY2hpbGQubmF0aXZlVmlldyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWdub3JlIGV4Y2VwdGlvbiAtIGNoaWxkIGlzIGxpa2VseSBhbHJlYWR5IHJlbW92ZWQvcmVwbGFjZWRcbiAgICAgIC8vIGZpeGVzICM3NlxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50OiBhY3Rpb25CYXJcbn0pO1xuXG5yZWdpc3RlckVsZW1lbnQoJ0FjdGlvbkl0ZW0nLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5BY3Rpb25JdGVtOyB9KTtcblxucmVnaXN0ZXJFbGVtZW50KCdhbmRyb2lkJywgbnVsbCwge1xuICBjb21wb25lbnQ6IGFuZHJvaWRcbn0pO1xuXG5yZWdpc3RlckVsZW1lbnQoJ2lvcycsIG51bGwsIHtcbiAgY29tcG9uZW50OiBpb3Ncbn0pO1xuXG5yZWdpc3RlckVsZW1lbnQoJ0xpc3RWaWV3JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZSgnQG5hdGl2ZXNjcmlwdC9jb3JlJykuTGlzdFZpZXc7IH0sIHtcbiAgY29tcG9uZW50OiBsaXN0Vmlld1xufSk7XG5cbnJlZ2lzdGVyRWxlbWVudChcbiAgJ05hdmlnYXRpb25CdXR0b24nLFxuICBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5OYXZpZ2F0aW9uQnV0dG9uOyB9XG4pO1xuXG5yZWdpc3RlckVsZW1lbnQoJ1RhYlZpZXcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5UYWJWaWV3OyB9LCB7XG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ3NlbGVjdGVkSW5kZXgnLFxuICAgIGV2ZW50OiAnc2VsZWN0ZWRJbmRleENoYW5nZSdcbiAgfSxcbiAgY29tcG9uZW50OiB0YWJWaWV3XG59KTtcblxucmVnaXN0ZXJFbGVtZW50KFxuICAnVGFiVmlld0l0ZW0nLFxuICBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5UYWJWaWV3SXRlbTsgfSxcbiAge1xuICAgIHNraXBBZGRUb0RvbTogdHJ1ZSxcbiAgICBjb21wb25lbnQ6IHRhYlZpZXdJdGVtXG4gIH1cbik7XG5cbnJlZ2lzdGVyRWxlbWVudChcbiAgJ0JvdHRvbU5hdmlnYXRpb24nLFxuICBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5Cb3R0b21OYXZpZ2F0aW9uOyB9LFxuICB7XG4gICAgbW9kZWw6IHtcbiAgICAgIHByb3A6ICdzZWxlY3RlZEluZGV4JyxcbiAgICAgIGV2ZW50OiAnc2VsZWN0ZWRJbmRleENoYW5nZSdcbiAgICB9LFxuICAgIGNvbXBvbmVudDogYm90dG9tTmF2aWdhdGlvblxuICB9XG4pO1xuXG5yZWdpc3RlckVsZW1lbnQoJ1RhYnMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5UYWJzOyB9LCB7XG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ3NlbGVjdGVkSW5kZXgnLFxuICAgIGV2ZW50OiAnc2VsZWN0ZWRJbmRleENoYW5nZSdcbiAgfSxcbiAgY29tcG9uZW50OiB0YWJzXG59KTtcblxucmVnaXN0ZXJFbGVtZW50KCdUYWJTdHJpcCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJ0BuYXRpdmVzY3JpcHQvY29yZScpLlRhYlN0cmlwOyB9LCB7XG4gIHNraXBBZGRUb0RvbTogdHJ1ZSxcbiAgY29tcG9uZW50OiB0YWJTdHJpcFxufSk7XG5cbnJlZ2lzdGVyRWxlbWVudChcbiAgJ1RhYlN0cmlwSXRlbScsXG4gIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJ0BuYXRpdmVzY3JpcHQvY29yZScpLlRhYlN0cmlwSXRlbTsgfSxcbiAge1xuICAgIHNraXBBZGRUb0RvbTogdHJ1ZSxcbiAgICBjb21wb25lbnQ6IHRhYlN0cmlwSXRlbVxuICB9XG4pO1xuXG5yZWdpc3RlckVsZW1lbnQoXG4gICdUYWJDb250ZW50SXRlbScsXG4gIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJ0BuYXRpdmVzY3JpcHQvY29yZScpLlRhYkNvbnRlbnRJdGVtOyB9LFxuICB7XG4gICAgc2tpcEFkZFRvRG9tOiB0cnVlLFxuICAgIGNvbXBvbmVudDogdGFiQ29udGVudEl0ZW1cbiAgfVxuKTtcblxucmVnaXN0ZXJFbGVtZW50KCd0cmFuc2l0aW9uJywgbnVsbCwge1xuICBjb21wb25lbnQ6IFRyYW5zaXRpb25cbn0pO1xuXG5yZWdpc3RlckVsZW1lbnQoJ3YtdGVtcGxhdGUnLCBudWxsLCB7XG4gIGNvbXBvbmVudDogdlRlbXBsYXRlJDFcbn0pO1xuXG4vLyBOUyBjb21wb25lbnRzIHdoaWNoIHVzZXMgdGhlIGF1dG9tYXRpYyByZWdpc3RlckVsZW1lbnQgVnVlIHdyYXBwZXJcbi8vIGFzIHRoZXkgZG8gbm90IG5lZWQgYW55IHNwZWNpYWwgbG9naWNcblxucmVnaXN0ZXJFbGVtZW50KCdMYWJlbCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJ0BuYXRpdmVzY3JpcHQvY29yZScpLkxhYmVsOyB9LCB7XG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ3RleHQnLFxuICAgIGV2ZW50OiAndGV4dENoYW5nZSdcbiAgfVxufSk7XG5cbnJlZ2lzdGVyRWxlbWVudCgnRGF0ZVBpY2tlcicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJ0BuYXRpdmVzY3JpcHQvY29yZScpLkRhdGVQaWNrZXI7IH0sIHtcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnZGF0ZScsXG4gICAgZXZlbnQ6ICdkYXRlQ2hhbmdlJ1xuICB9XG59KTtcblxucmVnaXN0ZXJFbGVtZW50KFxuICAnQWJzb2x1dGVMYXlvdXQnLFxuICBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5BYnNvbHV0ZUxheW91dDsgfVxuKTtcbnJlZ2lzdGVyRWxlbWVudChcbiAgJ0FjdGl2aXR5SW5kaWNhdG9yJyxcbiAgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZSgnQG5hdGl2ZXNjcmlwdC9jb3JlJykuQWN0aXZpdHlJbmRpY2F0b3I7IH1cbik7XG5yZWdpc3RlckVsZW1lbnQoJ0J1dHRvbicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJ0BuYXRpdmVzY3JpcHQvY29yZScpLkJ1dHRvbjsgfSk7XG5yZWdpc3RlckVsZW1lbnQoJ0NvbnRlbnRWaWV3JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZSgnQG5hdGl2ZXNjcmlwdC9jb3JlJykuQ29udGVudFZpZXc7IH0pO1xucmVnaXN0ZXJFbGVtZW50KCdEb2NrTGF5b3V0JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZSgnQG5hdGl2ZXNjcmlwdC9jb3JlJykuRG9ja0xheW91dDsgfSk7XG5yZWdpc3RlckVsZW1lbnQoJ0dyaWRMYXlvdXQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5HcmlkTGF5b3V0OyB9KTtcbnJlZ2lzdGVyRWxlbWVudCgnSHRtbFZpZXcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5IdG1sVmlldzsgfSk7XG5yZWdpc3RlckVsZW1lbnQoJ0ltYWdlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZSgnQG5hdGl2ZXNjcmlwdC9jb3JlJykuSW1hZ2U7IH0pO1xucmVnaXN0ZXJFbGVtZW50KCdpbWcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5JbWFnZTsgfSk7XG5yZWdpc3RlckVsZW1lbnQoJ0xpc3RQaWNrZXInLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5MaXN0UGlja2VyOyB9LCB7XG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ3NlbGVjdGVkSW5kZXgnLFxuICAgIGV2ZW50OiAnc2VsZWN0ZWRJbmRleENoYW5nZSdcbiAgfVxufSk7XG5yZWdpc3RlckVsZW1lbnQoJ1BhZ2UnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5QYWdlOyB9LCB7XG4gIHNraXBBZGRUb0RvbTogdHJ1ZSxcbiAgY29tcG9uZW50OiBwYWdlXG59KTtcblxucmVnaXN0ZXJFbGVtZW50KCdQbGFjZWhvbGRlcicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJ0BuYXRpdmVzY3JpcHQvY29yZScpLlBsYWNlaG9sZGVyOyB9KTtcbnJlZ2lzdGVyRWxlbWVudCgnUHJvZ3Jlc3MnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5Qcm9ncmVzczsgfSwge1xuICBtb2RlbDoge1xuICAgIHByb3A6ICd2YWx1ZScsXG4gICAgZXZlbnQ6ICd2YWx1ZUNoYW5nZSdcbiAgfVxufSk7XG5yZWdpc3RlckVsZW1lbnQoXG4gICdQcm94eVZpZXdDb250YWluZXInLFxuICBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5Qcm94eVZpZXdDb250YWluZXI7IH1cbik7XG4vLyByZWdpc3RlckVsZW1lbnQoXG4vLyAgICdSZXBlYXRlcicsXG4vLyAgICgpID0+IHJlcXVpcmUoJ0BuYXRpdmVzY3JpcHQvY29yZScpLlJlcGVhdGVyXG4vLyApXG5yZWdpc3RlckVsZW1lbnQoJ1Njcm9sbFZpZXcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5TY3JvbGxWaWV3OyB9KTtcbnJlZ2lzdGVyRWxlbWVudCgnU2VhcmNoQmFyJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZSgnQG5hdGl2ZXNjcmlwdC9jb3JlJykuU2VhcmNoQmFyOyB9LCB7XG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ3RleHQnLFxuICAgIGV2ZW50OiAndGV4dENoYW5nZSdcbiAgfVxufSk7XG5yZWdpc3RlckVsZW1lbnQoXG4gICdTZWdtZW50ZWRCYXInLFxuICBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5TZWdtZW50ZWRCYXI7IH0sXG4gIHtcbiAgICBtb2RlbDoge1xuICAgICAgcHJvcDogJ3NlbGVjdGVkSW5kZXgnLFxuICAgICAgZXZlbnQ6ICdzZWxlY3RlZEluZGV4Q2hhbmdlJ1xuICAgIH1cbiAgfVxuKTtcbnJlZ2lzdGVyRWxlbWVudChcbiAgJ1NlZ21lbnRlZEJhckl0ZW0nLFxuICBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5TZWdtZW50ZWRCYXJJdGVtOyB9XG4pO1xucmVnaXN0ZXJFbGVtZW50KCdTbGlkZXInLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5TbGlkZXI7IH0sIHtcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAndmFsdWUnLFxuICAgIGV2ZW50OiAndmFsdWVDaGFuZ2UnXG4gIH1cbn0pO1xucmVnaXN0ZXJFbGVtZW50KCdTdGFja0xheW91dCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJ0BuYXRpdmVzY3JpcHQvY29yZScpLlN0YWNrTGF5b3V0OyB9KTtcbnJlZ2lzdGVyRWxlbWVudChcbiAgJ0ZsZXhib3hMYXlvdXQnLFxuICBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5GbGV4Ym94TGF5b3V0OyB9XG4pO1xucmVnaXN0ZXJFbGVtZW50KCdTd2l0Y2gnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5Td2l0Y2g7IH0sIHtcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnY2hlY2tlZCcsXG4gICAgZXZlbnQ6ICdjaGVja2VkQ2hhbmdlJ1xuICB9XG59KTtcblxucmVnaXN0ZXJFbGVtZW50KCdUZXh0RmllbGQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5UZXh0RmllbGQ7IH0sIHtcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAndGV4dCcsXG4gICAgZXZlbnQ6ICd0ZXh0Q2hhbmdlJ1xuICB9XG59KTtcbnJlZ2lzdGVyRWxlbWVudCgnVGV4dFZpZXcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5UZXh0VmlldzsgfSwge1xuICBtb2RlbDoge1xuICAgIHByb3A6ICd0ZXh0JyxcbiAgICBldmVudDogJ3RleHRDaGFuZ2UnXG4gIH1cbn0pO1xucmVnaXN0ZXJFbGVtZW50KCdUaW1lUGlja2VyJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZSgnQG5hdGl2ZXNjcmlwdC9jb3JlJykuVGltZVBpY2tlcjsgfSwge1xuICBtb2RlbDoge1xuICAgIHByb3A6ICd0aW1lJyxcbiAgICBldmVudDogJ3RpbWVDaGFuZ2UnXG4gIH1cbn0pO1xucmVnaXN0ZXJFbGVtZW50KCdXZWJWaWV3JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZSgnQG5hdGl2ZXNjcmlwdC9jb3JlJykuV2ViVmlldzsgfSk7XG5yZWdpc3RlckVsZW1lbnQoJ1dyYXBMYXlvdXQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5XcmFwTGF5b3V0OyB9KTtcbnJlZ2lzdGVyRWxlbWVudChcbiAgJ0Zvcm1hdHRlZFN0cmluZycsXG4gIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJ0BuYXRpdmVzY3JpcHQvY29yZScpLkZvcm1hdHRlZFN0cmluZzsgfSxcbiAge1xuICAgIGluc2VydENoaWxkOiBmdW5jdGlvbiBpbnNlcnRDaGlsZChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIGF0SW5kZXgpIHtcbiAgICAgIGlmIChhdEluZGV4ID4gLTEpIHtcbiAgICAgICAgcGFyZW50Tm9kZS5uYXRpdmVWaWV3LnNwYW5zLnNwbGljZShhdEluZGV4LCAwLCBjaGlsZE5vZGUubmF0aXZlVmlldyk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcGFyZW50Tm9kZS5uYXRpdmVWaWV3LnNwYW5zLnB1c2goY2hpbGROb2RlLm5hdGl2ZVZpZXcpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudE5vZGUsIGNoaWxkTm9kZSkge1xuICAgICAgdmFyIGluZGV4ID0gcGFyZW50Tm9kZS5uYXRpdmVWaWV3LnNwYW5zLmluZGV4T2YoY2hpbGROb2RlLm5hdGl2ZVZpZXcpO1xuXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICBwYXJlbnROb2RlLm5hdGl2ZVZpZXcuc3BhbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbik7XG5yZWdpc3RlckVsZW1lbnQoJ1NwYW4nLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5TcGFuOyB9KTtcblxucmVnaXN0ZXJFbGVtZW50KFxuICAnRGV0YWNoZWRDb250YWluZXInLFxuICBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5Qcm94eVZpZXdDb250YWluZXI7IH0sXG4gIHtcbiAgICBza2lwQWRkVG9Eb206IHRydWVcbiAgfVxuKTtcbnJlZ2lzdGVyRWxlbWVudChcbiAgJ0RldGFjaGVkVGV4dCcsXG4gIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJ0BuYXRpdmVzY3JpcHQvY29yZScpLlBsYWNlaG9sZGVyOyB9LFxuICB7XG4gICAgc2tpcEFkZFRvRG9tOiB0cnVlXG4gIH1cbik7XG5yZWdpc3RlckVsZW1lbnQoJ0NvbW1lbnQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5QbGFjZWhvbGRlcjsgfSk7XG5cbnJlZ2lzdGVyRWxlbWVudChcbiAgJ0RvY3VtZW50JyxcbiAgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZSgnQG5hdGl2ZXNjcmlwdC9jb3JlJykuUHJveHlWaWV3Q29udGFpbmVyOyB9LFxuICB7XG4gICAgc2tpcEFkZFRvRG9tOiB0cnVlXG4gIH1cbik7XG5cbnJlZ2lzdGVyRWxlbWVudCgnRnJhbWUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5GcmFtZTsgfSwge1xuICBpbnNlcnRDaGlsZDogZnVuY3Rpb24gaW5zZXJ0Q2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCBhdEluZGV4KSB7XG4gICAgLy8gaWYgKG5vcm1hbGl6ZUVsZW1lbnROYW1lKGNoaWxkTm9kZS50YWdOYW1lKSA9PT0gJ25hdGl2ZXBhZ2UnKSB7XG4gICAgLy8gcGFyZW50Tm9kZS5uYXRpdmVWaWV3Lm5hdmlnYXRlKHsgY3JlYXRlOiAoKSA9PiBjaGlsZE5vZGUubmF0aXZlVmlldyB9KVxuICAgIC8vIH1cbiAgfSxcbiAgY29tcG9uZW50OiBmcmFtZVxufSk7XG5cbi8qIVxuICogaXNvYmplY3QgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzb2JqZWN0PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG52YXIgaXNvYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkodmFsKSA9PT0gZmFsc2U7XG59O1xuXG4vKiFcbiAqIGlzLXBsYWluLW9iamVjdCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtcGxhaW4tb2JqZWN0PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5cblxuZnVuY3Rpb24gaXNPYmplY3RPYmplY3Qobykge1xuICByZXR1cm4gaXNvYmplY3QobykgPT09IHRydWVcbiAgICAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG52YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qobykge1xuICB2YXIgY3Rvcixwcm90O1xuXG4gIGlmIChpc09iamVjdE9iamVjdChvKSA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gSWYgaGFzIG1vZGlmaWVkIGNvbnN0cnVjdG9yXG4gIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICBpZiAodHlwZW9mIGN0b3IgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gSWYgaGFzIG1vZGlmaWVkIHByb3RvdHlwZVxuICBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gIGlmIChpc09iamVjdE9iamVjdChwcm90KSA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gSWYgY29uc3RydWN0b3IgZG9lcyBub3QgaGF2ZSBhbiBPYmplY3Qtc3BlY2lmaWMgbWV0aG9kXG4gIGlmIChwcm90Lmhhc093blByb3BlcnR5KCdpc1Byb3RvdHlwZU9mJykgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gTW9zdCBsaWtlbHkgYSBwbGFpbiBPYmplY3RcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKiFcbiAqIHNldC12YWx1ZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvc2V0LXZhbHVlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE4LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5cblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcGF0aCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHBhdGgpO1xuICBpZiAoIWlzQXJyYXkgJiYgdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHZhciBtZXJnZSA9IG9wdHMubWVyZ2U7XG4gIGlmIChtZXJnZSAmJiB0eXBlb2YgbWVyZ2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICBtZXJnZSA9IE9iamVjdC5hc3NpZ247XG4gIH1cblxuICB2YXIga2V5cyA9IChpc0FycmF5ID8gcGF0aCA6IHNwbGl0KHBhdGgsIG9wdHMpKS5maWx0ZXIoaXNWYWxpZEtleSk7XG4gIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgdmFyIG9yaWcgPSB0YXJnZXQ7XG5cbiAgaWYgKCFvcHRpb25zICYmIGtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmVzdWx0KHRhcmdldCwga2V5c1swXSwgdmFsdWUsIG1lcmdlKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwcm9wID0ga2V5c1tpXTtcblxuICAgIGlmICghaXNPYmplY3QodGFyZ2V0W3Byb3BdKSkge1xuICAgICAgdGFyZ2V0W3Byb3BdID0ge307XG4gICAgfVxuXG4gICAgaWYgKGkgPT09IGxlbiAtIDEpIHtcbiAgICAgIHJlc3VsdCh0YXJnZXQsIHByb3AsIHZhbHVlLCBtZXJnZSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0YXJnZXQgPSB0YXJnZXRbcHJvcF07XG4gIH1cblxuICByZXR1cm4gb3JpZztcbn1cblxuZnVuY3Rpb24gcmVzdWx0KHRhcmdldCwgcGF0aCwgdmFsdWUsIG1lcmdlKSB7XG4gIGlmIChtZXJnZSAmJiBpc1BsYWluT2JqZWN0KHRhcmdldFtwYXRoXSkgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB0YXJnZXRbcGF0aF0gPSBtZXJnZSh7fSwgdGFyZ2V0W3BhdGhdLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0W3BhdGhdID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3BsaXQocGF0aCwgb3B0aW9ucykge1xuICB2YXIgaWQgPSBjcmVhdGVLZXkocGF0aCwgb3B0aW9ucyk7XG4gIGlmIChzZXQubWVtb1tpZF0pIHsgcmV0dXJuIHNldC5tZW1vW2lkXTsgfVxuXG4gIHZhciBjaGFyID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXBhcmF0b3IpID8gb3B0aW9ucy5zZXBhcmF0b3IgOiAnLic7XG4gIHZhciBrZXlzID0gW107XG4gIHZhciByZXMgPSBbXTtcblxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5zcGxpdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGtleXMgPSBvcHRpb25zLnNwbGl0KHBhdGgpO1xuICB9IGVsc2Uge1xuICAgIGtleXMgPSBwYXRoLnNwbGl0KGNoYXIpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBrZXlzW2ldO1xuICAgIHdoaWxlIChwcm9wICYmIHByb3Auc2xpY2UoLTEpID09PSAnXFxcXCcgJiYga2V5c1tpICsgMV0gIT0gbnVsbCkge1xuICAgICAgcHJvcCA9IHByb3Auc2xpY2UoMCwgLTEpICsgY2hhciArIGtleXNbKytpXTtcbiAgICB9XG4gICAgcmVzLnB1c2gocHJvcCk7XG4gIH1cbiAgc2V0Lm1lbW9baWRdID0gcmVzO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXkocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgaWQgPSBwYXR0ZXJuO1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGlkICsgJyc7XG4gIH1cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWQgKz0gJzsnICsga2V5ICsgJz0nICsgU3RyaW5nKG9wdGlvbnNba2V5XSk7XG4gIH1cbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICByZXR1cm4ga2V5ICE9PSAnX19wcm90b19fJyAmJiBrZXkgIT09ICdjb25zdHJ1Y3RvcicgJiYga2V5ICE9PSAncHJvdG90eXBlJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpO1xufVxuXG5zZXQubWVtbyA9IHt9O1xudmFyIHNldFZhbHVlID0gc2V0O1xuXG52YXIgVmlldztcbmZ1bmN0aW9uIGlzVmlldyh2aWV3KSB7XG4gIGlmICghVmlldykge1xuICAgIFZpZXcgPSByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5WaWV3O1xuICB9XG4gIHJldHVybiB2aWV3IGluc3RhbmNlb2YgVmlld1xufVxuXG52YXIgTGF5b3V0QmFzZTtcbmZ1bmN0aW9uIGlzTGF5b3V0KHZpZXcpIHtcbiAgaWYgKCFMYXlvdXRCYXNlKSB7XG4gICAgTGF5b3V0QmFzZSA9IHJlcXVpcmUoJ0BuYXRpdmVzY3JpcHQvY29yZScpLkxheW91dEJhc2U7XG4gIH1cbiAgcmV0dXJuIHZpZXcgaW5zdGFuY2VvZiBMYXlvdXRCYXNlXG59XG5cbnZhciBDb250ZW50VmlldztcbmZ1bmN0aW9uIGlzQ29udGVudFZpZXcodmlldykge1xuICBpZiAoIUNvbnRlbnRWaWV3KSB7XG4gICAgQ29udGVudFZpZXcgPSByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5Db250ZW50VmlldztcbiAgfVxuICByZXR1cm4gdmlldyBpbnN0YW5jZW9mIENvbnRlbnRWaWV3XG59XG5cbmZ1bmN0aW9uIGluc2VydENoaWxkKHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgYXRJbmRleCkge1xuICBpZiAoIGF0SW5kZXggPT09IHZvaWQgMCApIGF0SW5kZXggPSAtMTtcblxuICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChwYXJlbnROb2RlLm1ldGEgJiYgdHlwZW9mIHBhcmVudE5vZGUubWV0YS5pbnNlcnRDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwYXJlbnROb2RlLm1ldGEuaW5zZXJ0Q2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCBhdEluZGV4KVxuICB9XG5cbiAgaWYgKGNoaWxkTm9kZS5tZXRhLnNraXBBZGRUb0RvbSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHBhcmVudFZpZXcgPSBwYXJlbnROb2RlLm5hdGl2ZVZpZXc7XG4gIHZhciBjaGlsZFZpZXcgPSBjaGlsZE5vZGUubmF0aXZlVmlldztcblxuICBpZiAoaXNMYXlvdXQocGFyZW50VmlldykpIHtcbiAgICBpZiAoY2hpbGRWaWV3LnBhcmVudCA9PT0gcGFyZW50Vmlldykge1xuICAgICAgdmFyIGluZGV4ID0gcGFyZW50Vmlldy5nZXRDaGlsZEluZGV4KGNoaWxkVmlldyk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHBhcmVudFZpZXcucmVtb3ZlQ2hpbGQoY2hpbGRWaWV3KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0SW5kZXggIT09IC0xKSB7XG4gICAgICBwYXJlbnRWaWV3Lmluc2VydENoaWxkKGNoaWxkVmlldywgYXRJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudFZpZXcuYWRkQ2hpbGQoY2hpbGRWaWV3KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNDb250ZW50VmlldyhwYXJlbnRWaWV3KSkge1xuICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgIHBhcmVudFZpZXcuX2FkZFZpZXcoY2hpbGRWaWV3LCBhdEluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Vmlldy5jb250ZW50ID0gY2hpbGRWaWV3O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWaWV3ICYmIHBhcmVudFZpZXcuX2FkZENoaWxkRnJvbUJ1aWxkZXIpIHtcbiAgICBwYXJlbnRWaWV3Ll9hZGRDaGlsZEZyb21CdWlsZGVyKFxuICAgICAgY2hpbGROb2RlLl9uYXRpdmVWaWV3LmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICBjaGlsZFZpZXdcbiAgICApO1xuICB9IGVsc2UgO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCQxKHBhcmVudE5vZGUsIGNoaWxkTm9kZSkge1xuICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChwYXJlbnROb2RlLm1ldGEgJiYgdHlwZW9mIHBhcmVudE5vZGUubWV0YS5yZW1vdmVDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwYXJlbnROb2RlLm1ldGEucmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlKVxuICB9XG5cbiAgaWYgKGNoaWxkTm9kZS5tZXRhLnNraXBBZGRUb0RvbSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHBhcmVudFZpZXcgPSBwYXJlbnROb2RlLm5hdGl2ZVZpZXc7XG4gIHZhciBjaGlsZFZpZXcgPSBjaGlsZE5vZGUubmF0aXZlVmlldztcblxuICBpZiAoaXNMYXlvdXQocGFyZW50VmlldykpIHtcbiAgICBwYXJlbnRWaWV3LnJlbW92ZUNoaWxkKGNoaWxkVmlldyk7XG4gIH0gZWxzZSBpZiAoaXNDb250ZW50VmlldyhwYXJlbnRWaWV3KSkge1xuICAgIGlmIChwYXJlbnRWaWV3LmNvbnRlbnQgPT09IGNoaWxkVmlldykge1xuICAgICAgcGFyZW50Vmlldy5jb250ZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICBwYXJlbnRWaWV3Ll9yZW1vdmVWaWV3KGNoaWxkVmlldyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmlldyhwYXJlbnRWaWV3KSkge1xuICAgIHBhcmVudFZpZXcuX3JlbW92ZVZpZXcoY2hpbGRWaWV3KTtcbiAgfSBlbHNlIDtcbn1cblxudmFyIFhNTF9BVFRSSUJVVEVTID0gT2JqZWN0LmZyZWV6ZShbXG4gICdzdHlsZScsXG4gICdyb3dzJyxcbiAgJ2NvbHVtbnMnLFxuICAnZm9udEF0dHJpYnV0ZXMnXG5dKTtcblxudmFyIFZpZXdOb2RlID0gZnVuY3Rpb24gVmlld05vZGUoKSB7XG4gIHRoaXMubm9kZVR5cGUgPSBudWxsO1xuICB0aGlzLl90YWdOYW1lID0gbnVsbDtcbiAgdGhpcy5wYXJlbnROb2RlID0gbnVsbDtcbiAgdGhpcy5jaGlsZE5vZGVzID0gW107XG4gIHRoaXMucHJldlNpYmxpbmcgPSBudWxsO1xuICB0aGlzLm5leHRTaWJsaW5nID0gbnVsbDtcblxuICB0aGlzLl9vd25lckRvY3VtZW50ID0gbnVsbDtcbiAgdGhpcy5fbmF0aXZlVmlldyA9IG51bGw7XG4gIHRoaXMuX21ldGEgPSBudWxsO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAqIG1ha2UgdnVlIGhhcHB5IDopXG4gICAqL1xuICB0aGlzLmhhc0F0dHJpYnV0ZSA9IHRoaXMucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyB0YWdOYW1lOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGZpcnN0Q2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sbGFzdENoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LG5hdGl2ZVZpZXc6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sbWV0YTogeyBjb25maWd1cmFibGU6IHRydWUgfSxvd25lckRvY3VtZW50OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5WaWV3Tm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiAoKHRoaXMuY29uc3RydWN0b3IubmFtZSkgKyBcIihcIiArICh0aGlzLnRhZ05hbWUpICsgXCIpXCIpXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMudGFnTmFtZS5zZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICB0aGlzLl90YWdOYW1lID0gbm9ybWFsaXplRWxlbWVudE5hbWUobmFtZSk7XG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMudGFnTmFtZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl90YWdOYW1lXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuZmlyc3RDaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoID8gdGhpcy5jaGlsZE5vZGVzWzBdIDogbnVsbFxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmxhc3RDaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoXG4gICAgPyB0aGlzLmNoaWxkTm9kZXNbdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDFdXG4gICAgOiBudWxsXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMubmF0aXZlVmlldy5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9uYXRpdmVWaWV3XG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMubmF0aXZlVmlldy5zZXQgPSBmdW5jdGlvbiAodmlldykge1xuICBpZiAodGhpcy5fbmF0aXZlVmlldykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IG92ZXJyaWRlIG5hdGl2ZSB2aWV3LlwiKVxuICB9XG5cbiAgdGhpcy5fbmF0aXZlVmlldyA9IHZpZXc7XG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMubWV0YS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9tZXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ldGFcbiAgfVxuXG4gIHJldHVybiAodGhpcy5fbWV0YSA9IGdldFZpZXdNZXRhKHRoaXMudGFnTmFtZSkpXG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLm93bmVyRG9jdW1lbnQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fb3duZXJEb2N1bWVudCkge1xuICAgIHJldHVybiB0aGlzLl9vd25lckRvY3VtZW50XG4gIH1cblxuICB2YXIgZWwgPSB0aGlzO1xuICB3aGlsZSAoKGVsID0gZWwucGFyZW50Tm9kZSkubm9kZVR5cGUgIT09IDkpIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH1cblxuICByZXR1cm4gKHRoaXMuX293bmVyRG9jdW1lbnQgPSBlbClcbn07XG5cblZpZXdOb2RlLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUgKGtleSkge1xuICByZXR1cm4gdGhpcy5uYXRpdmVWaWV3W2tleV1cbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5WaWV3Tm9kZS5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlIChrZXksIHZhbHVlKSB7XG4gIHZhciBpc0FuZHJvaWQgPSBnbG9iYWwuaXNBbmRyb2lkO1xuICB2YXIgaXNJT1MgPSBnbG9iYWwuaXNJT1M7XG4gIHZhciBudiA9IHRoaXMubmF0aXZlVmlldztcblxuICB0cnkge1xuICAgIGlmIChYTUxfQVRUUklCVVRFUy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICBudltrZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRldGVjdCBleHBhbmRhYmxlIGF0dHJzIGZvciBib29sZWFuIHZhbHVlc1xuICAgICAgLy8gU2VlIGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMtcHJvcHMuaHRtbCNQYXNzaW5nLWEtQm9vbGVhblxuICAgICAgaWYgKFxuICAgICAgICByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5VdGlscy5pc0Jvb2xlYW4obnZba2V5XSkgJiZcbiAgICAgICAgdmFsdWUgPT09ICcnXG4gICAgICApIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNBbmRyb2lkICYmIGtleS5zdGFydHNXaXRoKCdhbmRyb2lkOicpKSB7XG4gICAgICAgIHNldFZhbHVlKG52LCBrZXkuc3Vic3RyKDgpLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzSU9TICYmIGtleS5zdGFydHNXaXRoKCdpb3M6JykpIHtcbiAgICAgICAgc2V0VmFsdWUobnYsIGtleS5zdWJzdHIoNCksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5LmVuZHNXaXRoKCcuZGVjb2RlJykpIHtcbiAgICAgICAgc2V0VmFsdWUoXG4gICAgICAgICAgbnYsXG4gICAgICAgICAga2V5LnNsaWNlKDAsIC03KSxcbiAgICAgICAgICByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5YbWxQYXJzZXIuX2RlcmVmZXJlbmNlRW50aXRpZXModmFsdWUpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRWYWx1ZShudiwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaWdub3JlXG4gIH1cbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5WaWV3Tm9kZS5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbiBzZXRTdHlsZSAocHJvcGVydHksIHZhbHVlKSB7XG4gIGlmICghdmFsdWUgfHwgISh2YWx1ZSA9IHZhbHVlLnRyaW0oKSkubGVuZ3RoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocHJvcGVydHkuZW5kc1dpdGgoJ0FsaWduJykpIHtcbiAgICAvLyBOYXRpdmVTY3JpcHQgdXNlcyBBbGlnbm1lbnQgaW5zdGVhZCBvZiBBbGlnbiwgdGhpcyBlbnN1cmVzIHRoYXQgdGV4dC1hbGlnbiB3b3Jrc1xuICAgIHByb3BlcnR5ICs9ICdtZW50JztcbiAgfVxuICB0aGlzLm5hdGl2ZVZpZXcuc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuVmlld05vZGUucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiBzZXRUZXh0ICh0ZXh0KSB7XG4gIGlmICh0aGlzLm5vZGVUeXBlID09PSAzKSB7XG4gICAgdGhpcy5wYXJlbnROb2RlLnNldFRleHQodGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RleHQnLCB0ZXh0KTtcbiAgfVxufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblZpZXdOb2RlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lciAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgdGhpcy5uYXRpdmVWaWV3Lm9uKGV2ZW50LCBoYW5kbGVyKTtcbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5WaWV3Tm9kZS5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIgKGV2ZW50KSB7XG4gIHRoaXMubmF0aXZlVmlldy5vZmYoZXZlbnQpO1xufTtcblxuVmlld05vZGUucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZSAoY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIGlmICghY2hpbGROb2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgaW5zZXJ0IGNoaWxkLlwiKVxuICB9XG5cbiAgaWYgKFxuICAgIHJlZmVyZW5jZU5vZGUgJiZcbiAgICByZWZlcmVuY2VOb2RlLnBhcmVudE5vZGUgJiZcbiAgICByZWZlcmVuY2VOb2RlLnBhcmVudE5vZGUgIT09IHRoaXNcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJDYW4ndCBpbnNlcnQgY2hpbGQsIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBub2RlIGhhcyBhIGRpZmZlcmVudCBwYXJlbnQuXCJcbiAgICApXG4gIH1cblxuICBpZiAoY2hpbGROb2RlLnBhcmVudE5vZGUgJiYgY2hpbGROb2RlLnBhcmVudE5vZGUgIT09IHRoaXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkNhbid0IGluc2VydCBjaGlsZCwgYmVjYXVzZSBpdCBhbHJlYWR5IGhhcyBhIGRpZmZlcmVudCBwYXJlbnQuXCJcbiAgICApXG4gIH1cblxuICBpZiAoY2hpbGROb2RlLnBhcmVudE5vZGUgPT09IHRoaXMpIHtcbiAgICAvLyBpbiBjYXNlIHRoZSBjaGlsZE5vZGUgaXMgYWxyZWFkeSBhIGNoaWxkIG5vZGUgb2YgdGhpcyB2aWV3XG4gICAgLy8gd2UgbmVlZCB0byBmaXJzdCByZW1vdmUgaXQgdG8gY2xlYW4gdXAgY2hpbGROb2RlcywgcGFyZW50Tm9kZSwgcHJldi9uZXh0IHNpYmxpbmdzXG4gICAgLy8gd2UgYXJlIGFkZGluZyBiYWNrIHRoZSBjaGlsZCByaWdodCBhZnRlciAtIHRoaXMgaXMgb2Z0ZW4gdGhlIGNhc2Ugd2hlbiB0aGUgb3JkZXJcbiAgICAvLyBvZiBjaGlsZHJlbiBoYXMgdG8gY2hhbmdlIChpbmNsdWRpbmcgY29tbWVudCBub2RlcyBjcmVhdGVkIGJ5IHZ1ZSlcbiAgICAvLyBmaXhlcyAjNjA4XG4gICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZE5vZGUpO1xuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gdGhyb3cgYW4gZXJyb3IgaGVyZSwgYmVjYXVzZSBpdCBpcyBhIHZhbGlkIGNhc2VcbiAgICAvLyBmb3IgZXhhbXBsZSB3aGVuIHN3aXRjaGluZyB0aGUgb3JkZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWVcbiAgICAvLyBmaXhlcyAjMTI3IC0gc2VlIGZvciBtb3JlIGRldGFpbHNcbiAgICAvLyBmaXhlcyAjMjQwXG4gICAgLy8gdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBpbnNlcnQgY2hpbGQsIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSBhIGNoaWxkLmApXG4gIH1cblxuICAvLyBpbiBzb21lIHJhcmUgY2FzZXMgaW5zZXJ0QmVmb3JlIGlzIGNhbGxlZCB3aXRoIGEgbnVsbCByZWZlcmVuY2VOb2RlXG4gIC8vIHRoaXMgbWFrZXMgc3VyZSB0aGF0IGl0IGdldCdzIGFwcGVuZGVkIGFzIHRoZSBsYXN0IGNoaWxkXG4gIGlmICghcmVmZXJlbmNlTm9kZSkge1xuICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKGNoaWxkTm9kZSlcbiAgfVxuXG4gIHZhciBpbmRleCA9IHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKHJlZmVyZW5jZU5vZGUpO1xuXG4gIGNoaWxkTm9kZS5wYXJlbnROb2RlID0gdGhpcztcbiAgY2hpbGROb2RlLm5leHRTaWJsaW5nID0gcmVmZXJlbmNlTm9kZTtcbiAgY2hpbGROb2RlLnByZXZTaWJsaW5nID0gdGhpcy5jaGlsZE5vZGVzW2luZGV4IC0gMV07XG4gIGlmIChjaGlsZE5vZGUucHJldlNpYmxpbmcpIHsgY2hpbGROb2RlLnByZXZTaWJsaW5nLm5leHRTaWJsaW5nID0gY2hpbGROb2RlOyB9XG5cbiAgcmVmZXJlbmNlTm9kZS5wcmV2U2libGluZyA9IGNoaWxkTm9kZTtcbiAgdGhpcy5jaGlsZE5vZGVzLnNwbGljZShpbmRleCwgMCwgY2hpbGROb2RlKTtcblxuICBpbnNlcnRDaGlsZCh0aGlzLCBjaGlsZE5vZGUsIGluZGV4KTtcbn07XG5cblZpZXdOb2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIGFwcGVuZENoaWxkIChjaGlsZE5vZGUpIHtcbiAgaWYgKCFjaGlsZE5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhcHBlbmQgY2hpbGQuXCIpXG4gIH1cblxuICBpZiAoY2hpbGROb2RlLnBhcmVudE5vZGUgJiYgY2hpbGROb2RlLnBhcmVudE5vZGUgIT09IHRoaXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkNhbid0IGFwcGVuZCBjaGlsZCwgYmVjYXVzZSBpdCBhbHJlYWR5IGhhcyBhIGRpZmZlcmVudCBwYXJlbnQuXCJcbiAgICApXG4gIH1cblxuICBjaGlsZE5vZGUucGFyZW50Tm9kZSA9IHRoaXM7XG4gIGlmICh0aGlzLmxhc3RDaGlsZCkge1xuICAgIGNoaWxkTm9kZS5wcmV2U2libGluZyA9IHRoaXMubGFzdENoaWxkO1xuICAgIHRoaXMubGFzdENoaWxkLm5leHRTaWJsaW5nID0gY2hpbGROb2RlO1xuICB9XG5cbiAgdGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGROb2RlKTtcblxuICBpbnNlcnRDaGlsZCh0aGlzLCBjaGlsZE5vZGUpO1xufTtcblxuVmlld05vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKGNoaWxkTm9kZSkge1xuICBpZiAoIWNoaWxkTm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHJlbW92ZSBjaGlsZC5cIilcbiAgfVxuXG4gIGlmICghY2hpbGROb2RlLnBhcmVudE5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCByZW1vdmUgY2hpbGQsIGJlY2F1c2UgaXQgaGFzIG5vIHBhcmVudC5cIilcbiAgfVxuXG4gIGlmIChjaGlsZE5vZGUucGFyZW50Tm9kZSAhPT0gdGhpcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHJlbW92ZSBjaGlsZCwgYmVjYXVzZSBpdCBoYXMgYSBkaWZmZXJlbnQgcGFyZW50LlwiKVxuICB9XG5cbiAgY2hpbGROb2RlLnBhcmVudE5vZGUgPSBudWxsO1xuXG4gIGlmIChjaGlsZE5vZGUucHJldlNpYmxpbmcpIHtcbiAgICBjaGlsZE5vZGUucHJldlNpYmxpbmcubmV4dFNpYmxpbmcgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gIH1cblxuICBpZiAoY2hpbGROb2RlLm5leHRTaWJsaW5nKSB7XG4gICAgY2hpbGROb2RlLm5leHRTaWJsaW5nLnByZXZTaWJsaW5nID0gY2hpbGROb2RlLnByZXZTaWJsaW5nO1xuICB9XG5cbiAgLy8gcmVzZXQgdGhlIHByZXZTaWJsaW5nIGFuZCBuZXh0U2libGluZy4gSWYgbm90LCBhIGtlZXAtYWxpdmVkIGNvbXBvbmVudCB3aWxsXG4gIC8vIHN0aWxsIGhhdmUgYSBmaWxsZWQgbmV4dFNpYmxpbmcgYXR0cmlidXRlIHNvIHZ1ZSB3aWxsIG5vdFxuICAvLyBpbnNlcnQgdGhlIG5vZGUgYWdhaW4gdG8gdGhlIHBhcmVudC4gU2VlICMyMjBcbiAgY2hpbGROb2RlLnByZXZTaWJsaW5nID0gbnVsbDtcbiAgY2hpbGROb2RlLm5leHRTaWJsaW5nID0gbnVsbDtcblxuICB0aGlzLmNoaWxkTm9kZXMgPSB0aGlzLmNoaWxkTm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlICE9PSBjaGlsZE5vZGU7IH0pO1xuXG4gIHJlbW92ZUNoaWxkJDEodGhpcywgY2hpbGROb2RlKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWaWV3Tm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgVlVFX0VMRU1FTlRfUkVGID0gJ19fdnVlX2VsZW1lbnRfcmVmX18nO1xuXG52YXIgRWxlbWVudE5vZGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChWaWV3Tm9kZSkge1xuICBmdW5jdGlvbiBFbGVtZW50Tm9kZSh0YWdOYW1lKSB7XG4gICAgVmlld05vZGUuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMubm9kZVR5cGUgPSAxO1xuICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XG5cbiAgICB2YXIgdmlld0NsYXNzID0gZ2V0Vmlld0NsYXNzKHRhZ05hbWUpO1xuICAgIGlmICghdmlld0NsYXNzKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAoXCJObyBuYXRpdmUgY29tcG9uZW50IGZvciBlbGVtZW50IHRhZyBuYW1lIFwiICsgdGFnTmFtZSArIFwiLlwiKVxuICAgICAgKVxuICAgIH1cbiAgICB0aGlzLl9uYXRpdmVWaWV3ID0gbmV3IHZpZXdDbGFzcygpO1xuICAgIHRoaXMuX25hdGl2ZVZpZXdbVlVFX0VMRU1FTlRfUkVGXSA9IHRoaXM7XG4gIH1cblxuICBpZiAoIFZpZXdOb2RlICkgRWxlbWVudE5vZGUuX19wcm90b19fID0gVmlld05vZGU7XG4gIEVsZW1lbnROb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFZpZXdOb2RlICYmIFZpZXdOb2RlLnByb3RvdHlwZSApO1xuICBFbGVtZW50Tm9kZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFbGVtZW50Tm9kZTtcblxuICBFbGVtZW50Tm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmF0aXZlVmlldy50b1N0cmluZygpXG4gIH07XG5cbiAgRWxlbWVudE5vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKGNoaWxkTm9kZSkge1xuICAgIFZpZXdOb2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZC5jYWxsKHRoaXMsIGNoaWxkTm9kZSk7XG5cbiAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICB0aGlzLnNldFRleHQoY2hpbGROb2RlLnRleHQpO1xuICAgIH1cbiAgfTtcblxuICBFbGVtZW50Tm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICBWaWV3Tm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlLmNhbGwodGhpcywgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKTtcblxuICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIHRoaXMuc2V0VGV4dChjaGlsZE5vZGUudGV4dCk7XG4gICAgfVxuICB9O1xuXG4gIEVsZW1lbnROb2RlLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkIChjaGlsZE5vZGUpIHtcbiAgICBWaWV3Tm9kZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQuY2FsbCh0aGlzLCBjaGlsZE5vZGUpO1xuXG4gICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgdGhpcy5zZXRUZXh0KCcnKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEVsZW1lbnROb2RlO1xufShWaWV3Tm9kZSkpO1xuXG52YXIgQ29tbWVudE5vZGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFbGVtZW50Tm9kZSkge1xuICBmdW5jdGlvbiBDb21tZW50Tm9kZSh0ZXh0KSB7XG4gICAgRWxlbWVudE5vZGUuY2FsbCh0aGlzLCAnY29tbWVudCcpO1xuXG4gICAgdGhpcy5ub2RlVHlwZSA9IDg7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuXG4gIGlmICggRWxlbWVudE5vZGUgKSBDb21tZW50Tm9kZS5fX3Byb3RvX18gPSBFbGVtZW50Tm9kZTtcbiAgQ29tbWVudE5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRWxlbWVudE5vZGUgJiYgRWxlbWVudE5vZGUucHJvdG90eXBlICk7XG4gIENvbW1lbnROb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbW1lbnROb2RlO1xuXG4gIHJldHVybiBDb21tZW50Tm9kZTtcbn0oRWxlbWVudE5vZGUpKTtcblxudmFyIFRleHROb2RlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoVmlld05vZGUpIHtcbiAgZnVuY3Rpb24gVGV4dE5vZGUodGV4dCkge1xuICAgIFZpZXdOb2RlLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLm5vZGVUeXBlID0gMztcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuXG4gICAgdGhpcy5fbWV0YSA9IHtcbiAgICAgIHNraXBBZGRUb0RvbTogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBpZiAoIFZpZXdOb2RlICkgVGV4dE5vZGUuX19wcm90b19fID0gVmlld05vZGU7XG4gIFRleHROb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFZpZXdOb2RlICYmIFZpZXdOb2RlLnByb3RvdHlwZSApO1xuICBUZXh0Tm9kZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0Tm9kZTtcblxuICBUZXh0Tm9kZS5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uIHNldFRleHQgKHRleHQpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMucGFyZW50Tm9kZS5zZXRUZXh0KHRleHQpO1xuICB9O1xuXG4gIHJldHVybiBUZXh0Tm9kZTtcbn0oVmlld05vZGUpKTtcblxudmFyIERvY3VtZW50Tm9kZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFZpZXdOb2RlKSB7XG4gIGZ1bmN0aW9uIERvY3VtZW50Tm9kZSgpIHtcbiAgICBWaWV3Tm9kZS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5ub2RlVHlwZSA9IDk7XG4gICAgdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBuZXcgRWxlbWVudE5vZGUoJ2RvY3VtZW50Jyk7XG5cbiAgICAvLyBtYWtlIHN0YXRpYyBtZXRob2RzIGFjY2Vzc2libGUgdmlhIHRoaXNcbiAgICB0aGlzLmNyZWF0ZUNvbW1lbnQgPSB0aGlzLmNvbnN0cnVjdG9yLmNyZWF0ZUNvbW1lbnQ7XG4gICAgdGhpcy5jcmVhdGVFbGVtZW50ID0gdGhpcy5jb25zdHJ1Y3Rvci5jcmVhdGVFbGVtZW50O1xuICAgIHRoaXMuY3JlYXRlRWxlbWVudE5TID0gdGhpcy5jb25zdHJ1Y3Rvci5jcmVhdGVFbGVtZW50TlM7XG4gICAgdGhpcy5jcmVhdGVUZXh0Tm9kZSA9IHRoaXMuY29uc3RydWN0b3IuY3JlYXRlVGV4dE5vZGU7XG4gIH1cblxuICBpZiAoIFZpZXdOb2RlICkgRG9jdW1lbnROb2RlLl9fcHJvdG9fXyA9IFZpZXdOb2RlO1xuICBEb2N1bWVudE5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVmlld05vZGUgJiYgVmlld05vZGUucHJvdG90eXBlICk7XG4gIERvY3VtZW50Tm9kZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEb2N1bWVudE5vZGU7XG5cbiAgRG9jdW1lbnROb2RlLmNyZWF0ZUNvbW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgQ29tbWVudE5vZGUodGV4dClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgfVxuICB9O1xuXG4gIERvY3VtZW50Tm9kZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAodGFnTmFtZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEVsZW1lbnROb2RlKHRhZ05hbWUpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgIH1cbiAgfTtcblxuICBEb2N1bWVudE5vZGUuY3JlYXRlRWxlbWVudE5TID0gZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBFbGVtZW50Tm9kZShuYW1lc3BhY2UgKyAnOicgKyB0YWdOYW1lKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgRG9jdW1lbnROb2RlLmNyZWF0ZVRleHROb2RlID0gZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0ZXh0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIERvY3VtZW50Tm9kZTtcbn0oVmlld05vZGUpKTtcblxudmFyIG5hbWVzcGFjZU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZ05hbWUsIHZub2RlKSB7XG4gIHRyYWNlKChcIkNyZWF0ZUVsZW1lbnQoXCIgKyAodGFnTmFtZS5yZXBsYWNlKC9ebmF0aXZlL2ksICcnKSkgKyBcIilcIikpO1xuICByZXR1cm4gRG9jdW1lbnROb2RlLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICB0cmFjZSgoXCJDcmVhdGVFbGVtZW50TlMoXCIgKyBuYW1lc3BhY2UgKyBcIiNcIiArIHRhZ05hbWUgKyBcIilcIikpO1xuICByZXR1cm4gRG9jdW1lbnROb2RlLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlKHRleHQpIHtcbiAgdHJhY2UoKFwiQ3JlYXRlVGV4dE5vZGUoXCIgKyB0ZXh0ICsgXCIpXCIpKTtcbiAgcmV0dXJuIERvY3VtZW50Tm9kZS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50KHRleHQpIHtcbiAgdHJhY2UoKFwiQ3JlYXRlQ29tbWVudChcIiArIHRleHQgKyBcIilcIikpO1xuXG4gIHJldHVybiBEb2N1bWVudE5vZGUuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICB0cmFjZSgoXCJJbnNlcnRCZWZvcmUoXCIgKyBwYXJlbnROb2RlICsgXCIsIFwiICsgbmV3Tm9kZSArIFwiLCBcIiArIHJlZmVyZW5jZU5vZGUgKyBcIilcIikpO1xuICByZXR1cm4gcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSlcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQobm9kZSwgY2hpbGQpIHtcbiAgdHJhY2UoKFwiUmVtb3ZlQ2hpbGQoXCIgKyBub2RlICsgXCIsIFwiICsgY2hpbGQgKyBcIilcIikpO1xuICByZXR1cm4gbm9kZS5yZW1vdmVDaGlsZChjaGlsZClcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQobm9kZSwgY2hpbGQpIHtcbiAgdHJhY2UoKFwiQXBwZW5kQ2hpbGQoXCIgKyBub2RlICsgXCIsIFwiICsgY2hpbGQgKyBcIilcIikpO1xuXG4gIHJldHVybiBub2RlLmFwcGVuZENoaWxkKGNoaWxkKVxufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlKG5vZGUpIHtcbiAgdHJhY2UoKFwiUGFyZW50Tm9kZShcIiArIG5vZGUgKyBcIikgLT4gXCIgKyAobm9kZS5wYXJlbnROb2RlKSkpO1xuXG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcobm9kZSkge1xuICB0cmFjZSgoXCJOZXh0U2libGluZyhcIiArIG5vZGUgKyBcIikgLT4gXCIgKyAobm9kZS5uZXh0U2libGluZykpKTtcblxuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lKGVsZW1lbnROb2RlKSB7XG4gIHRyYWNlKChcIlRhZ05hbWUoXCIgKyBlbGVtZW50Tm9kZSArIFwiKSAtPiBcIiArIChlbGVtZW50Tm9kZS50YWdOYW1lKSkpO1xuXG4gIHJldHVybiBlbGVtZW50Tm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50KG5vZGUsIHRleHQpIHtcbiAgdHJhY2UoKFwiU2V0VGV4dENvbnRlbnQoXCIgKyBub2RlICsgXCIsIFwiICsgdGV4dCArIFwiKVwiKSk7XG5cbiAgbm9kZS5zZXRUZXh0KHRleHQpO1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUobm9kZSwga2V5LCB2YWwpIHtcbiAgdHJhY2UoKFwiU2V0QXR0cmlidXRlKFwiICsgbm9kZSArIFwiLCBcIiArIGtleSArIFwiLCBcIiArIHZhbCArIFwiKVwiKSk7XG5cbiAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlKG5vZGUsIHNjb3BlSWQpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoc2NvcGVJZCwgJycpO1xufVxuXG52YXIgbm9kZU9wcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBuYW1lc3BhY2VNYXA6IG5hbWVzcGFjZU1hcCxcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgc2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGUsXG4gIHNldFN0eWxlU2NvcGU6IHNldFN0eWxlU2NvcGVcbn0pO1xuXG52YXIgbW9kdWxlcyQxID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oe1xuICBub2RlT3BzOiBub2RlT3BzLFxuICBtb2R1bGVzOiBtb2R1bGVzJDFcbn0pO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZGVjb2RlXG59O1xuXG5mdW5jdGlvbiBkZWNvZGUoaHRtbCkge1xuICAvLyB0b2RvP1xuICByZXR1cm4gaHRtbFxufVxuXG4vKiAgKi9cblxubWFrZU1hcChcbiAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInXG4pO1xuXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cbi8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbm1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbnZhciBkeW5hbWljQXJnQXR0cmlidXRlID0gL15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XStcXF1bXlxcc1wiJzw+XFwvPV0qKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xudmFyIG5jbmFtZSA9IFwiW2EtekEtWl9dW1xcXFwtXFxcXC4wLTlfYS16QS1aXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCJdKlwiO1xudmFyIHFuYW1lQ2FwdHVyZSA9IFwiKCg/OlwiICsgbmNuYW1lICsgXCJcXFxcOik/XCIgKyBuY25hbWUgKyBcIilcIjtcbnZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKChcIl48XCIgKyBxbmFtZUNhcHR1cmUpKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgoXCJePFxcXFwvXCIgKyBxbmFtZUNhcHR1cmUgKyBcIltePl0qPlwiKSk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xuLy8gIzcyOTg6IGVzY2FwZSAtIHRvIGF2b2lkIGJlaW5nIHBhc3NlZCBhcyBIVE1MIGNvbW1lbnQgd2hlbiBpbmxpbmVkIGluIHBhZ2VcbnZhciBjb21tZW50ID0gL148IVxcLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJyxcbiAgJyYjOTsnOiAnXFx0JyxcbiAgJyYjMzk7JzogXCInXCJcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOSk7L2c7XG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOXwjMTB8IzkpOy9nO1xuXG4vLyAjNTk5MlxudmFyIGlzSWdub3JlTmV3bGluZVRhZyA9IG1ha2VNYXAoJ3ByZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHNob3VsZElnbm9yZUZpcnN0TmV3bGluZSA9IGZ1bmN0aW9uICh0YWcsIGh0bWwpIHsgcmV0dXJuIHRhZyAmJiBpc0lnbm9yZU5ld2xpbmVUYWcodGFnKSAmJiBodG1sWzBdID09PSAnXFxuJzsgfTtcblxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gIHZhciByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gZGVjb2RpbmdNYXBbbWF0Y2hdOyB9KVxufVxuXG5mdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICB2YXIgaXNVbmFyeVRhZyA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgdmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xuXG4gICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGNvbW1lbnRFbmQpLCBpbmRleCwgaW5kZXggKyBjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XG4gICAgICAgICAgICBhZHZhbmNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdC5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEVuZCA8IDApIHtcbiAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGFkdmFuY2UodGV4dC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCwgaW5kZXggLSB0ZXh0Lmxlbmd0aCwgaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJykgLy8gIzcyOThcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdCQxLmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0JDE7XG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XG4gICAgICBvcHRpb25zLmNoYXJzICYmIG9wdGlvbnMuY2hhcnMoaHRtbCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpLCB7IHN0YXJ0OiBpbmRleCArIGh0bWwubGVuZ3RoIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goZHluYW1pY0FyZ0F0dHJpYnV0ZSkgfHwgaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICBhdHRyLnN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICBhdHRyLmVuZCA9IGluZGV4O1xuICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgIGlmIChleHBlY3RIVE1MKSB7XG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmFyeSA9IGlzVW5hcnlUYWcodGFnTmFtZSkgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSB0YWdOYW1lID09PSAnYScgJiYgYXJnc1sxXSA9PT0gJ2hyZWYnXG4gICAgICAgID8gb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWZcbiAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgIH07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gYXJncy5zdGFydCArIGFyZ3NbMF0ubWF0Y2goL15cXHMqLykubGVuZ3RoO1xuICAgICAgICBhdHRyc1tpXS5lbmQgPSBhcmdzLmVuZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycywgc3RhcnQ6IG1hdGNoLnN0YXJ0LCBlbmQ6IG1hdGNoLmVuZCB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7IGVuZCA9IGluZGV4OyB9XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxuICAgICAgICAgIG9wdGlvbnMud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpLFxuICAgICAgICAgICAgeyBzdGFydDogc3RhY2tbaV0uc3RhcnQsIGVuZDogc3RhY2tbaV0uZW5kIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMgKGV4cCkge1xuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgdmFyIGluRG91YmxlID0gZmFsc2U7XG4gIHZhciBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gIHZhciBjdXJseSA9IDA7XG4gIHZhciBzcXVhcmUgPSAwO1xuICB2YXIgcGFyZW4gPSAwO1xuICB2YXIgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgdmFyIGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIHsgaW5TaW5nbGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NUMpIHsgaW5SZWdleCA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgKGFyZ3MgIT09ICcpJyA/ICcsJyArIGFyZ3MgOiBhcmdzKSlcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgcmF3VG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG4gICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIiRzZXQoXCIgKyAocmVzLmV4cCkgKyBcIiwgXCIgKyAocmVzLmtleSkgKyBcIiwgXCIgKyBhc3NpZ25tZW50ICsgXCIpXCIpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogUG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3Rba2V5XVxuICogLSB0ZXN0W3Rlc3QxW2tleV1dXG4gKiAtIHRlc3RbXCJhXCJdW2tleV1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2tleV1dXG4gKlxuICovXG5cbnZhciBsZW4sIHN0ciwgY2hyLCBpbmRleCwgZXhwcmVzc2lvblBvcywgZXhwcmVzc2lvbkVuZFBvcztcblxuXG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICAvLyBGaXggaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9wdWxsLzc3MzBcbiAgLy8gYWxsb3cgdi1tb2RlbD1cIm9iai52YWwgXCIgKHRyYWlsaW5nIHdoaXRlc3BhY2UpXG4gIHZhbCA9IHZhbC50cmltKCk7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuICAgIGluZGV4ID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAga2V5OiAnXCInICsgdmFsLnNsaWNlKGluZGV4ICsgMSkgKyAnXCInXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLFxuICAgICAgICBrZXk6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHIgPSB2YWw7XG4gIGluZGV4ID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXg7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4O1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2csIHJhbmdlKSB7XG4gIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSBjb21waWxlcl06IFwiICsgbXNnKSk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIHZhciBhdHRycyA9IGR5bmFtaWNcbiAgICA/IChlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKSlcbiAgICA6IChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpO1xuICBhdHRycy5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG4vLyBhZGQgYSByYXcgYXR0ciAodXNlIHRoaXMgaW4gcHJlVHJhbnNmb3JtcylcbmZ1bmN0aW9uIGFkZFJhd0F0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UpIHtcbiAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcbiAgZWwuYXR0cnNMaXN0LnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0sIHJhbmdlKSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBpc0R5bmFtaWNBcmcsXG4gIG1vZGlmaWVycyxcbiAgcmFuZ2Vcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oe1xuICAgIG5hbWU6IG5hbWUsXG4gICAgcmF3TmFtZTogcmF3TmFtZSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgYXJnOiBhcmcsXG4gICAgaXNEeW5hbWljQXJnOiBpc0R5bmFtaWNBcmcsXG4gICAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbiAgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyTWFya2VyIChzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcbiAgcmV0dXJuIGR5bmFtaWNcbiAgICA/IChcIl9wKFwiICsgbmFtZSArIFwiLFxcXCJcIiArIHN5bWJvbCArIFwiXFxcIilcIilcbiAgICA6IHN5bWJvbCArIG5hbWUgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbn1cblxuZnVuY3Rpb24gYWRkSGFuZGxlciAoXG4gIGVsLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzLFxuICBpbXBvcnRhbnQsXG4gIHdhcm4sXG4gIHJhbmdlLFxuICBkeW5hbWljXG4pIHtcbiAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4gJiZcbiAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJyxcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxuICAvLyB0aGUgb25seSB0YXJnZXQgZW52cyB0aGF0IGhhdmUgcmlnaHQvbWlkZGxlIGNsaWNrcy5cbiAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBuYW1lID0gXCIoXCIgKyBuYW1lICsgXCIpPT09J2NsaWNrJz8nY29udGV4dG1lbnUnOihcIiArIG5hbWUgKyBcIilcIjtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgIG5hbWUgPSAnY29udGV4dG1lbnUnO1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5yaWdodDtcbiAgICB9XG4gIH0gZWxzZSBpZiAobW9kaWZpZXJzLm1pZGRsZSkge1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBuYW1lID0gXCIoXCIgKyBuYW1lICsgXCIpPT09J2NsaWNrJz8nbW91c2V1cCc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdtb3VzZXVwJztcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCchJywgbmFtZSwgZHluYW1pYyk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJ34nLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyYnLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuXG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cblxuICB2YXIgbmV3SGFuZGxlciA9IHJhbmdlU2V0SXRlbSh7IHZhbHVlOiB2YWx1ZS50cmltKCksIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpO1xuICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgIG5ld0hhbmRsZXIubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG5cbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0UmF3QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIHJldHVybiBlbC5yYXdBdHRyc01hcFsnOicgKyBuYW1lXSB8fFxuICAgIGVsLnJhd0F0dHJzTWFwWyd2LWJpbmQ6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbbmFtZV1cbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgZ2V0U3RhdGljXG4pIHtcbiAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmVtb3ZlRnJvbU1hcFxuKSB7XG4gIHZhciB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZlRnJvbU1hcCkge1xuICAgIGRlbGV0ZSBlbC5hdHRyc01hcFtuYW1lXTtcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4IChcbiAgZWwsXG4gIG5hbWVcbikge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBhdHRyID0gbGlzdFtpXTtcbiAgICBpZiAobmFtZS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgcmV0dXJuIGF0dHJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmFuZ2VTZXRJdGVtIChcbiAgaXRlbSxcbiAgcmFuZ2Vcbikge1xuICBpZiAocmFuZ2UpIHtcbiAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5zdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgIGl0ZW0uZW5kID0gcmFuZ2UuZW5kO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8Xjp8XiMvO1xudmFyIGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcbnZhciBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xudmFyIGR5bmFtaWNBcmdSRSA9IC9eXFxbLipcXF0kLztcblxudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgYmluZFJFID0gL146fF5cXC58XnYtYmluZDovO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXFxdXSsoPz1bXlxcXV0qJCkvZztcblxudmFyIHNsb3RSRSA9IC9edi1zbG90KDp8JCl8XiMvO1xuXG52YXIgbGluZUJyZWFrUkUgPSAvW1xcclxcbl0vO1xudmFyIHdoaXRlc3BhY2VSRSA9IC9cXHMrL2c7XG5cbnZhciBpbnZhbGlkQXR0cmlidXRlUkUgPSAvW1xcc1wiJzw+XFwvPV0vO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xuXG52YXIgZW1wdHlTbG90U2NvcGVUb2tlbiA9IFwiX2VtcHR5X1wiO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcbnZhciBtYXliZUNvbXBvbmVudDtcblxuZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gIHRhZyxcbiAgYXR0cnMsXG4gIHBhcmVudFxuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMSxcbiAgICB0YWc6IHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBjaGlsZHJlbjogW11cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICBtYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcblxuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG5cbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHdoaXRlc3BhY2VPcHRpb24gPSBvcHRpb25zLndoaXRlc3BhY2U7XG4gIHZhciByb290O1xuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xuICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2csIHJhbmdlKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuKG1zZywgcmFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlRWxlbWVudCAoZWxlbWVudCkge1xuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuICAgIGlmICghaW5WUHJlICYmICFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgZWxlbWVudCA9IHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBlbGVtZW50ICE9PSByb290KSB7XG4gICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiLFxuICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbGVtZW50LnNsb3RTY29wZSkge1xuICAgICAgICAgIC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgLy8ga2VlcCBpdCBpbiB0aGUgY2hpbGRyZW4gbGlzdCBzbyB0aGF0IHYtZWxzZSgtaWYpIGNvbmRpdGlvbnMgY2FuXG4gICAgICAgICAgLy8gZmluZCBpdCBhcyB0aGUgcHJldiBub2RlLlxuICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIidcbiAgICAgICAgICA7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaW5hbCBjaGlsZHJlbiBjbGVhbnVwXG4gICAgLy8gZmlsdGVyIG91dCBzY29wZWQgc2xvdHNcbiAgICBlbGVtZW50LmNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuICEoYykuc2xvdFNjb3BlOyB9KTtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlIGFnYWluXG4gICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG5cbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvc3RUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaW1FbmRpbmdXaGl0ZXNwYWNlIChlbCkge1xuICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGVcbiAgICBpZiAoIWluUHJlKSB7XG4gICAgICB2YXIgbGFzdE5vZGU7XG4gICAgICB3aGlsZSAoXG4gICAgICAgIChsYXN0Tm9kZSA9IGVsLmNoaWxkcmVuW2VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdKSAmJlxuICAgICAgICBsYXN0Tm9kZS50eXBlID09PSAzICYmXG4gICAgICAgIGxhc3ROb2RlLnRleHQgPT09ICcgJ1xuICAgICAgKSB7XG4gICAgICAgIGVsLmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLicsXG4gICAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIG91dHB1dFNvdXJjZVJhbmdlOiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnksIHN0YXJ0JDEsIGVuZCkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBlbGVtZW50LnN0YXJ0ID0gc3RhcnQkMTtcbiAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZDtcbiAgICAgICAgICBlbGVtZW50LnJhd0F0dHJzTWFwID0gZWxlbWVudC5hdHRyc0xpc3QucmVkdWNlKGZ1bmN0aW9uIChjdW11bGF0ZWQsIGF0dHIpIHtcbiAgICAgICAgICAgIGN1bXVsYXRlZFthdHRyLm5hbWVdID0gYXR0cjtcbiAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWRcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBcIkludmFsaWQgZHluYW1pYyBhcmd1bWVudCBleHByZXNzaW9uOiBhdHRyaWJ1dGUgbmFtZXMgY2Fubm90IGNvbnRhaW4gXCIgK1xuICAgICAgICAgICAgICBcInNwYWNlcywgcXVvdGVzLCA8LCA+LCAvIG9yID0uXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGFydDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5pbmRleE9mKFwiW1wiKSxcbiAgICAgICAgICAgICAgICBlbmQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUubGVuZ3RoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJyxcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICh0YWcsIHN0YXJ0LCBlbmQkMSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgIGVsZW1lbnQuZW5kID0gZW5kJDE7XG4gICAgICB9XG4gICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LicsXG4gICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YXJ0IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpLFxuICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgaWYgKGluUHJlIHx8IHRleHQudHJpbSgpKSB7XG4gICAgICAgIHRleHQgPSBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAvLyByZW1vdmUgdGhlIHdoaXRlc3BhY2Utb25seSBub2RlIHJpZ2h0IGFmdGVyIGFuIG9wZW5pbmcgdGFnXG4gICAgICAgIHRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAod2hpdGVzcGFjZU9wdGlvbikge1xuICAgICAgICBpZiAod2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xuICAgICAgICAgIC8vIGluIGNvbmRlbnNlIG1vZGUsIHJlbW92ZSB0aGUgd2hpdGVzcGFjZSBub2RlIGlmIGl0IGNvbnRhaW5zXG4gICAgICAgICAgLy8gbGluZSBicmVhaywgb3RoZXJ3aXNlIGNvbmRlbnNlIHRvIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgICAgdGV4dCA9IGxpbmVCcmVha1JFLnRlc3QodGV4dCkgPyAnJyA6ICcgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gJyAnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gcHJlc2VydmVXaGl0ZXNwYWNlID8gJyAnIDogJyc7XG4gICAgICB9XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBpZiAoIWluUHJlICYmIHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAvLyBjb25kZW5zZSBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlcyBpbnRvIHNpbmdsZSBzcGFjZVxuICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2Uod2hpdGVzcGFjZVJFLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgLy8gYWRkaW5nIGFueXRoaW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgLy8gY29tbWVudHMgc2hvdWxkIHN0aWxsIGJlIGFsbG93ZWQsIGJ1dCBpZ25vcmVkXG4gICAgICBpZiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICB2YXIgY2hpbGQgPSB7XG4gICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICBpZiAobGVuKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogbGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgICBpZiAobGlzdFtpXS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gbGlzdFtpXS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChcbiAgZWxlbWVudCxcbiAgb3B0aW9uc1xuKSB7XG4gIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gIGVsZW1lbnQucGxhaW4gPSAoXG4gICAgIWVsZW1lbnQua2V5ICYmXG4gICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcbiAgICAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoXG4gICk7XG5cbiAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdE91dGxldChlbGVtZW50KTtcbiAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgfVxuICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIixcbiAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZWwuZm9yKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGVsLml0ZXJhdG9yMiB8fCBlbC5pdGVyYXRvcjE7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgICAgIGlmIChpdGVyYXRvciAmJiBpdGVyYXRvciA9PT0gZXhwICYmIHBhcmVudCAmJiBwYXJlbnQudGFnID09PSAndHJhbnNpdGlvbi1ncm91cCcpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJEbyBub3QgdXNlIHYtZm9yIGluZGV4IGFzIGtleSBvbiA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4sIFwiICtcbiAgICAgICAgICAgIFwidGhpcyBpcyB0aGUgc2FtZSBhcyBub3QgdXNpbmcga2V5cy5cIixcbiAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksXG4gICAgICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VGb3IoZXhwKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICBleHRlbmQoZWwsIHJlcyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKSxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cblxuXG5mdW5jdGlvbiBwYXJzZUZvciAoZXhwKSB7XG4gIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcbiAgICByZXMuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXM7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiLFxuICAgICAgZWwucmF3QXR0cnNNYXBbZWwuZWxzZWlmID8gJ3YtZWxzZS1pZicgOiAndi1lbHNlJ11cbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiLFxuICAgICAgICAgIGNoaWxkcmVuW2ldXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBoYW5kbGUgY29udGVudCBiZWluZyBwYXNzZWQgdG8gYSBjb21wb25lbnQgYXMgc2xvdCxcbi8vIGUuZy4gPHRlbXBsYXRlIHNsb3Q9XCJ4eHhcIj4sIDxkaXYgc2xvdC1zY29wZT1cInh4eFwiPlxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RDb250ZW50IChlbCkge1xuICB2YXIgc2xvdFNjb3BlO1xuICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdFNjb3BlKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcInRoZSBcXFwic2NvcGVcXFwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBcIiArXG4gICAgICAgIFwicmVwbGFjZWQgYnkgXFxcInNsb3Qtc2NvcGVcXFwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcXFwic2xvdC1zY29wZVxcXCIgYXR0cmlidXRlIFwiICtcbiAgICAgICAgXCJjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gXCIgK1xuICAgICAgICBcImRlbm90ZSBzY29wZWQgc2xvdHMuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5hdHRyc01hcFsndi1mb3InXSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJBbWJpZ3VvdXMgY29tYmluZWQgdXNhZ2Ugb2Ygc2xvdC1zY29wZSBhbmQgdi1mb3Igb24gPFwiICsgKGVsLnRhZykgKyBcIj4gXCIgK1xuICAgICAgICBcIih2LWZvciB0YWtlcyBoaWdoZXIgcHJpb3JpdHkpLiBVc2UgYSB3cmFwcGVyIDx0ZW1wbGF0ZT4gZm9yIHRoZSBcIiArXG4gICAgICAgIFwic2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLlwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnc2xvdC1zY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGU7XG4gIH1cblxuICAvLyBzbG90PVwieHh4XCJcbiAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSAhIShlbC5hdHRyc01hcFsnOnNsb3QnXSB8fCBlbC5hdHRyc01hcFsndi1iaW5kOnNsb3QnXSk7XG4gICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHMuXG4gICAgaWYgKGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAnc2xvdCcpKTtcbiAgICB9XG4gIH1cblxuICAvLyAyLjYgdi1zbG90IHN5bnRheFxuICB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgLy8gdi1zbG90IG9uIDx0ZW1wbGF0ZT5cbiAgICAgIHZhciBzbG90QmluZGluZyA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgaWYgKHNsb3RCaW5kaW5nKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGVsLnNsb3RUYXJnZXQgfHwgZWwuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuXCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZSB2LXNsb3Q+IGNhbiBvbmx5IGFwcGVhciBhdCB0aGUgcm9vdCBsZXZlbCBpbnNpZGUgXCIgK1xuICAgICAgICAgICAgICBcInRoZSByZWNlaXZpbmcgY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmcpO1xuICAgICAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuICAgICAgICB2YXIgZHluYW1pYyA9IHJlZi5keW5hbWljO1xuICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90QmluZGluZy52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuOyAvLyBmb3JjZSBpdCBpbnRvIGEgc2NvcGVkIHNsb3QgZm9yIHBlcmZcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdi1zbG90IG9uIGNvbXBvbmVudCwgZGVub3RlcyBkZWZhdWx0IHNsb3RcbiAgICAgIHZhciBzbG90QmluZGluZyQxID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmckMSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBcInYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPi5cIixcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmckMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNsb3RTY29wZSB8fCBlbC5zbG90VGFyZ2V0KSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuXCIsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIFwiVG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LCB0aGUgZGVmYXVsdCBzbG90IHNob3VsZCBhbHNvIHVzZSBcIiArXG4gICAgICAgICAgICAgIFwiPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuXCIsXG4gICAgICAgICAgICAgIHNsb3RCaW5kaW5nJDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4gdG8gaXRzIGRlZmF1bHQgc2xvdFxuICAgICAgICB2YXIgc2xvdHMgPSBlbC5zY29wZWRTbG90cyB8fCAoZWwuc2NvcGVkU2xvdHMgPSB7fSk7XG4gICAgICAgIHZhciByZWYkMSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nJDEpO1xuICAgICAgICB2YXIgbmFtZSQxID0gcmVmJDEubmFtZTtcbiAgICAgICAgdmFyIGR5bmFtaWMkMSA9IHJlZiQxLmR5bmFtaWM7XG4gICAgICAgIHZhciBzbG90Q29udGFpbmVyID0gc2xvdHNbbmFtZSQxXSA9IGNyZWF0ZUFTVEVsZW1lbnQoJ3RlbXBsYXRlJywgW10sIGVsKTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0ID0gbmFtZSQxO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYyQxO1xuICAgICAgICBzbG90Q29udGFpbmVyLmNoaWxkcmVuID0gZWwuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgaWYgKCFjLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nJDEudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjtcbiAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XG4gICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIG1hcmsgZWwgbm9uLXBsYWluIHNvIGRhdGEgZ2V0cyBnZW5lcmF0ZWRcbiAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2xvdE5hbWUgKGJpbmRpbmcpIHtcbiAgdmFyIG5hbWUgPSBiaW5kaW5nLm5hbWUucmVwbGFjZShzbG90UkUsICcnKTtcbiAgaWYgKCFuYW1lKSB7XG4gICAgaWYgKGJpbmRpbmcubmFtZVswXSAhPT0gJyMnKSB7XG4gICAgICBuYW1lID0gJ2RlZmF1bHQnO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybihcbiAgICAgICAgXCJ2LXNsb3Qgc2hvcnRoYW5kIHN5bnRheCByZXF1aXJlcyBhIHNsb3QgbmFtZS5cIixcbiAgICAgICAgYmluZGluZ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpXG4gICAgLy8gZHluYW1pYyBbbmFtZV1cbiAgICA/IHsgbmFtZTogbmFtZS5zbGljZSgxLCAtMSksIGR5bmFtaWM6IHRydWUgfVxuICAgIC8vIHN0YXRpYyBuYW1lXG4gICAgOiB7IG5hbWU6IChcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIiksIGR5bmFtaWM6IGZhbHNlIH1cbn1cblxuLy8gaGFuZGxlIDxzbG90Lz4gb3V0bGV0c1xuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPdXRsZXQgKGVsKSB7XG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIixcbiAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgc3luY0dlbiwgaXNEeW5hbWljO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUucmVwbGFjZShkaXJSRSwgJycpKTtcbiAgICAgIC8vIHN1cHBvcnQgLmZvbyBzaG9ydGhhbmQgc3ludGF4IGZvciB0aGUgLnByb3AgbW9kaWZpZXJcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgaXNEeW5hbWljID0gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSk7XG4gICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICB2YWx1ZS50cmltKCkubGVuZ3RoID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcXFwidi1iaW5kOlwiICsgbmFtZSArIFwiXFxcIlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIHN5bmNHZW4gPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIik7XG4gICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuLFxuICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGh5cGhlbmF0ZShuYW1lKSAhPT0gY2FtZWxpemUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoaHlwaGVuYXRlKG5hbWUpKSksXG4gICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgd2FybixcbiAgICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBoYW5kbGVyIHcvIGR5bmFtaWMgZXZlbnQgbmFtZVxuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIChcIlxcXCJ1cGRhdGU6XFxcIisoXCIgKyBuYW1lICsgXCIpXCIpLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuLFxuICAgICAgICAgICAgICAgIGxpc3RbaV0sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvLyBkeW5hbWljXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICAgIGlmIChkeW5hbWljQXJnUkUudGVzdChhcmcpKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgaXNEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBpc0R5bmFtaWMsIG1vZGlmaWVycywgbGlzdFtpXSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LicsXG4gICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpLCBsaXN0W2ldKTtcbiAgICAgIC8vICM2ODg3IGZpcmVmb3ggZG9lc24ndCB1cGRhdGUgbXV0ZWQgc3RhdGUgaWYgc2V0IHZpYSBhdHRyaWJ1dGVcbiAgICAgIC8vIGV2ZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgZWxlbWVudCBjcmVhdGlvblxuICAgICAgaWYgKCFlbC5jb21wb25lbnQgJiZcbiAgICAgICAgICBuYW1lID09PSAnbXV0ZWQnICYmXG4gICAgICAgICAgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgIGFkZFByb3AoZWwsIG5hbWUsICd0cnVlJywgbGlzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gIHZhciBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBtYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZVxuICAgICkge1xuICAgICAgd2FybignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMsc3RhcnQsZW5kLHJhd0F0dHJzTWFwJyArXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gIClcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMoYmxvY2spO1xuICAgICAgICBpZiAoIWJsb2NrLnN0YXRpYykge1xuICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzIChub2RlLCBpc0luRm9yKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICB9XG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcbiAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcbiAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICApKSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2ssIGlzSW5Gb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIGZuRXhwUkUgPSAvXihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvbig/OlxccytbXFx3JF0rKT9cXHMqXFwoLztcbnZhciBmbkludm9rZVJFID0gL1xcKFteKV0qP1xcKTsqJC87XG52YXIgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLztcblxuLy8gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcbnZhciBrZXlOYW1lcyA9IHtcbiAgLy8gIzc4ODA6IElFMTEgYW5kIEVkZ2UgdXNlIGBFc2NgIGZvciBFc2NhcGUga2V5IG5hbWUuXG4gIGVzYzogWydFc2MnLCAnRXNjYXBlJ10sXG4gIHRhYjogJ1RhYicsXG4gIGVudGVyOiAnRW50ZXInLFxuICAvLyAjOTExMjogSUUxMSB1c2VzIGBTcGFjZWJhcmAgZm9yIFNwYWNlIGtleSBuYW1lLlxuICBzcGFjZTogWycgJywgJ1NwYWNlYmFyJ10sXG4gIC8vICM3ODA2OiBJRTExIHVzZXMga2V5IG5hbWVzIHdpdGhvdXQgYEFycm93YCBwcmVmaXggZm9yIGFycm93IGtleXMuXG4gIHVwOiBbJ1VwJywgJ0Fycm93VXAnXSxcbiAgbGVmdDogWydMZWZ0JywgJ0Fycm93TGVmdCddLFxuICByaWdodDogWydSaWdodCcsICdBcnJvd1JpZ2h0J10sXG4gIGRvd246IFsnRG93bicsICdBcnJvd0Rvd24nXSxcbiAgLy8gIzkxMTI6IElFMTEgdXNlcyBgRGVsYCBmb3IgRGVsZXRlIGtleSBuYW1lLlxuICAnZGVsZXRlJzogWydCYWNrc3BhY2UnLCAnRGVsZXRlJywgJ0RlbCddXG59O1xuXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XG5cbnZhciBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoXG4gIGV2ZW50cyxcbiAgaXNOYXRpdmVcbikge1xuICB2YXIgcHJlZml4ID0gaXNOYXRpdmUgPyAnbmF0aXZlT246JyA6ICdvbjonO1xuICB2YXIgc3RhdGljSGFuZGxlcnMgPSBcIlwiO1xuICB2YXIgZHluYW1pY0hhbmRsZXJzID0gXCJcIjtcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICB2YXIgaGFuZGxlckNvZGUgPSBnZW5IYW5kbGVyKGV2ZW50c1tuYW1lXSk7XG4gICAgaWYgKGV2ZW50c1tuYW1lXSAmJiBldmVudHNbbmFtZV0uZHluYW1pYykge1xuICAgICAgZHluYW1pY0hhbmRsZXJzICs9IG5hbWUgKyBcIixcIiArIGhhbmRsZXJDb2RlICsgXCIsXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY0hhbmRsZXJzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIGhhbmRsZXJDb2RlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIHN0YXRpY0hhbmRsZXJzID0gXCJ7XCIgKyAoc3RhdGljSGFuZGxlcnMuc2xpY2UoMCwgLTEpKSArIFwifVwiO1xuICBpZiAoZHluYW1pY0hhbmRsZXJzKSB7XG4gICAgcmV0dXJuIHByZWZpeCArIFwiX2QoXCIgKyBzdGF0aWNIYW5kbGVycyArIFwiLFtcIiArIChkeW5hbWljSGFuZGxlcnMuc2xpY2UoMCwgLTEpKSArIFwiXSlcIlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmVmaXggKyBzdGF0aWNIYW5kbGVyc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIoaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgfVxuXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICB2YXIgaXNGdW5jdGlvbkludm9jYXRpb24gPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlLnJlcGxhY2UoZm5JbnZva2VSRSwgJycpKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgaWYgKGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIGhhbmRsZXIudmFsdWVcbiAgICB9XG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaXNGdW5jdGlvbkludm9jYXRpb24gPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkpIDogaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSAoaGFuZGxlci5tb2RpZmllcnMpO1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gZ2VuR3VhcmQoXG4gICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAhbW9kaWZpZXJzW2tleU1vZGlmaWVyXTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAoXCIkZXZlbnQuXCIgKyBrZXlNb2RpZmllciArIFwiS2V5XCIpOyB9KVxuICAgICAgICAgICAgLmpvaW4oJ3x8JylcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIoJGV2ZW50KVwiKVxuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICA/IChcInJldHVybiAoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICA6IGlzRnVuY3Rpb25JbnZvY2F0aW9uXG4gICAgICAgICAgPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkpXG4gICAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgY29kZSArIGhhbmRsZXJDb2RlICsgXCJ9XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG4gIHJldHVybiAoXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBrZXkgZmlsdGVycyBvbmx5IGFwcGx5IHRvIEtleWJvYXJkRXZlbnRzXG4gICAgLy8gIzk0NDE6IGNhbid0IHVzZSAna2V5Q29kZScgaW4gJGV2ZW50IGJlY2F1c2UgQ2hyb21lIGF1dG9maWxsIGZpcmVzIGZha2VcbiAgICAvLyBrZXkgZXZlbnRzIHRoYXQgZG8gbm90IGhhdmUga2V5Q29kZSBwcm9wZXJ0eS4uLlxuICAgIFwiaWYoISRldmVudC50eXBlLmluZGV4T2YoJ2tleScpJiZcIiArXG4gICAgKGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJykpICsgXCIpcmV0dXJuIG51bGw7XCJcbiAgKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGtleUNvZGUgPSBrZXlDb2Rlc1trZXldO1xuICB2YXIga2V5TmFtZSA9IGtleU5hbWVzW2tleV07XG4gIHJldHVybiAoXG4gICAgXCJfaygkZXZlbnQua2V5Q29kZSxcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGtleSkpICsgXCIsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXlDb2RlKSkgKyBcIixcIiArXG4gICAgXCIkZXZlbnQua2V5LFwiICtcbiAgICBcIlwiICsgKEpTT04uc3RyaW5naWZ5KGtleU5hbWUpKSArXG4gICAgXCIpXCJcbiAgKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGlyLm1vZGlmaWVycykge1xuICAgIHdhcm4kMShcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XG4gIH1cbiAgZWwud3JhcExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJfZyhcIiArIGNvZGUgKyBcIixcIiArIChkaXIudmFsdWUpICsgXCIpXCIpOyB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBvbjogb24sXG4gIGJpbmQ6IGJpbmQsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuXG5cblxuXG52YXIgQ29kZWdlblN0YXRlID0gZnVuY3Rpb24gQ29kZWdlblN0YXRlIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICB0aGlzLm9uY2VJZCA9IDA7XG4gIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG4gIHRoaXMucHJlID0gZmFsc2U7XG59O1xuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJOYXRpdmVDb250ZW50Vmlld1wiKSc7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnBhcmVudCkge1xuICAgIGVsLnByZSA9IGVsLnByZSB8fCBlbC5wYXJlbnQucHJlO1xuICB9XG5cbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIGlmICghZWwucGxhaW4gfHwgKGVsLnByZSAmJiBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkpKSB7XG4gICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIC8vIFNvbWUgZWxlbWVudHMgKHRlbXBsYXRlcykgbmVlZCB0byBiZWhhdmUgZGlmZmVyZW50bHkgaW5zaWRlIG9mIGEgdi1wcmVcbiAgLy8gbm9kZS4gIEFsbCBwcmUgbm9kZXMgYXJlIHN0YXRpYyByb290cywgc28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgbG9jYXRpb24gdG9cbiAgLy8gd3JhcCBhIHN0YXRlIGNoYW5nZSBhbmQgcmVzZXQgaXQgdXBvbiBleGl0aW5nIHRoZSBwcmUgbm9kZS5cbiAgdmFyIG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gIGlmIChlbC5wcmUpIHtcbiAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XG4gIH1cbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gIHN0YXRlLnByZSA9IG9yaWdpbmFsUHJlU3RhdGU7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0ZS53YXJuKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIFwiLFwiICsga2V5ICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAhZWwua2V5XG4gICkge1xuICAgIHN0YXRlLndhcm4oXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10sXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIChhbHRIZWxwZXIgfHwgJ19sJykgKyBcIigoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczpcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCIsXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczpcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCIsXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UpKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLCBlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkeW5hbWljIGFyZ3VtZW50IHdyYXBcbiAgLy8gdi1iaW5kIHdpdGggZHluYW1pYyBhcmd1bWVudHMgbXVzdCBiZSBhcHBsaWVkIHVzaW5nIHRoZSBzYW1lIHYtYmluZCBvYmplY3RcbiAgLy8gbWVyZ2UgaGVscGVyIHNvIHRoYXQgY2xhc3Mvc3R5bGUvbXVzdFVzZVByb3AgYXR0cnMgYXJlIGhhbmRsZWQgY29ycmVjdGx5LlxuICBpZiAoZWwuZHluYW1pY0F0dHJzKSB7XG4gICAgZGF0YSA9IFwiX2IoXCIgKyBkYXRhICsgXCIsXFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCIgKyAoZ2VuUHJvcHMoZWwuZHluYW1pY0F0dHJzKSkgKyBcIilcIjtcbiAgfVxuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcIiArIChkaXIuaXNEeW5hbWljQXJnID8gZGlyLmFyZyA6IChcIlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSkpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgICdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nLFxuICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICk7XG4gIH1cbiAgaWYgKGFzdCAmJiBhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBlbCxcbiAgc2xvdHMsXG4gIHN0YXRlXG4pIHtcbiAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXCJzdGFibGVcIiwgdGhpcyBhbGxvd3MgY2hpbGRcbiAgLy8gY29tcG9uZW50cyB3aXRoIG9ubHkgc2NvcGVkIHNsb3RzIHRvIHNraXAgZm9yY2VkIHVwZGF0ZXMgZnJvbSBwYXJlbnQuXG4gIC8vIGJ1dCBpbiBzb21lIGNhc2VzIHdlIGhhdmUgdG8gYmFpbC1vdXQgb2YgdGhpcyBvcHRpbWl6YXRpb25cbiAgLy8gZm9yIGV4YW1wbGUgaWYgdGhlIHNsb3QgY29udGFpbnMgZHluYW1pYyBuYW1lcywgaGFzIHYtaWYgb3Igdi1mb3Igb24gdGhlbS4uLlxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9IGVsLmZvciB8fCBPYmplY3Qua2V5cyhzbG90cykuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHNsb3QgPSBzbG90c1trZXldO1xuICAgIHJldHVybiAoXG4gICAgICBzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8XG4gICAgICBzbG90LmlmIHx8XG4gICAgICBzbG90LmZvciB8fFxuICAgICAgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcbiAgICApXG4gIH0pO1xuXG4gIC8vICM5NTM0OiBpZiBhIGNvbXBvbmVudCB3aXRoIHNjb3BlZCBzbG90cyBpcyBpbnNpZGUgYSBjb25kaXRpb25hbCBicmFuY2gsXG4gIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBzYW1lIGNvbXBvbmVudCB0byBiZSByZXVzZWQgYnV0IHdpdGggZGlmZmVyZW50XG4gIC8vIGNvbXBpbGVkIHNsb3QgY29udGVudC4gVG8gYXZvaWQgdGhhdCwgd2UgZ2VuZXJhdGUgYSB1bmlxdWUga2V5IGJhc2VkIG9uXG4gIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSBvZiBhbGwgdGhlIHNsb3QgY29udGVudHMuXG4gIHZhciBuZWVkc0tleSA9ICEhZWwuaWY7XG5cbiAgLy8gT1Igd2hlbiBpdCBpcyBpbnNpZGUgYW5vdGhlciBzY29wZWQgc2xvdCBvciB2LWZvciAodGhlIHJlYWN0aXZpdHkgbWF5IGJlXG4gIC8vIGRpc2Nvbm5lY3RlZCBkdWUgdG8gdGhlIGludGVybWVkaWF0ZSBzY29wZSB2YXJpYWJsZSlcbiAgLy8gIzk0MzgsICM5NTA2XG4gIC8vIFRPRE86IHRoaXMgY2FuIGJlIGZ1cnRoZXIgb3B0aW1pemVkIGJ5IHByb3Blcmx5IGFuYWx5emluZyBpbi1zY29wZSBiaW5kaW5nc1xuICAvLyBhbmQgc2tpcCBmb3JjZSB1cGRhdGluZyBvbmVzIHRoYXQgZG8gbm90IGFjdHVhbGx5IHVzZSBzY29wZSB2YXJpYWJsZXMuXG4gIGlmICghbmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAocGFyZW50LnNsb3RTY29wZSAmJiBwYXJlbnQuc2xvdFNjb3BlICE9PSBlbXB0eVNsb3RTY29wZVRva2VuKSB8fFxuICAgICAgICBwYXJlbnQuZm9yXG4gICAgICApIHtcbiAgICAgICAgbmVlZHNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAocGFyZW50LmlmKSB7XG4gICAgICAgIG5lZWRzS2V5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGdlbmVyYXRlZFNsb3RzID0gT2JqZWN0LmtleXMoc2xvdHMpXG4gICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKTsgfSlcbiAgICAuam9pbignLCcpO1xuXG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyBnZW5lcmF0ZWRTbG90cyArIFwiXVwiICsgKG5lZWRzRm9yY2VVcGRhdGUgPyBcIixudWxsLHRydWVcIiA6IFwiXCIpICsgKCFuZWVkc0ZvcmNlVXBkYXRlICYmIG5lZWRzS2V5ID8gKFwiLG51bGwsZmFsc2UsXCIgKyAoaGFzaChnZW5lcmF0ZWRTbG90cykpKSA6IFwiXCIpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gIHZhciBoYXNoID0gNTM4MTtcbiAgdmFyIGkgPSBzdHIubGVuZ3RoO1xuICB3aGlsZShpKSB7XG4gICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuICByZXR1cm4gaGFzaCA+Pj4gMFxufVxuXG5mdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZCAoZWwpIHtcbiAgaWYgKGVsLnR5cGUgPT09IDEpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBlbC5jaGlsZHJlbi5zb21lKGNvbnRhaW5zU2xvdENoaWxkKVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBcIm51bGxcIilcbiAgfVxuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdClcbiAgfVxuICB2YXIgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuXG4gICAgPyBcIlwiXG4gICAgOiBTdHJpbmcoZWwuc2xvdFNjb3BlKTtcbiAgdmFyIGZuID0gXCJmdW5jdGlvbihcIiArIHNsb3RTY29wZSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGVsLmlmICYmIGlzTGVnYWN5U3ludGF4XG4gICAgICAgID8gKFwiKFwiICsgKGVsLmlmKSArIFwiKT9cIiArIChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnKSArIFwiOnVuZGVmaW5lZFwiKVxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiO1xuICAvLyByZXZlcnNlIHByb3h5IHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gIHZhciByZXZlcnNlUHJveHkgPSBzbG90U2NvcGUgPyBcIlwiIDogXCIscHJveHk6dHJ1ZVwiO1xuICByZXR1cm4gKFwie2tleTpcIiArIChlbC5zbG90VGFyZ2V0IHx8IFwiXFxcImRlZmF1bHRcXFwiXCIpICsgXCIsZm46XCIgKyBmbiArIHJldmVyc2VQcm94eSArIFwifVwiKVxufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgY2hlY2tTa2lwLFxuICBhbHRHZW5FbGVtZW50LFxuICBhbHRHZW5Ob2RlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsJDEuZm9yICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwkMSkgPyBcIiwxXCIgOiBcIiwwXCJcbiAgICAgICAgOiBcIlwiO1xuICAgICAgcmV0dXJuIChcIlwiICsgKChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKSkgKyBub3JtYWxpemF0aW9uVHlwZSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlJDEgPSBjaGVja1NraXBcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxuICAgICAgOiAwO1xuICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSQxID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUkMSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCwgc3RhdGUpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgfHwgZWwuZHluYW1pY0F0dHJzXG4gICAgPyBnZW5Qcm9wcygoZWwuYXR0cnMgfHwgW10pLmNvbmNhdChlbC5keW5hbWljQXR0cnMgfHwgW10pLm1hcChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gKHtcbiAgICAgICAgLy8gc2xvdCBwcm9wcyBhcmUgY2FtZWxpemVkXG4gICAgICAgIG5hbWU6IGNhbWVsaXplKGF0dHIubmFtZSksXG4gICAgICAgIHZhbHVlOiBhdHRyLnZhbHVlLFxuICAgICAgICBkeW5hbWljOiBhdHRyLmR5bmFtaWNcbiAgICAgIH0pOyB9KSlcbiAgICA6IG51bGw7XG4gIHZhciBiaW5kID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZDtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gIGNvbXBvbmVudE5hbWUsXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciBzdGF0aWNQcm9wcyA9IFwiXCI7XG4gIHZhciBkeW5hbWljUHJvcHMgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSk7XG4gICAgaWYgKHByb3AuZHluYW1pYykge1xuICAgICAgZHluYW1pY1Byb3BzICs9IChwcm9wLm5hbWUpICsgXCIsXCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNQcm9wcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgdmFsdWUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgc3RhdGljUHJvcHMgPSBcIntcIiArIChzdGF0aWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXCJ9XCI7XG4gIGlmIChkeW5hbWljUHJvcHMpIHtcbiAgICByZXR1cm4gKFwiX2QoXCIgKyBzdGF0aWNQcm9wcyArIFwiLFtcIiArIChkeW5hbWljUHJvcHMuc2xpY2UoMCwgLTEpKSArIFwiXSlcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGljUHJvcHNcbiAgfVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCwgd2Fybikge1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgd2Fybik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCB3YXJuKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByYW5nZSA9IG5vZGUucmF3QXR0cnNNYXBbbmFtZV07XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAndi1zbG90JyB8fCBuYW1lWzBdID09PSAnIycpIHtcbiAgICAgICAgICAgIGNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIHdhcm4pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIHdhcm4sIG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgdmFyIHN0cmlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RyaXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RyaXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICB3YXJuKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICByYW5nZVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChcbiAgaWRlbnQsXG4gIHR5cGUsXG4gIHRleHQsXG4gIHdhcm4sXG4gIHJhbmdlXG4pIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKChcInZhciBcIiArIGlkZW50ICsgXCI9X1wiKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybigoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSksIHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCJcXG4gIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAoZS5tZXNzYWdlKSArIFwiIGluXFxuXFxuXCIgK1xuICAgICAgICBcIiAgICBcIiArIGV4cCArIFwiXFxuXFxuXCIgK1xuICAgICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCIsXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0Z1bmN0aW9uUGFyYW1ldGVyRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihleHAsICcnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHdhcm4oXG4gICAgICBcImludmFsaWQgZnVuY3Rpb24gcGFyYW1ldGVyIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgIFwiICAgIFwiICsgZXhwICsgXCJcXG5cXG5cIiArXG4gICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCIsXG4gICAgICByYW5nZVxuICAgICk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciByYW5nZSA9IDI7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lIChcbiAgc291cmNlLFxuICBzdGFydCxcbiAgZW5kXG4pIHtcbiAgaWYgKCBzdGFydCA9PT0gdm9pZCAwICkgc3RhcnQgPSAwO1xuICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gc291cmNlLmxlbmd0aDtcblxuICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAodmFyIGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgcmVzLnB1c2goKFwiXCIgKyAoaiArIDEpICsgKHJlcGVhdChcIiBcIiwgMyAtIFN0cmluZyhqICsgMSkubGVuZ3RoKSkgKyBcInwgIFwiICsgKGxpbmVzW2pdKSkpO1xuICAgICAgICB2YXIgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxuICAgICAgICAgIHZhciBwYWQgPSBzdGFydCAtIChjb3VudCAtIGxpbmVMZW5ndGgpICsgMTtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgcmVzLnB1c2goXCIgICB8ICBcIiArIHJlcGVhdChcIiBcIiwgcGFkKSArIHJlcGVhdChcIl5cIiwgbGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGgkMSA9IE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQoXCJeXCIsIGxlbmd0aCQxKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpXG59XG5cbmZ1bmN0aW9uIHJlcGVhdCAoc3RyLCBuKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKG4gPiAwKSB7XG4gICAgd2hpbGUgKHRydWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaWYgKG4gJiAxKSB7IHJlc3VsdCArPSBzdHI7IH1cbiAgICAgIG4gPj4+PSAxO1xuICAgICAgaWYgKG4gPD0gMCkgeyBicmVhayB9XG4gICAgICBzdHIgKz0gc3RyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICAgIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IHdhcm4kMTtcbiAgICBkZWxldGUgb3B0aW9ucy53YXJuO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgKGUubXNnKSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgICAgICBnZW5lcmF0ZUNvZGVGcmFtZSh0ZW1wbGF0ZSwgZS5zdGFydCwgZS5lbmQpLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFwiLSBcIiArIGUpOyB9KS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gdGlwKGUubXNnLCB2bSk7IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBjcmVhdGVGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKVxuICAgIH0pO1xuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoY2FjaGVba2V5XSA9IHJlcylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJDcmVhdG9yIChiYXNlQ29tcGlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgICB0ZW1wbGF0ZSxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIHZhciBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHZhciB0aXBzID0gW107XG5cbiAgICAgIHZhciB3YXJuID0gZnVuY3Rpb24gKG1zZywgcmFuZ2UsIHRpcCkge1xuICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgICAgfTtcblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICAgIHZhciBsZWFkaW5nU3BhY2VMZW5ndGggPSB0ZW1wbGF0ZS5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XG5cbiAgICAgICAgICB3YXJuID0gZnVuY3Rpb24gKG1zZywgcmFuZ2UsIHRpcCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7IG1zZzogbXNnIH07XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5lbmQgPSByYW5nZS5lbmQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKGRhdGEpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID1cbiAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMgfHwgbnVsbCksXG4gICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gd2FybjtcblxuICAgICAgdmFyIGNvbXBpbGVkID0gYmFzZUNvbXBpbGUodGVtcGxhdGUudHJpbSgpLCBmaW5hbE9wdGlvbnMpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCwgd2Fybik7XG4gICAgICB9XG4gICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICBjb21waWxlZC50aXBzID0gdGlwcztcbiAgICAgIHJldHVybiBjb21waWxlZFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb21waWxlOiBjb21waWxlLFxuICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBgY3JlYXRlQ29tcGlsZXJDcmVhdG9yYCBhbGxvd3MgY3JlYXRpbmcgY29tcGlsZXJzIHRoYXQgdXNlIGFsdGVybmF0aXZlXG4vLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXG4vLyBIZXJlIHdlIGp1c3QgZXhwb3J0IGEgZGVmYXVsdCBjb21waWxlciB1c2luZyB0aGUgZGVmYXVsdCBwYXJ0cy5cbnZhciBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLm9wdGltaXplICE9PSBmYWxzZSkge1xuICAgIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gIH1cbiAgdmFyIGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGFzdDogYXN0LFxuICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59KTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQyKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgY2xhc3NfID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMixcbiAgZ2VuRGF0YTogZ2VuRGF0YSQxXG59O1xuXG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGNhbWVsaXplKTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgdmFyIHJlZiA9IHBhcnNlU3RhdGljU3R5bGUoc3RhdGljU3R5bGUsIG9wdGlvbnMpO1xuICB2YXIgZHluYW1pYyA9IHJlZi5keW5hbWljO1xuICB2YXIgc3R5bGVSZXN1bHQgPSByZWYuc3R5bGVSZXN1bHQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGR5bmFtaWMpIHtcbiAgICB3YXJuKFxuICAgICAgXCJzdHlsZT1cXFwiXCIgKyAoU3RyaW5nKHN0YXRpY1N0eWxlKSkgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4nXG4gICAgKTtcbiAgfVxuICBpZiAoIWR5bmFtaWMgJiYgc3R5bGVSZXN1bHQpIHtcbiAgICBlbC5zdGF0aWNTdHlsZSA9IHN0eWxlUmVzdWx0O1xuICB9XG4gIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKHN0eWxlQmluZGluZykge1xuICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgfSBlbHNlIGlmIChkeW5hbWljKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVSZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YShlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTpcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGFyc2VTdGF0aWNTdHlsZShzdGF0aWNTdHlsZSwgb3B0aW9ucykge1xuICAvLyBcIndpZHRoOiAyMDBweDsgaGVpZ2h0OiAyMDBweDtcIiAtPiB7d2lkdGg6IDIwMCwgaGVpZ2h0OiAyMDB9XG4gIC8vIFwid2lkdGg6IDIwMHB4OyBoZWlnaHQ6IHt7eX19XCIgLT4ge3dpZHRoOiAyMDAsIGhlaWdodDogeX1cbiAgdmFyIGR5bmFtaWMgPSBmYWxzZTtcbiAgdmFyIHN0eWxlUmVzdWx0ID0gJyc7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIHZhciBzdHlsZUxpc3QgPSBzdGF0aWNTdHlsZVxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KCc7JylcbiAgICAgIC5tYXAoZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBzdHlsZS50cmltKCkuc3BsaXQoJzonKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gbm9ybWFsaXplKHJlc3VsdFswXS50cmltKCkpO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHRbMV0udHJpbSgpO1xuICAgICAgICB2YXIgZHluYW1pY1ZhbHVlID0gcGFyc2VUZXh0KHZhbHVlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgICBpZiAoZHluYW1pY1ZhbHVlKSB7XG4gICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGtleSArICc6JyArIGR5bmFtaWNWYWx1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXkgKyAnOicgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdDsgfSk7XG4gICAgaWYgKHN0eWxlTGlzdC5sZW5ndGgpIHtcbiAgICAgIHN0eWxlUmVzdWx0ID0gJ3snICsgc3R5bGVMaXN0LmpvaW4oJywnKSArICd9JztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgZHluYW1pYzogZHluYW1pYywgc3R5bGVSZXN1bHQ6IHN0eWxlUmVzdWx0IH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgZ2VuRGF0YTogZ2VuRGF0YVxufTtcblxuZnVuY3Rpb24gcHJlVHJhbnNmb3JtTm9kZSQyKGVsKSB7XG4gIHZhciB2Zm9yO1xuXG4gIGlmIChub3JtYWxpemVFbGVtZW50TmFtZShlbC50YWcpID09PSAnbmF0aXZlbGlzdHZpZXcnKSB7XG4gICAgdmZvciA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpO1xuICAgIGRlbGV0ZSBlbC5hdHRyc01hcFsndi1mb3InXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB2Zm9yKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiVGhlIHYtZm9yIGRpcmVjdGl2ZSBpcyBub3Qgc3VwcG9ydGVkIG9uIGEgXCIgKyAoZWwudGFnKSArIFwiLCBcIiArXG4gICAgICAgICAgJ1VzZSB0aGUgXCJmb3JcIiBhdHRyaWJ1dGUgaW5zdGVhZC4gRm9yIGV4YW1wbGUsIGluc3RlYWQgb2YgJyArXG4gICAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIHZmb3IgKyBcIlxcXCI+IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiIGZvcj1cXFwiXCIgKyB2Zm9yICsgXCJcXFwiPi5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2ZvcicpIHx8IHZmb3I7XG4gIGlmICghZXhwKSB7IHJldHVybiB9XG5cbiAgdmFyIHJlcyA9IHBhcnNlRm9yKGV4cCk7XG4gIGlmICghcmVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4kMSgoXCJJbnZhbGlkIGZvciBleHByZXNzaW9uOiBcIiArIGV4cCkpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIGFkZFJhd0F0dHIoZWwsICc6aXRlbXMnLCByZXMuZm9yKTtcbiAgYWRkUmF3QXR0cihlbCwgJythbGlhcycsIHJlcy5hbGlhcyk7XG5cbiAgaWYgKHJlcy5pdGVyYXRvcjEpIHtcbiAgICBhZGRSYXdBdHRyKGVsLCAnK2luZGV4JywgcmVzLml0ZXJhdG9yMSk7XG4gIH1cbn1cblxudmFyIGZvcl8gPSB7XG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGUkMlxufTtcblxuZnVuY3Rpb24gcHJlVHJhbnNmb3JtTm9kZSQxKGVsKSB7XG4gIGlmIChlbC50YWcgIT09ICdyb3V0ZXItdmlldycpIHsgcmV0dXJuIH1cbiAgaWYgKFxuICAgIGVsLnBhcmVudCAmJlxuICAgIGVsLnBhcmVudC50YWcgJiZcbiAgICBub3JtYWxpemVFbGVtZW50TmFtZShlbC5wYXJlbnQudGFnKSA9PT0gJ25hdGl2ZWZyYW1lJ1xuICApIHtcbiAgICBhZGRBdHRyKGVsLnBhcmVudCwgJ2hhc1JvdXRlclZpZXcnLCAndHJ1ZScpO1xuICB9XG59XG5cbnZhciByb3V0ZXIgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGUkMVxufTtcblxuZnVuY3Rpb24gcHJlVHJhbnNmb3JtTm9kZShlbCkge1xuICBpZiAoZWwucGFyZW50ICYmIGVsLnBhcmVudC50YWcgPT09ICd2LXRlbXBsYXRlJykge1xuICAgIHZhciBhbGlhcyA9IGVsLnBhcmVudC5wYXJlbnQuYXR0cnNNYXBbJythbGlhcyddIHx8ICdpdGVtJztcbiAgICB2YXIgaW5kZXggPSBlbC5wYXJlbnQucGFyZW50LmF0dHJzTWFwWycraW5kZXgnXSB8fCAnJGluZGV4JztcbiAgICBlbC5zbG90U2NvcGUgPSBidWlsZFNjb3BlU3RyaW5nKGFsaWFzLCBpbmRleCk7XG4gIH1cbn1cblxudmFyIHZUZW1wbGF0ZSA9IHtcbiAgcHJlVHJhbnNmb3JtTm9kZTogcHJlVHJhbnNmb3JtTm9kZVxufTtcblxuZnVuY3Rpb24gYnVpbGRTY29wZVN0cmluZyhhbGlhcywgaW5kZXgpIHtcbiAgcmV0dXJuIChcInsgXCIgKyBhbGlhcyArIFwiLCBcIiArIGluZGV4ICsgXCIsICRldmVuLCAkb2RkIH1cIilcbn1cblxuLy8gdHJhbnNmb3JtcyB+dGVzdCAtPiB2LXZpZXc6dGVzdFxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZShlbCkge1xuICB2YXIgYXR0ciA9IE9iamVjdC5rZXlzKGVsLmF0dHJzTWFwKS5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLnN0YXJ0c1dpdGgoJ34nKTsgfSk7XG5cbiAgaWYgKGF0dHIpIHtcbiAgICB2YXIgYXR0ck5hbWUgPSBhdHRyLnN1YnN0cigxKTtcbiAgICB2YXIgcmVmID0gYXR0ck5hbWUuc3BsaXQoJy4nKTtcbiAgICB2YXIgYXJnID0gcmVmWzBdO1xuICAgIHZhciBtb2RpZmllcnMgPSByZWYuc2xpY2UoMSk7XG4gICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobW9kcywgbW9kKSB7XG4gICAgICBtb2RzW21vZF0gPSB0cnVlO1xuICAgICAgcmV0dXJuIG1vZHNcbiAgICB9LCB7fSk7XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgYXR0ciwgdHJ1ZSk7XG4gICAgYWRkRGlyZWN0aXZlKGVsLCAndmlldycsIChcInYtdmlldzpcIiArIGF0dHJOYW1lKSwgJycsIGFyZywgZmFsc2UsIG1vZGlmaWVycyk7XG4gIH1cbn1cblxudmFyIHZpZXckMSA9IHtcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZVxufTtcblxudmFyIG1vZHVsZXMgPSBbY2xhc3NfLCBzdHlsZSwgdlRlbXBsYXRlLCBmb3JfLCByb3V0ZXIsIHZpZXckMV07XG5cbmZ1bmN0aW9uIG1vZGVsKGVsLCBkaXIpIHtcbiAgaWYgKGVsLnR5cGUgPT09IDEgJiYgaXNLbm93blZpZXcoZWwudGFnKSkge1xuICAgIGdlblZpZXdDb21wb25lbnRNb2RlbChlbCwgZGlyLnZhbHVlLCBkaXIubW9kaWZpZXJzKTtcbiAgfSBlbHNlIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgZGlyLnZhbHVlLCBkaXIubW9kaWZpZXJzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5WaWV3Q29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpIHtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciByZWYkMSA9IGdldFZpZXdNZXRhKGVsLnRhZykubW9kZWw7XG4gIHZhciBwcm9wID0gcmVmJDEucHJvcDtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLm9iamVjdFtcIiArIChKU09OLnN0cmluZ2lmeShwcm9wKSkgKyBcIl1cIjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgXCI/IFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgXCI6IFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IG1vZGVsXG59O1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIG1vZHVsZXM6IG1vZHVsZXMsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHByZXNlcnZlV2hpdGVzcGFjZTogZmFsc2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMkMShtb2R1bGVzKVxufTtcblxudmFyIHJlZiA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5mdW5jdGlvbiBWdWUgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUpXG4gICkge1xuICAgIHdhcm4kMSgnVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbiQxKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbnJlbmRlck1peGluKFZ1ZSk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdCQxKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGNhY2hlZCA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQgJiYgKCFjdXJyZW50IHx8IGNhY2hlZC50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZC5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUkMihrZXlzLCBrZXkpO1xufVxuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLiR3YXRjaCgnaW5jbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9KTtcbiAgICB0aGlzLiR3YXRjaCgnZXhjbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgaW5jbHVkZSA9IHJlZi5pbmNsdWRlO1xuICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgIHZhciBjYWNoZSA9IHJlZiQxLmNhY2hlO1xuICAgICAgdmFyIGtleXMgPSByZWYkMS5rZXlzO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZSQyKGtleXMsIGtleSk7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybiQxKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuJDEsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldCQxO1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICAvLyAyLjYgZXhwbGljaXQgb2JzZXJ2YWJsZSBBUElcbiAgVnVlLm9ic2VydmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgb2JzZXJ2ZShvYmopO1xuICAgIHJldHVybiBvYmpcbiAgfTtcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4oVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblxuVnVlLnZlcnNpb24gPSAnMi42LjEyJztcblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbFZpc2liaWxpdHkgPSAoZWwuX192T3JpZ2luYWxWaXNpYmlsaXR5ID1cbiAgICAgIGVsLmdldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScpID09PSAnbm9uZSdcbiAgICAgICAgPyAnJ1xuICAgICAgICA6IGVsLmdldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScpKTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbikge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsIG9yaWdpbmFsVmlzaWJpbGl0eSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywgdmFsdWUgPyBvcmlnaW5hbFZpc2liaWxpdHkgOiAnY29sbGFwc2VkJyk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsIGVsLl9fdk9yaWdpbmFsVmlzaWJpbGl0eSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCAnY29sbGFwc2VkJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICd2aXNpYmlsaXR5JyxcbiAgICAgICAgdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbFZpc2liaWxpdHkgOiAnY29sbGFwc2VkJ1xuICAgICAgKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsIGVsLl9fdk9yaWdpbmFsVmlzaWJpbGl0eSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmlldyA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkKGVsLCByZWYpIHtcbiAgICB2YXIgYXJnID0gcmVmLmFyZztcbiAgICB2YXIgbW9kaWZpZXJzID0gcmVmLm1vZGlmaWVycztcblxuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlLm5hdGl2ZVZpZXc7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAobW9kaWZpZXJzLmFycmF5KSB7XG4gICAgICAgIHBhcmVudFthcmddID0gKHBhcmVudFthcmddIHx8IFtdKS5wdXNoKGVsLm5hdGl2ZVZpZXcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50W2FyZ10gPSBlbC5uYXRpdmVWaWV3O1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgc2hvdzogc2hvdyxcbiAgdmlldzogdmlld1xufTtcblxuVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cblZ1ZS4kZG9jdW1lbnQgPSBWdWUucHJvdG90eXBlLiRkb2N1bWVudCA9IG5ldyBEb2N1bWVudE5vZGUoKTtcblxuLy8gRXhwb3NlZCBmb3IgYWR2YW5jZWQgdXNlcyBvbmx5LCBub3QgcHVibGljIEFQSVxuVnVlLl9fZmx1c2hDYWxsYmFja3NfXyA9IGZsdXNoQ2FsbGJhY2tzO1xuXG5WdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblZ1ZS5yZWdpc3RlckVsZW1lbnQgPSByZWdpc3RlckVsZW1lbnQ7XG5cbk9iamVjdC5hc3NpZ24oVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBwYXRjaDtcblxuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoZWwsIGh5ZHJhdGluZykge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSAmJiB0eXBlb2YgdGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB3YXJuJDEoJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOiAnICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnMoXG4gICAgICAgIHRlbXBsYXRlLFxuICAgICAgICB7XG4gICAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cblZ1ZS5wcm90b3R5cGUuJHN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBBcHBDb25zdHJ1Y3RvciA9IFZ1ZS5leHRlbmQodGhpcy4kb3B0aW9ucyk7XG5cbiAgLy8gcmVnaXN0ZXIgTlMgY29tcG9uZW50cyBpbnRvIFZ1ZVxuICBPYmplY3QudmFsdWVzKGdldEVsZW1lbnRNYXAoKSkuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICBWdWUuY29tcG9uZW50KGVudHJ5Lm1ldGEuY29tcG9uZW50Lm5hbWUsIGVudHJ5Lm1ldGEuY29tcG9uZW50KTtcbiAgfSk7XG5cbiAgY29yZS5BcHBsaWNhdGlvbi5ydW4oe1xuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgaWYgKHNlbGYuJGVsKSB7XG4gICAgICAgIHNlbGYuJGRlc3Ryb3koKTtcbiAgICAgICAgc2VsZiA9IG5ldyBBcHBDb25zdHJ1Y3RvcigpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLiRtb3VudCgpO1xuICAgICAgcmV0dXJuIHNlbGYuJGVsLm5hdGl2ZVZpZXdcbiAgICB9XG4gIH0pO1xufTtcblxuLy8gRGVmaW5lIGEgYG5hdGl2ZVZpZXdgIGdldHRlciBpbiBldmVyeSBOUyB2dWUgaW5zdGFuY2Vcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnbmF0aXZlVmlldycsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGVsID8gdGhpcy4kZWwubmF0aXZlVmlldyA6IHVuZGVmaW5lZFxuICB9XG59KTtcblxudmFyIHNlcXVlbnRpYWxDb3VudGVyJDEgPSAwO1xuXG5mdW5jdGlvbiBzZXJpYWxpemVNb2RhbE9wdGlvbnMob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB2YXIgYWxsb3dlZCA9IFsnZnVsbHNjcmVlbiddO1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhvcHRpb25zKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gYWxsb3dlZC5pbmNsdWRlcyhrZXkpOyB9KVxuICAgIC5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIChrZXkgKyBcIjogXCIgKyAob3B0aW9uc1trZXldKSlcbiAgICB9KVxuICAgIC5jb25jYXQoKFwidWlkOiBcIiArICgrK3NlcXVlbnRpYWxDb3VudGVyJDEpKSlcbiAgICAuam9pbignLCAnKVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRWaWV3KHRhcmdldCkge1xuICBpZiAoaXNPYmplY3QkMSh0YXJnZXQpICYmIGlzRGVmKHRhcmdldC4kZWwpKSB7XG4gICAgcmV0dXJuIHRhcmdldC4kZWwubmF0aXZlVmlld1xuICB9IGVsc2UgaWYgKGlzRGVmKHRhcmdldC5uYXRpdmVWaWV3KSkge1xuICAgIHJldHVybiB0YXJnZXQubmF0aXZlVmlld1xuICB9IGVsc2UgaWYgKHRhcmdldFtWVUVfRUxFTUVOVF9SRUZdKSB7XG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG59XG5cbmZ1bmN0aW9uIF9maW5kUGFyZW50TW9kYWxFbnRyeSh2bSkge1xuICBpZiAoIXZtKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB2YXIgZW50cnkgPSB2bS4kcGFyZW50O1xuICB3aGlsZSAoZW50cnkgJiYgZW50cnkuJG9wdGlvbnMubmFtZSAhPT0gJ01vZGFsRW50cnknKSB7XG4gICAgZW50cnkgPSBlbnRyeS4kcGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIGVudHJ5XG59XG5cbnZhciBNb2RhbFBsdWdpbiA9IHtcbiAgaW5zdGFsbDogZnVuY3Rpb24gaW5zdGFsbChWdWUpIHtcbiAgICBWdWUubWl4aW4oe1xuICAgICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLiRtb2RhbCA9IHtcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2ZpbmRQYXJlbnRNb2RhbEVudHJ5KHNlbGYpO1xuXG4gICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgZW50cnkuY2xvc2VDYihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBWdWUucHJvdG90eXBlLiRzaG93TW9kYWwgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBvcHRpb25zKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciByZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgY2xvc2VDYiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgaWYgKHJlc29sdmVkKSB7IHJldHVybiB9XG5cbiAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICBtb2RhbFBhZ2UuY2xvc2VNb2RhbCgpO1xuXG4gICAgICAgICAgLy8gZW1pdHRlZCB0byBzaG93IHVwIGluIGRldnRvb2xzXG4gICAgICAgICAgLy8gZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgICAgIG5hdkVudHJ5SW5zdGFuY2UuJGVtaXQoJ21vZGFsOmNsb3NlJywgZGF0YSk7XG4gICAgICAgICAgbmF2RW50cnlJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGJ1aWxkIG9wdGlvbnMgb2JqZWN0IHdpdGggZGVmYXVsdHNcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzJDEuJHJvb3RcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgICAgICAgIGNsb3NlQ2FsbGJhY2s6IGNsb3NlQ2JcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIG5hdkVudHJ5SW5zdGFuY2UgPSBuZXcgVnVlKHtcbiAgICAgICAgICBuYW1lOiAnTW9kYWxFbnRyeScsXG4gICAgICAgICAgcGFyZW50OiBvcHRpb25zLnRhcmdldCxcbiAgICAgICAgICBtZXRob2RzOiB7XG4gICAgICAgICAgICBjbG9zZUNiOiBjbG9zZUNiXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChoKSB7IHJldHVybiBoKGNvbXBvbmVudCwge1xuICAgICAgICAgICAgICBwcm9wczogb3B0aW9ucy5wcm9wcyxcbiAgICAgICAgICAgICAga2V5OiBzZXJpYWxpemVNb2RhbE9wdGlvbnMob3B0aW9ucylcbiAgICAgICAgICAgIH0pOyB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbW9kYWxQYWdlID0gbmF2RW50cnlJbnN0YW5jZS4kbW91bnQoKS4kZWwubmF0aXZlVmlldztcbiAgICAgICAgdXBkYXRlRGV2dG9vbHMoKTtcblxuICAgICAgICBnZXRUYXJnZXRWaWV3KG9wdGlvbnMudGFyZ2V0KS5zaG93TW9kYWwobW9kYWxQYWdlLCBvcHRpb25zKTtcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxufTtcblxudmFyIHNlcXVlbnRpYWxDb3VudGVyID0gMDtcblxuZnVuY3Rpb24gc2VyaWFsaXplTmF2aWdhdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB2YXIgYWxsb3dlZCA9IFsnYmFja3N0YWNrVmlzaWJsZScsICdjbGVhckhpc3RvcnknXTtcblxuICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucylcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFsbG93ZWQuaW5jbHVkZXMoa2V5KTsgfSlcbiAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiAoa2V5ICsgXCI6IFwiICsgKG9wdGlvbnNba2V5XSkpXG4gICAgfSlcbiAgICAuY29uY2F0KChcInVpZDogXCIgKyAoKytzZXF1ZW50aWFsQ291bnRlcikpKVxuICAgIC5qb2luKCcsICcpXG59XG5cbmZ1bmN0aW9uIGdldEZyYW1lSW5zdGFuY2UoZnJhbWUpIHtcbiAgLy8gZ2V0IHRoZSBmcmFtZSB0aGF0IHdlIG5lZWQgdG8gbmF2aWdhdGVcbiAgLy8gdGhpcyBjYW4gYmUgYSBmcmFtZSBpZCAoU3RyaW5nKVxuICAvLyBhIFZ1ZSByZWYgdG8gYSBmcmFtZVxuICAvLyBhIEZyYW1lIFZpZXdOb2RlXG4gIC8vIG9yIGEgRnJhbWUgaW5zdGFuY2VcbiAgaWYgKGlzT2JqZWN0JDEoZnJhbWUpICYmIGlzRGVmKGZyYW1lLiRlbCkpIHtcbiAgICBmcmFtZSA9IGZyYW1lLiRlbC5uYXRpdmVWaWV3O1xuICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGZyYW1lKSkge1xuICAgIGZyYW1lID0gcmVxdWlyZSgnQG5hdGl2ZXNjcmlwdC9jb3JlJykuRnJhbWUuZ2V0RnJhbWVCeUlkKGZyYW1lKTtcbiAgfSBlbHNlIGlmIChpc0RlZihmcmFtZS5uYXRpdmVWaWV3KSkge1xuICAgIGZyYW1lID0gZnJhbWUubmF0aXZlVmlldztcbiAgfVxuICAvLyBmaW5hbGx5IGdldCB0aGUgY29tcG9uZW50IGluc3RhbmNlIGZvciB0aGlzIGZyYW1lXG4gIHJldHVybiBnZXRGcmFtZShmcmFtZS5pZClcbn1cblxuZnVuY3Rpb24gZmluZFBhcmVudEZyYW1lKHZtKSB7XG4gIGlmICghdm0pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHZhciBlbnRyeSA9IHZtLiRwYXJlbnQ7XG4gIHdoaWxlIChlbnRyeSAmJiBlbnRyeS4kb3B0aW9ucy5uYW1lICE9PSAnRnJhbWUnKSB7XG4gICAgZW50cnkgPSBlbnRyeS4kcGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIGVudHJ5XG59XG5cbnZhciBOYXZpZ2F0b3JQbHVnaW4gPSB7XG4gIGluc3RhbGw6IGZ1bmN0aW9uIGluc3RhbGwoVnVlKSB7XG4gICAgVnVlLm5hdmlnYXRlQmFjayA9IFZ1ZS5wcm90b3R5cGUuJG5hdmlnYXRlQmFjayA9IGZ1bmN0aW9uIChcbiAgICAgIG9wdGlvbnMsXG4gICAgICBiYWNrc3RhY2tFbnRyeVxuICAgICkge1xuICAgICAgaWYgKCBiYWNrc3RhY2tFbnRyeSA9PT0gdm9pZCAwICkgYmFja3N0YWNrRW50cnkgPSBudWxsO1xuXG4gICAgICB2YXIgcGFyZW50RnJhbWUgPSBmaW5kUGFyZW50RnJhbWUodGhpcyk7XG4gICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGZyYW1lOiBwYXJlbnRGcmFtZSA/IHBhcmVudEZyYW1lIDogJ2RlZmF1bHQnXG4gICAgICB9O1xuICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIHZhciBmcmFtZSA9IGdldEZyYW1lSW5zdGFuY2Uob3B0aW9ucy5mcmFtZSk7XG5cbiAgICAgIGZyYW1lLmJhY2soYmFja3N0YWNrRW50cnkpO1xuICAgIH07XG5cbiAgICBWdWUubmF2aWdhdGVUbyA9IFZ1ZS5wcm90b3R5cGUuJG5hdmlnYXRlVG8gPSBmdW5jdGlvbiAoY29tcG9uZW50LCBvcHRpb25zKSB7XG4gICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGZyYW1lOiAnZGVmYXVsdCdcbiAgICAgIH07XG4gICAgICAvLyBidWlsZCBvcHRpb25zIG9iamVjdCB3aXRoIGRlZmF1bHRzXG4gICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIGZyYW1lID0gZ2V0RnJhbWVJbnN0YW5jZShvcHRpb25zLmZyYW1lKTtcbiAgICAgICAgdmFyIGtleSA9IHNlcmlhbGl6ZU5hdmlnYXRpb25PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgbmF2RW50cnlJbnN0YW5jZSA9IG5ldyBWdWUoe1xuICAgICAgICAgIGFic3RyYWN0OiB0cnVlLFxuICAgICAgICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgICAgICAgbmFtZTogJ05hdmlnYXRpb25FbnRyeScsXG4gICAgICAgICAgcGFyZW50OiBmcmFtZSxcbiAgICAgICAgICBmcmFtZTogZnJhbWUsXG4gICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoaCkgeyByZXR1cm4gaChjb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgcHJvcHM6IG9wdGlvbnMucHJvcHMsXG4gICAgICAgICAgICAgIGtleToga2V5XG4gICAgICAgICAgICB9KTsgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhZ2UgPSBuYXZFbnRyeUluc3RhbmNlLiRtb3VudCgpLiRlbC5uYXRpdmVWaWV3O1xuXG4gICAgICAgIHVwZGF0ZURldnRvb2xzKCk7XG5cbiAgICAgICAgdmFyIHJlc29sdmVPbkV2ZW50ID0gb3B0aW9ucy5yZXNvbHZlT25FdmVudDtcbiAgICAgICAgLy8gZW5zdXJlIHdlIGRvbnQgcmVzb2x2ZSB0d2ljZSBldmVudCB0aG91Z2ggdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIVxuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcblxuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgaWYgKGFyZ3MuaXNCYWNrTmF2aWdhdGlvbikge1xuICAgICAgICAgICAgcGFnZS5vZmYoJ25hdmlnYXRlZEZyb20nLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIG5hdkVudHJ5SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHBhZ2Uub24oJ25hdmlnYXRlZEZyb20nLCBoYW5kbGVyKTtcblxuICAgICAgICBpZiAocmVzb2x2ZU9uRXZlbnQpIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZUhhbmRsZXIgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHJlc29sdmUocGFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWdlLm9mZihyZXNvbHZlT25FdmVudCwgcmVzb2x2ZUhhbmRsZXIpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcGFnZS5vbihyZXNvbHZlT25FdmVudCwgcmVzb2x2ZUhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIG5hdkVudHJ5SW5zdGFuY2UgdnVlIGluc3RhbmNlIGlzIGRlc3Ryb3llZCB3aGVuIHRoZVxuICAgICAgICAvLyBwYWdlIGlzIGRpc3Bvc2VkIChjbGVhckhpc3Rvcnk6IHRydWUgZm9yIGV4YW1wbGUpXG4gICAgICAgIHZhciBkaXNwb3NlID0gcGFnZS5kaXNwb3NlTmF0aXZlVmlldztcbiAgICAgICAgcGFnZS5kaXNwb3NlTmF0aXZlVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICBuYXZFbnRyeUluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICAgICAgZGlzcG9zZS5jYWxsKHBhZ2UsIGFyZ3MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZyYW1lLm5hdmlnYXRlKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgY3JlYXRlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYWdlOyB9IH0pKTtcbiAgICAgICAgaWYgKCFyZXNvbHZlT25FdmVudCkge1xuICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlKHBhZ2UpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH1cbn07XG5cblZ1ZS5jb25maWcuc2lsZW50ID0gdHJ1ZTtcblZ1ZS5jb25maWcuc3VwcHJlc3NSZW5kZXJMb2dzID0gZmFsc2U7XG5cbnNldFZ1ZShWdWUpO1xuXG5WdWUudXNlKE1vZGFsUGx1Z2luKTtcblZ1ZS51c2UoTmF2aWdhdG9yUGx1Z2luKTtcblxuZ2xvYmFsLl9fb25MaXZlU3luY0NvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmcmFtZSA9IHJlcXVpcmUoJ0BuYXRpdmVzY3JpcHQvY29yZScpLkZyYW1lLnRvcG1vc3QoKTtcbiAgaWYgKGZyYW1lKSB7XG4gICAgaWYgKGZyYW1lLmN1cnJlbnRQYWdlICYmIGZyYW1lLmN1cnJlbnRQYWdlLm1vZGFsKSB7XG4gICAgICBmcmFtZS5jdXJyZW50UGFnZS5tb2RhbC5jbG9zZU1vZGFsKCk7XG4gICAgfVxuXG4gICAgaWYgKGZyYW1lLmN1cnJlbnRQYWdlKSB7XG4gICAgICBmcmFtZS5jdXJyZW50UGFnZS5hZGRDc3NGaWxlKFxuICAgICAgICByZXF1aXJlKCdAbmF0aXZlc2NyaXB0L2NvcmUnKS5BcHBsaWNhdGlvbi5nZXRDc3NGaWxlTmFtZSgpXG4gICAgICApO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWdWU7XG4iLCJ2YXIgVnVlIC8vIGxhdGUgYmluZFxudmFyIHZlcnNpb25cbnZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd2luZG93Ll9fVlVFX0hPVF9NQVBfXyA9IG1hcFxufVxudmFyIGluc3RhbGxlZCA9IGZhbHNlXG52YXIgaXNCcm93c2VyaWZ5ID0gZmFsc2VcbnZhciBpbml0SG9va05hbWUgPSAnYmVmb3JlQ3JlYXRlJ1xuXG5leHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbiAodnVlLCBicm93c2VyaWZ5KSB7XG4gIGlmIChpbnN0YWxsZWQpIHsgcmV0dXJuIH1cbiAgaW5zdGFsbGVkID0gdHJ1ZVxuXG4gIFZ1ZSA9IHZ1ZS5fX2VzTW9kdWxlID8gdnVlLmRlZmF1bHQgOiB2dWVcbiAgdmVyc2lvbiA9IFZ1ZS52ZXJzaW9uLnNwbGl0KCcuJykubWFwKE51bWJlcilcbiAgaXNCcm93c2VyaWZ5ID0gYnJvd3NlcmlmeVxuXG4gIC8vIGNvbXBhdCB3aXRoIDwgMi4wLjAtYWxwaGEuN1xuICBpZiAoVnVlLmNvbmZpZy5fbGlmZWN5Y2xlSG9va3MuaW5kZXhPZignaW5pdCcpID4gLTEpIHtcbiAgICBpbml0SG9va05hbWUgPSAnaW5pdCdcbiAgfVxuXG4gIGV4cG9ydHMuY29tcGF0aWJsZSA9IHZlcnNpb25bMF0gPj0gMlxuICBpZiAoIWV4cG9ydHMuY29tcGF0aWJsZSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdbSE1SXSBZb3UgYXJlIHVzaW5nIGEgdmVyc2lvbiBvZiB2dWUtaG90LXJlbG9hZC1hcGkgdGhhdCBpcyAnICtcbiAgICAgICAgJ29ubHkgY29tcGF0aWJsZSB3aXRoIFZ1ZS5qcyBjb3JlIF4yLjAuMC4nXG4gICAgKVxuICAgIHJldHVyblxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVjb3JkIGZvciBhIGhvdCBtb2R1bGUsIHdoaWNoIGtlZXBzIHRyYWNrIG9mIGl0cyBjb25zdHJ1Y3RvclxuICogYW5kIGluc3RhbmNlc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5leHBvcnRzLmNyZWF0ZVJlY29yZCA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xuICBpZihtYXBbaWRdKSB7IHJldHVybiB9XG5cbiAgdmFyIEN0b3IgPSBudWxsXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIEN0b3IgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9uc1xuICB9XG4gIG1ha2VPcHRpb25zSG90KGlkLCBvcHRpb25zKVxuICBtYXBbaWRdID0ge1xuICAgIEN0b3I6IEN0b3IsXG4gICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICBpbnN0YW5jZXM6IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBtb2R1bGUgaXMgcmVjb3JkZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqL1xuXG5leHBvcnRzLmlzUmVjb3JkZWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIHR5cGVvZiBtYXBbaWRdICE9PSAndW5kZWZpbmVkJ1xufVxuXG4vKipcbiAqIE1ha2UgYSBDb21wb25lbnQgb3B0aW9ucyBvYmplY3QgaG90LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBtYWtlT3B0aW9uc0hvdChpZCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgdmFyIHJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiAoaCwgY3R4KSB7XG4gICAgICB2YXIgaW5zdGFuY2VzID0gbWFwW2lkXS5pbnN0YW5jZXNcbiAgICAgIGlmIChjdHggJiYgaW5zdGFuY2VzLmluZGV4T2YoY3R4LnBhcmVudCkgPCAwKSB7XG4gICAgICAgIGluc3RhbmNlcy5wdXNoKGN0eC5wYXJlbnQpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVuZGVyKGgsIGN0eClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaW5qZWN0SG9vayhvcHRpb25zLCBpbml0SG9va05hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlY29yZCA9IG1hcFtpZF1cbiAgICAgIGlmICghcmVjb3JkLkN0b3IpIHtcbiAgICAgICAgcmVjb3JkLkN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yXG4gICAgICB9XG4gICAgICByZWNvcmQuaW5zdGFuY2VzLnB1c2godGhpcylcbiAgICB9KVxuICAgIGluamVjdEhvb2sob3B0aW9ucywgJ2JlZm9yZURlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbnN0YW5jZXMgPSBtYXBbaWRdLmluc3RhbmNlc1xuICAgICAgaW5zdGFuY2VzLnNwbGljZShpbnN0YW5jZXMuaW5kZXhPZih0aGlzKSwgMSlcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogSW5qZWN0IGEgaG9vayB0byBhIGhvdCByZWxvYWRhYmxlIGNvbXBvbmVudCBzbyB0aGF0XG4gKiB3ZSBjYW4ga2VlcCB0cmFjayBvZiBpdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhvb2tcbiAqL1xuXG5mdW5jdGlvbiBpbmplY3RIb29rKG9wdGlvbnMsIG5hbWUsIGhvb2spIHtcbiAgdmFyIGV4aXN0aW5nID0gb3B0aW9uc1tuYW1lXVxuICBvcHRpb25zW25hbWVdID0gZXhpc3RpbmdcbiAgICA/IEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpID8gZXhpc3RpbmcuY29uY2F0KGhvb2spIDogW2V4aXN0aW5nLCBob29rXVxuICAgIDogW2hvb2tdXG59XG5cbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKGlkLCBhcmcpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIFZ1ZSBjb21wb25lbnQgaG90LXJlbG9hZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuJ1xuICAgICAgKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zIChvbGRPcHRpb25zLCBuZXdPcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvbGRPcHRpb25zKSB7XG4gICAgaWYgKCEoa2V5IGluIG5ld09wdGlvbnMpKSB7XG4gICAgICBkZWxldGUgb2xkT3B0aW9uc1trZXldXG4gICAgfVxuICB9XG4gIGZvciAodmFyIGtleSQxIGluIG5ld09wdGlvbnMpIHtcbiAgICBvbGRPcHRpb25zW2tleSQxXSA9IG5ld09wdGlvbnNba2V5JDFdXG4gIH1cbn1cblxuZXhwb3J0cy5yZXJlbmRlciA9IHRyeVdyYXAoZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG4gIHZhciByZWNvcmQgPSBtYXBbaWRdXG4gIGlmICghb3B0aW9ucykge1xuICAgIHJlY29yZC5pbnN0YW5jZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UuJGZvcmNlVXBkYXRlKClcbiAgICB9KVxuICAgIHJldHVyblxuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zLm9wdGlvbnNcbiAgfVxuICBpZiAocmVjb3JkLkN0b3IpIHtcbiAgICByZWNvcmQuQ3Rvci5vcHRpb25zLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgcmVjb3JkLkN0b3Iub3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZuc1xuICAgIHJlY29yZC5pbnN0YW5jZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UuJG9wdGlvbnMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICAgIGluc3RhbmNlLiRvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zXG4gICAgICAvLyByZXNldCBzdGF0aWMgdHJlZXNcbiAgICAgIC8vIHByZSAyLjUsIGFsbCBzdGF0aWMgdHJlZXMgYXJlIGNhY2hlZCB0b2dldGhlciBvbiB0aGUgaW5zdGFuY2VcbiAgICAgIGlmIChpbnN0YW5jZS5fc3RhdGljVHJlZXMpIHtcbiAgICAgICAgaW5zdGFuY2UuX3N0YXRpY1RyZWVzID0gW11cbiAgICAgIH1cbiAgICAgIC8vIDIuNS4wXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWNvcmQuQ3Rvci5vcHRpb25zLmNhY2hlZCkpIHtcbiAgICAgICAgcmVjb3JkLkN0b3Iub3B0aW9ucy5jYWNoZWQgPSBbXVxuICAgICAgfVxuICAgICAgLy8gMi41LjNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGluc3RhbmNlLiRvcHRpb25zLmNhY2hlZCkpIHtcbiAgICAgICAgaW5zdGFuY2UuJG9wdGlvbnMuY2FjaGVkID0gW11cbiAgICAgIH1cblxuICAgICAgLy8gcG9zdCAyLjUuNDogdi1vbmNlIHRyZWVzIGFyZSBjYWNoZWQgb24gaW5zdGFuY2UuX3N0YXRpY1RyZWVzLlxuICAgICAgLy8gUHVyZSBzdGF0aWMgdHJlZXMgYXJlIGNhY2hlZCBvbiB0aGUgc3RhdGljUmVuZGVyRm5zIGFycmF5XG4gICAgICAvLyAoYm90aCBhbHJlYWR5IHJlc2V0IGFib3ZlKVxuXG4gICAgICAvLyAyLjY6IHRlbXBvcmFyaWx5IG1hcmsgcmVuZGVyZWQgc2NvcGVkIHNsb3RzIGFzIHVuc3RhYmxlIHNvIHRoYXRcbiAgICAgIC8vIGNoaWxkIGNvbXBvbmVudHMgY2FuIGJlIGZvcmNlZCB0byB1cGRhdGVcbiAgICAgIHZhciByZXN0b3JlID0gcGF0Y2hTY29wZWRTbG90cyhpbnN0YW5jZSlcbiAgICAgIGluc3RhbmNlLiRmb3JjZVVwZGF0ZSgpXG4gICAgICBpbnN0YW5jZS4kbmV4dFRpY2socmVzdG9yZSlcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIC8vIGZ1bmN0aW9uYWwgb3Igbm8gaW5zdGFuY2UgY3JlYXRlZCB5ZXRcbiAgICByZWNvcmQub3B0aW9ucy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgIHJlY29yZC5vcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zXG5cbiAgICAvLyBoYW5kbGUgZnVuY3Rpb25hbCBjb21wb25lbnQgcmUtcmVuZGVyXG4gICAgaWYgKHJlY29yZC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIHJlcmVuZGVyIHdpdGggZnVsbCBvcHRpb25zXG4gICAgICBpZiAoT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoID4gMikge1xuICAgICAgICB1cGRhdGVPcHRpb25zKHJlY29yZC5vcHRpb25zLCBvcHRpb25zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGVtcGxhdGUtb25seSByZXJlbmRlci5cbiAgICAgICAgLy8gbmVlZCB0byBpbmplY3QgdGhlIHN0eWxlIGluamVjdGlvbiBjb2RlIGZvciBDU1MgbW9kdWxlc1xuICAgICAgICAvLyB0byB3b3JrIHByb3Blcmx5LlxuICAgICAgICB2YXIgaW5qZWN0U3R5bGVzID0gcmVjb3JkLm9wdGlvbnMuX2luamVjdFN0eWxlc1xuICAgICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgICAgdmFyIHJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICAgICAgcmVjb3JkLm9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gKGgsIGN0eCkge1xuICAgICAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwoY3R4KVxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcihoLCBjdHgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWNvcmQub3B0aW9ucy5fQ3RvciA9IG51bGxcbiAgICAgIC8vIDIuNS4zXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWNvcmQub3B0aW9ucy5jYWNoZWQpKSB7XG4gICAgICAgIHJlY29yZC5vcHRpb25zLmNhY2hlZCA9IFtdXG4gICAgICB9XG4gICAgICByZWNvcmQuaW5zdGFuY2VzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UuJGZvcmNlVXBkYXRlKClcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KVxuXG5leHBvcnRzLnJlbG9hZCA9IHRyeVdyYXAoZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG4gIHZhciByZWNvcmQgPSBtYXBbaWRdXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucy5vcHRpb25zXG4gICAgfVxuICAgIG1ha2VPcHRpb25zSG90KGlkLCBvcHRpb25zKVxuICAgIGlmIChyZWNvcmQuQ3Rvcikge1xuICAgICAgaWYgKHZlcnNpb25bMV0gPCAyKSB7XG4gICAgICAgIC8vIHByZXNlcnZlIHByZSAyLjIgYmVoYXZpb3IgZm9yIGdsb2JhbCBtaXhpbiBoYW5kbGluZ1xuICAgICAgICByZWNvcmQuQ3Rvci5leHRlbmRPcHRpb25zID0gb3B0aW9uc1xuICAgICAgfVxuICAgICAgdmFyIG5ld0N0b3IgPSByZWNvcmQuQ3Rvci5zdXBlci5leHRlbmQob3B0aW9ucylcbiAgICAgIC8vIHByZXZlbnQgcmVjb3JkLm9wdGlvbnMuX0N0b3IgZnJvbSBiZWluZyBvdmVyd3JpdHRlbiBhY2NpZGVudGFsbHlcbiAgICAgIG5ld0N0b3Iub3B0aW9ucy5fQ3RvciA9IHJlY29yZC5vcHRpb25zLl9DdG9yXG4gICAgICByZWNvcmQuQ3Rvci5vcHRpb25zID0gbmV3Q3Rvci5vcHRpb25zXG4gICAgICByZWNvcmQuQ3Rvci5jaWQgPSBuZXdDdG9yLmNpZFxuICAgICAgcmVjb3JkLkN0b3IucHJvdG90eXBlID0gbmV3Q3Rvci5wcm90b3R5cGVcbiAgICAgIGlmIChuZXdDdG9yLnJlbGVhc2UpIHtcbiAgICAgICAgLy8gdGVtcG9yYXJ5IGdsb2JhbCBtaXhpbiBzdHJhdGVneSB1c2VkIGluIDwgMi4wLjAtYWxwaGEuNlxuICAgICAgICBuZXdDdG9yLnJlbGVhc2UoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVPcHRpb25zKHJlY29yZC5vcHRpb25zLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuICByZWNvcmQuaW5zdGFuY2VzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpZiAoaW5zdGFuY2UuJHZub2RlICYmIGluc3RhbmNlLiR2bm9kZS5jb250ZXh0KSB7XG4gICAgICBpbnN0YW5jZS4kdm5vZGUuY29udGV4dC4kZm9yY2VVcGRhdGUoKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLidcbiAgICAgIClcbiAgICB9XG4gIH0pXG59KVxuXG4vLyAyLjYgb3B0aW1pemVzIHRlbXBsYXRlLWNvbXBpbGVkIHNjb3BlZCBzbG90cyBhbmQgc2tpcHMgdXBkYXRlcyBpZiBjaGlsZFxuLy8gb25seSB1c2VzIHNjb3BlZCBzbG90cy4gV2UgbmVlZCB0byBwYXRjaCB0aGUgc2NvcGVkIHNsb3RzIHJlc29sdmluZyBoZWxwZXJcbi8vIHRvIHRlbXBvcmFyaWx5IG1hcmsgYWxsIHNjb3BlZCBzbG90cyBhcyB1bnN0YWJsZSBpbiBvcmRlciB0byBmb3JjZSBjaGlsZFxuLy8gdXBkYXRlcy5cbmZ1bmN0aW9uIHBhdGNoU2NvcGVkU2xvdHMgKGluc3RhbmNlKSB7XG4gIGlmICghaW5zdGFuY2UuX3UpIHsgcmV0dXJuIH1cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9ibG9iL2Rldi9zcmMvY29yZS9pbnN0YW5jZS9yZW5kZXItaGVscGVycy9yZXNvbHZlLXNjb3BlZC1zbG90cy5qc1xuICB2YXIgb3JpZ2luYWwgPSBpbnN0YW5jZS5fdVxuICBpbnN0YW5jZS5fdSA9IGZ1bmN0aW9uIChzbG90cykge1xuICAgIHRyeSB7XG4gICAgICAvLyAyLjYuNCB+IDIuNi42XG4gICAgICByZXR1cm4gb3JpZ2luYWwoc2xvdHMsIHRydWUpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gMi41IC8gPj0gMi42LjdcbiAgICAgIHJldHVybiBvcmlnaW5hbChzbG90cywgbnVsbCwgdHJ1ZSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpbnN0YW5jZS5fdSA9IG9yaWdpbmFsXG4gIH1cbn1cbiIsIi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAob3B0aW9ucy5mdW5jdGlvbmFsID8gdGhpcy5wYXJlbnQgOiB0aGlzKS4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIDogaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9